//=============================================================================
//       ___  ___  __            __   __  
// |__/ |__  |__  |__)     |\/| /  \ |  \
// |  \ |___ |___ |        |  | \__/ |__/                                                    
//
// Compiled by Qmaster
//
// Attributions: Spike, aka Spoike, aka the creator of FTEQW and FTEQCCGUI
//
//
// Distribution / Copyright / Permissions 
//
// Please do not use any of these assets in ANY COMMERCIAL PROJECT.
// and remember to give credit if you use any of these assets. Please credit
// the appropriate authors of the various content used.  Refer to the credits
// folder.
//				  
// The QC files in this MOD are based on 1.06 source files by ID Software.
// These files are released under the terms of GNU General Public License v2 or
// later. You may use the source files as a base to build your own MODs as long
// as you release them under the same license and make the source available.
// Please also give proper credit. Check http://www.gnu.org for details.
//
// Quake is a registered trademark of id Software, Inc.
//
// All of these resources may be electronically distributed only at 
// NO CHARGE to the recipient.
//
// Stats:
// Entity count: 0
// Function count: 0
// Builtin Function count: 380
//
// Implements: FTE (and some QSS) Engine specific API functions and definitions
//
// Description:
// Definitions for various helper functions, csqc hooks, and special effects.
//
// Ok what follows is autogenerated and does not conform to my coding
// standards.  Look away boys and girls!  This is not the proper code we know
// and love!  But hey at least Spike is cool enough to autogenerate stuff.
// And make a ridiculously awesome engine or two.
//
// This file was generated by FTE Quake 5570, dated Oct 18 2019.
// This file can be regenerated by issuing the following command:
// pr_dumpplatform -o fteextensions
//=============================================================================

/* Available options:
-Ffte       - target only FTE (optimations and additional extensions)
-Tnq        - dump specifically NQ fields
-Tqw        - dump specifically QW fields
-Tcs        - dump specifically CSQC fields
-Tmenu      - dump specifically menuqc fields
-Fdefines   - generate #defines instead of constants
-Faccessors - use accessors instead of basic types via defines
-O          - write to a different qc file
*/
#pragma noref 1
// #pragma warning error Q101 /*too many parms. The vanilla qcc didn't validate properly, hence why fteqcc normally treats it as a warning.*/
// #pragma warning error Q105 /*too few parms. The vanilla qcc didn't validate properly, hence why fteqcc normally treats it as a warning.*/
// #pragma warning error Q106 /*assignment to constant/lvalue. Define them as var if you want to initialise something.*/
// #pragma warning error Q208 /*system crc unknown. Compatibility goes out of the window if you disable this.*/
// #pragma warning disable F211 /*system crc outdated (eg: dp's csqc). Note that this may trigger emulation.*/
// #pragma warning enable F301 /*non-utf-8 strings. Think of the foreigners! Also think of text editors that insist on screwing up your char encodings.*/
// #pragma warning enable F302 /*uninitialised locals. They usually default to 0 in qc (except in recursive functions), but its still probably a bug*/
#if !defined(CSQC) && !defined(NQSSQC) && !defined(QWSSQC)&& !defined(MENU)
	#ifdef QUAKEWORLD
		#define QWSSQC
	#else
		#define NQSSQC
	#endif
#endif
#if !defined(SSQC) && (defined(QWSSQC) || defined(NQSSQC))
	#define SSQC
#endif
#define FTE_PEXT_SETVIEW /* NQ's svc_setview works correctly even in quakeworld */
#define DP_ENT_SCALE
#define FTE_PEXT_LIGHTSTYLECOL
#define DP_ENT_ALPHA
#define FTE_PEXT_VIEW2
#define FTE_PEXT_ACURATETIMINGS
#define FTE_PEXT_SOUNDDBL
#define FTE_PEXT_FATNESS
#define DP_HALFLIFE_MAP
#define FTE_PEXT_TE_BULLET
#define FTE_PEXT_HULLSIZE
#define FTE_PEXT_MODELDBL
#define FTE_PEXT_ENTITYDBL
#define FTE_PEXT_ENTITYDBL2
#define FTE_PEXT_FLOATCOORDS
#define FTE_PEXT_VWEAP
#define FTE_PEXT_Q2BSP
#define FTE_PEXT_Q3BSP
#define DP_ENT_COLORMOD
#define FTE_HEXEN2
#define FTE_PEXT_SPAWNSTATIC
#define FTE_PEXT_CUSTOMTENTS
#define FTE_PEXT_256PACKETENTITIES
#define TEI_SHOWLMP2
#define DP_GFX_QUAKE3MODELTAGS
#define FTE_PK3DOWNLOADS
#define PEXT_CHUNKEDDOWNLOADS
#define EXT_CSQC_SHARED
#define PEXT_DPFLAGS
#define EXT_CSQC
#define BX_COLOREDTEXT
#define DP_CON_SET /* The 'set' console command exists, and can be used to create/set cvars. */
#define DP_CON_SETA /* The 'seta' console command exists, like the 'set' command, but also marks the cvar for archiving, allowing it to be written into the user's config. Use this command in your default.cfg file. */
#define DP_EF_ADDITIVE
#define DP_EF_BLUE
#define DP_EF_FULLBRIGHT
#define DP_EF_NODEPTHTEST
#define DP_EF_NODRAW
#define DP_EF_NOGUNBOB
#define DP_EF_NOSHADOW
#define DP_EF_RED
#define DP_ENT_CUSTOMCOLORMAP
#define DP_ENT_EXTERIORMODELTOCLIENT
#define DP_ENT_TRAILEFFECTNUM /* self.traileffectnum=particleeffectnum("myeffectname"); can be used to attach a particle trail to the given server entity. This is equivelent to calling trailparticles each frame. */
#define DP_ENT_VIEWMODEL
#define DP_GECKO_SUPPORT
#define DP_GFX_FONTS
#define DP_GFX_SKINFILES
#define DP_GFX_SKYBOX
#define DP_HALFLIFE_MAP_CVAR
#define DP_INPUTBUTTONS
#define DP_LIGHTSTYLE_STATICVALUE
#define DP_LITSUPPORT
#define DP_MONSTERWALK /* MOVETYPE_WALK is valid on non-player entities. Note that only players receive acceleration etc in line with none/bounce/fly/noclip movetypes on the player, thus you will have to provide your own accelerations (incluing gravity) yourself. */
#define DP_MOVETYPEBOUNCEMISSILE
#define DP_MOVETYPEFOLLOW
#define DP_QC_ASINACOSATANATAN2TAN
#define DP_QC_CHANGEPITCH
#define DP_QC_COPYENTITY
#define DP_QC_CRC16
#define DP_QC_CVAR_DEFSTRING
#define DP_QC_CVAR_STRING
#define DP_QC_CVAR_TYPE
#define DP_QC_EDICT_NUM
#define DP_QC_ENTITYDATA
#define DP_QC_ETOS
#define DP_QC_FINDCHAIN
#define DP_QC_FINDCHAINFLOAT
#define DP_QC_FINDFLAGS
#define DP_QC_FINDCHAINFLAGS
#define DP_QC_FINDFLOAT
#define DP_QC_FS_SEARCH
#define DP_QC_GETSURFACE
#define DP_QC_GETSURFACEPOINTATTRIBUTE
#define DP_QC_GETTAGINFO
#define DP_QC_MINMAXBOUND
#define DP_QC_MULTIPLETEMPSTRINGS /* Superseded by DP_QC_UNLIMITEDTEMPSTRINGS. Functions that return a temporary string will not overwrite/destroy previous temporary strings until at least 16 strings are returned (or control returns to the engine). */
#define DP_QC_RANDOMVEC
#define DP_QC_RENDER_SCENE /* clearscene+addentity+setviewprop+renderscene+setmodel are available to menuqc. WARNING: DP advertises this extension without actually supporting it, FTE does actually support it. */
#define DP_QC_SINCOSSQRTPOW
#define DP_QC_SPRINTF /* Provides the sprintf builtin, which allows for rich formatting along the lines of C's function with the same name. Not to be confused with QC's sprint builtin. */
#define DP_QC_STRFTIME
#define DP_QC_STRING_CASE_FUNCTIONS
#define DP_QC_STRINGBUFFERS
#define DP_QC_STRINGCOLORFUNCTIONS
#define DP_QC_STRREPLACE
#define DP_QC_TOKENIZEBYSEPARATOR
#define DP_QC_TRACEBOX
#define DP_QC_TRACETOSS
#define DP_QC_TRACE_MOVETYPE_HITMODEL
#define DP_QC_TRACE_MOVETYPE_WORLDONLY
#define DP_QC_TRACE_MOVETYPES
#define DP_QC_UNLIMITEDTEMPSTRINGS /* Supersedes DP_QC_MULTIPLETEMPSTRINGS, superseded by FTE_QC_PERSISTENTTEMPSTRINGS. Specifies that all temp strings will be valid at least until the QCVM returns. */
#define DP_QC_URI_ESCAPE
#define DP_QC_URI_GET
#define DP_QC_URI_POST
#define DP_QC_VECTOANGLES_WITH_ROLL
#define DP_QC_VECTORVECTORS
#define DP_QC_WHICHPACK
#define DP_QUAKE2_MODEL
#define DP_QUAKE2_SPRITE
#define DP_QUAKE3_MODEL
#define DP_REGISTERCVAR
#define DP_SND_SOUND7_WIP2
#define DP_SND_STEREOWAV
#define DP_SND_OGGVORBIS
#define DP_SOLIDCORPSE
#define DP_SPRITE32
#define DP_SV_BOTCLIENT
#define DP_SV_CLIENTCAMERA /* Works like svc_setview except also handles pvs. */
#define DP_SV_CLIENTCOLORS /* Provided only for compatibility with DP. */
#define DP_SV_CLIENTNAME /* Provided only for compatibility with DP. */
#define DP_SV_DRAWONLYTOCLIENT
#define DP_SV_DROPCLIENT /* Equivelent to quakeworld's stuffcmd(self,"disconnect\n"); hack */
#define DP_SV_EFFECT
#define DP_SV_EXTERIORMODELFORCLIENT
#define DP_SV_NODRAWTOCLIENT
#define DP_SV_PLAYERPHYSICS /* Allows reworking parts of NQ player physics. USE AT OWN RISK - this necessitates NQ physics and is thus guarenteed to break prediction. */
#define DP_SV_POINTSOUND
#define DP_SV_PRECACHEANYTIME /* Specifies that the various precache builtins can be called at any time. WARNING: precaches are sent reliably while sound events, modelindexes, and particle events are not. This can mean sounds and particles might not work the first time around, or models may take a while to appear (after the reliables are received and the model is loaded from disk). Always attempt to precache a little in advance in order to reduce these issues (preferably at the start of the map...) */
#define DP_SV_PRINT /* Says that the print builtin can be used from nqssqc (as well as just csqc), bypassing the developer cvar issues. */
#define DP_SV_SETCOLOR
#define DP_SV_SPAWNFUNC_PREFIX
#define DP_SV_WRITEPICTURE
#define DP_SV_WRITEUNTERMINATEDSTRING
#define DP_TE_BLOOD
#define DP_TE_CUSTOMFLASH
#define DP_TE_EXPLOSIONRGB
#define DP_TE_PARTICLECUBE
#define DP_TE_PARTICLERAIN
#define DP_TE_PARTICLESNOW
#define DP_TE_SMALLFLASH
#define DP_TE_SPARK
#define DP_TE_STANDARDEFFECTBUILTINS
#define DP_VIEWZOOM
#define EXT_BITSHIFT
#define EXT_DIMENSION_VISIBILITY
#define EXT_DIMENSION_PHYSICS
#define EXT_DIMENSION_GHOST
#define FRIK_FILE
#define FTE_CALLTIMEOFDAY /* Replication of mvdsv functionality (call calltimeofday to cause 'timeofday' to be called, with arguments that can be saved off to a global). Generally strftime is simpler to use. */
#define FTE_CSQC_ALTCONSOLES /* The engine tracks multiple consoles. These may or may not be directly visible to the user. */
#define FTE_CSQC_BASEFRAME /* Specifies that .basebone, .baseframe2, .baselerpfrac, baseframe1time, etc exist in csqc. These fields affect all bones in the entity's model with a lower index than the .basebone field, allowing you to give separate control to the legs of a skeletal model, without affecting the torso animations. */
#define FTE_CSQC_HALFLIFE_MODELS
#define FTE_CSQC_SERVERBROWSER /* Provides builtins to query the engine's serverbrowser servers list from ssqc. Note that these builtins are always available in menuqc. */
#define FTE_CSQC_SKELETONOBJECTS /* Provides container objects for skeletal bone data, which can be modified on a per bone basis if needed. This allows you to dynamically generate animations (or just blend them with greater customisation) instead of being limited to a single animation or two. */
#define FTE_CSQC_RAWIMAGES /* Provides raw rgba image access to csqc. With this, the csprogs can read textures into qc-accessible memory, modify it, and then upload it to the renderer. */
#define FTE_CSQC_RENDERTARGETS /* VF_RT_DESTCOLOUR exists and can be used to redirect any rendering to a texture instead of the screen. */
#define FTE_CSQC_REVERB /* Specifies that the mod can create custom reverb effects. Whether they will actually be used or not depends upon the sound driver. */
#define FTE_CSQC_WINDOWCAPTION /* Provides csqc with the ability to change the window caption as displayed when running windowed or in the task bar when switched out. */
#define FTE_ENT_SKIN_CONTENTS /* self.skin = CONTENTS_WATER; makes a brush entity into water. use -16 for a ladder. */
#define FTE_ENT_UNIQUESPAWNID
#define FTE_EXTENDEDTEXTCODES
#define FTE_FORCESHADER /* Allows csqc to override shaders on models with an explicitly named replacement. Also allows you to define shaders with a fallback if it does not exist on disk. */
#define FTE_FORCEINFOKEY /* Provides an easy way to change a user's userinfo from the server. */
#define FTE_GFX_QUAKE3SHADERS /* specifies that the engine has full support for vanilla quake3 shaders */
#define FTE_GFX_REMAPSHADER /* With the raw power of stuffcmds, the r_remapshader console command is exposed! This mystical command can be used to remap any shader to another. Remapped shaders that specify $diffuse etc in some form will inherit the textures implied by the surface. */
#define FTE_GFX_MODELEVENTS /* Provides a query for per-animation events in model files, including from progs/foo.mdl.events files. */
#define FTE_ISBACKBUFFERED /* Allows you to check if a client has too many reliable messages pending. */
#define FTE_MEMALLOC /* Allows dynamically allocating memory. Use pointers to access this memory. Memory will not be saved into saved games. */
#define FTE_MEDIA_CIN /* playfilm command supports q2 cin files. */
#define FTE_MEDIA_ROQ /* playfilm command supports q3 roq files. */
#define FTE_MULTIPROGS /* Multiple progs.dat files can be loaded inside the same qcvm. Insert new ones with addprogs inside the 'init' function, and use externvalue+externset to rewrite globals (and hook functions) to link them together. Note that the result is generally not very clean unless you carefully design for it beforehand. */
#define FTE_MULTITHREADED /* Faux multithreading, allowing multiple contexts to run in sequence. */
#define FTE_MVD_PLAYERSTATS /* In csqc, getplayerstat can be used to query any player's stats when playing back MVDs. isdemo will return 2 in this case. */
#define FTE_PART_SCRIPT /* Specifies that the r_particledesc cvar can be used to select a list of particle effects to load from particles/*.cfg, the format of which is documented elsewhere. */
#define FTE_PART_NAMESPACES /* Specifies that the engine can use foo.bar to load effect foo from particle description bar. When used via ssqc, this should cause the client to download whatever effects as needed. */
#define FTE_PART_NAMESPACE_EFFECTINFO /* Specifies that effectinfo.bar can load effects from effectinfo.txt for DP compatibility. */
#define FTE_QC_BASEFRAME /* Specifies that .basebone and .baseframe exist in ssqc. These fields affect all bones in the entity's model with a lower index than the .basebone field, allowing you to give separate control to the legs of a skeletal model, without affecting the torso animations, from ssqc. */
#define FTE_QC_FILE_BINARY /* Extends FRIK_FILE with binary read+write, as well as allowing seeking. Requires pointers. */
#define FTE_QC_CHANGELEVEL_HUB /* Adds an extra argument to changelevel which is carried over to the next map in the 'spawnspot' global. Maps will be saved+reloaded until the extra argument is omitted again, purging all saved maps. Saved games will contain a copy of each preserved map. parm1-parm64 globals can be used, giving more space to transfer more player data. */
#define FTE_QC_CHECKCOMMAND /* Provides a way to test if a console command exists, and whether its a command/alias/cvar. Does not say anything about the expected meanings of any arguments or values. */
#define FTE_QC_CHECKPVS
#define FTE_QC_CROSSPRODUCT
#define FTE_QC_CUSTOMSKINS /* The engine supports the use of q3 skins, as well as the use of such skin 'files' to specify rich top+bottom colours, qw skins, geomsets, or texture composition even on non-players.. */
#define FTE_QC_FS_SEARCH_SIZEMTIME
#define FTE_QC_HARDWARECURSORS /* setcursormode exists in both csqc+menuqc, and accepts additional arguments to specify a cursor image to use when this module has focus. If the image exceeds hardware limits (or hardware cursors are unsupported), it will be emulated using regular draws - this at least still avoids conflicting cursors as only one will ever be used, even if console+menu+csqc are all overlayed. */
#define FTE_QC_INFOKEY /* QuakeWorld's infokey builtin works, and reports at least name+topcolor+bottomcolor+ping(in ms)+ip(unmasked, but not always ipv4)+team(aka bottomcolor in nq). Does not require actual localinfo/serverinfo/userinfo, but they're _highly_ recommended to any engines with csqc */
#define FTE_QC_INTCONV /* Provides string<>int conversions, including hex representations. */
#define FTE_QC_MATCHCLIENTNAME
#define FTE_QC_MULTICAST /* QuakeWorld's multicast builtin works along with MSG_MULTICAST, but also with unicast support. */
#define FTE_QC_PAUSED
#define FTE_QC_PERSISTENTTEMPSTRINGS /* Supersedes DP_QC_MULTIPLETEMPSTRINGS. Temp strings are garbage collected automatically, and do not expire while they're still in use. This makes strzone redundant. */
#define FTE_QC_RAGDOLL_WIP
#define FTE_QC_SENDPACKET /* Allows the use of out-of-band udp packets to/from other hosts. Includes the SV_ParseConnectionlessPacket event. */
#define FTE_QC_STUFFCMDFLAGS /* Variation on regular stuffcmd that gives control over how spectators/mvds should be treated. */
#define FTE_QC_TRACETRIGGER
#define FTE_QUAKE2_CLIENT /* This engine is able to act as a quake2 client */
#define FTE_QUAKE2_SERVER /* This engine is able to act as a quake2 server */
#define FTE_QUAKE3_CLIENT /* This engine is able to act as a quake3 client */
#define FTE_QUAKE3_SERVER /* This engine is able to act as a quake3 server */
#define FTE_SPLITSCREEN /* Client supports splitscreen, controlled via cl_splitscreen. Servers require allow_splitscreen 1 if splitscreen is to be used over the internet. Mods that use csqc will need to be aware for this to work properly. per-client networking may be problematic. */
#define FTE_SQL /* Provides sql* builtins which can be used for sql database access */
#define FTE_SQL_SQLITE /* SQL functionality is able to utilise sqlite databases */
#define FTE_STRINGS /* Extra builtins (and additional behaviour) to make string manipulation easier */
#define FTE_SV_POINTPARTICLES /* Specifies that particleeffectnum, pointparticles, and trailparticles exist in ssqc as well as csqc. particleeffectnum acts as a precache, allowing ssqc values to be networked up with csqc for use. Use in combination with FTE_PART_SCRIPT+FTE_PART_NAMESPACES to use custom effects. This extension is functionally identical to the DP version, but avoids any misplaced assumptions about the format of the client's particle descriptions. */
#define FTE_SV_REENTER
#define FTE_TE_STANDARDEFFECTBUILTINS /* Provides builtins to replace writebytes, with a QW compatible twist. */
#define FTE_TERRAIN_MAP /* This engine supports .hmp files, as well as terrain embedded within bsp files. */
#define FTE_RAW_MAP /* This engine supports directly loading .map files, as well as realtime editing of the various brushes. */
#define KRIMZON_SV_PARSECLIENTCOMMAND /* SSQC's SV_ParseClientCommand function is able to handle client 'cmd' commands. The tokenizing parts also work in csqc. */
#define NEH_CMD_PLAY2
#define NEH_RESTOREGAME
#define QSG_CVARSTRING
#define QW_ENGINE
#define QWE_MVD_RECORD /* You can use the easyrecord command to record MVD demos serverside. */
#define TEI_MD3_MODEL
#define TENEBRAE_GFX_DLIGHTS /* Allows ssqc to attach rtlights to entities with various special properties. */
#define ZQ_MOVETYPE_FLY /* MOVETYPE_FLY works on players. */
#define ZQ_MOVETYPE_NOCLIP /* MOVETYPE_NOCLIP works on players. */
#define ZQ_MOVETYPE_NONE /* MOVETYPE_NONE works on players. */
#define ZQ_VWEP
#define ZQ_QC_STRINGS /* The strings-only subset of FRIK_FILE is supported. */
float input_timelength;
vector input_angles;	/* +x=DOWN */
vector input_movevalues;
float input_buttons;
float input_impulse;
.float lastruntime;	/* This field used to be used to avoid running an entity multiple times in a single frame due to quakeworld's out-of-order thinks. It is no longer used by FTE due to precision issues, but may still be updated for compatibility reasons. */
.float pmove_flags;
int trace_endcontents;
int trace_surfaceflags;
int trace_brush_id;
int trace_brush_faceid;
int trace_surface_id;	/* 1-based. 0 if not known. */
int trace_bone_id;	/* 1-based. 0 if not known. typically needs MOVE_HITMODEL. */
int trace_triangle_id;	/* 1-based. 0 if not known. */
vector global_gravitydir = '0 0 -1';	/* The direction gravity should act in if not otherwise specified per entity. */
int serverid;	/* The unique id of this server within the server cluster. */
.float hull;	/* Overrides the hull used by the entity for walkmove/movetogoal and not traceline/tracebox. */
.void() chainmoved;	/* Called when the entity is moved as a result of being part of another entity's .movechain */
.float dimension_solid;	/* This is the bitmask of dimensions which the entity is solid within. */
.float dimension_hit;	/* This is the bitmask of dimensions which the entity will be blocked by. If other.dimension_solid & self.dimension_hit, our traces will impact and not proceed. If its false, the traces will NOT impact, allowing self to pass straight through. */
.int hitcontentsmaski;	/* Traces performed for this entity will impact against surfaces that match this contents mask. */
.float fatness;	/* How many QuakeUnits to push the entity's verticies along their normals by. */
.float basebone;	/* The base* frame animations are equivelent to their non-base versions, except that they only affect bone numbers below the 'basebone' value. This means that the base* animation can affect the legs of a skeletal model independantly of the normal animation fields affecting the torso area. For more complex animation than this, use skeletal objects. */
.float baseframe;	/* See basebone */
.void() customphysics;	/* Called once each physics frame, overriding the entity's .movetype field and associated logic. You'll probably want to use tracebox to move it through the world. Be sure to call .think as appropriate. */
.vector gravitydir;	/* Specifies the direction in which gravity acts. Must be normalised. '0 0 0' also means down. Use '0 0 1' if you want the player to be able to run on ceilings. */
.vector(vector org, vector ang) camera_transform;	/* Provides portal transform information for portal surfaces attached to this entity. Also used to open up pvs in ssqc. */
.float geomtype;
.float friction;
.float erp;
.float drawflags;	/* Various flags that affect lighting values and scaling. Typically set to 96 in quake for proper compatibility with DP_QC_SCALE. */
.float abslight;	/* Allows overriding light levels. Use drawflags to state that this field should actually be used. */
.float maxspeed;
.entity view2;	/* defines a second viewpoint, typically displayed in a corner of the screen (also punches open pvs). */
.float vw_index;	/* This acts as a second modelindex, using the same frames etc. */
.float dimension_see;	/* This is the dimension mask (bitfield) that the client is allowed to see. Entities and events not in this dimension mask will be invisible. */
.float dimension_seen;	/* This is the dimension mask (bitfield) that the client is visible within. Clients that cannot see this dimension mask will not see this entity. */
.float dimension_ghost;	/* If this entity is visible only within these dimensions, it will become transparent, as if a ghost. */
.float dimension_ghost_alpha;	/* If this entity is subject to dimension_ghost, this is the scaler for its alpha value. If 0, 0.5 will be used instead. */
.float(entity playerent, float changedflags) SendEntity;	/* Called by the engine whenever an entity needs to be (re)sent to a client's csprogs, either because SendFlags was set or because data was lost. Must write its data to the MSG_ENTITY buffer. Will be called at the engine's leasure. */
.float SendFlags;	/* Indicates that something in the entity has been changed, and that it needs to be updated to all players that can see it. The engine will clear it at some point, with the cleared bits appearing in the 'changedflags' argument of the SendEntity method. */
.float clientcolors;
.float viewzoom;
.float items2;
.float playerclass;
.float hasted;
.float light_level;	/* Used by hexen2 to indicate the light level where the player is standing. */
.float pvsflags;	/* Reconfigures when the entity is visible to clients */
.float uniquespawnid;	/* Incremented by 1 whenever the entity is respawned. Persists across remove calls, for when the two-second grace period is insufficient. */
.float() customizeentityforclient;	/* Called just before an entity is sent to a client (non-csqc protocol). This gives you a chance to tailor 'self' according to what 'other' should see. */
void(string cmd) SV_ParseClientCommand;	/* Provides QC with a way to intercept 'cmd foo' commands from the client. Very handy. Self will be set to the sending client, while the 'cmd' argument can be tokenize()d and each element retrieved via argv(argno). Unrecognised cmds MUST be passed on to the clientcommand builtin. */
float parm17, parm18, parm19, parm20, parm21, parm22, parm23, parm24, parm25, parm26, parm27, parm28, parm29, parm30, parm31, parm32;	/* Additional spawn parms, following the same parmN theme. */
float parm33, parm34, parm35, parm36, parm37, parm38, parm39, parm40, parm41, parm42, parm43, parm44, parm45, parm46, parm47, parm48;
float parm49, parm50, parm51, parm52, parm53, parm54, parm55, parm56, parm57, parm58, parm59, parm60, parm61, parm62, parm63, parm64;
string parm_string;	/* Like the regular parmN globals, but preserves string contents. */
string startspot;	/* Receives the value of the second argument to changelevel from the previous map. */
var float dimension_send;	/* Used by multicast functionality. Multicasts (and related builtins that multicast internally) will only be sent to players where (player.dimension_see & dimension_send) is non-zero. */
__used var float physics_mode = 2;	/* 0: original csqc - physics are not run 1: DP-compat. Thinks occur, but not true movetypes. 2: movetypes occur just as they do in ssqc. */
var vector drawfontscale = '1 1 0';	/* Specifies a scaler for all text rendering. There are other ways to implement this. */
float drawfont;	/* Allows you to choose exactly which font is to be used to draw text. Fonts can be registered/allocated with the loadfont builtin. */
float FONT_DEFAULT = 0;
float SOLID_PORTAL = 21;	/* CSG subtraction volume combined with entity transformations on impact. */
float SOLID_PHYSICS_CYLINDER = 36;
float GEOMTYPE_NONE = -1;
float GEOMTYPE_SOLID = 0;
float GEOMTYPE_BOX = 1;
float GEOMTYPE_SPHERE = 2;
float GEOMTYPE_CAPSULE = 3;
float GEOMTYPE_TRIMESH = 4;
float GEOMTYPE_CYLINDER = 5;
float GEOMTYPE_CAPSULE_X = 6;
float GEOMTYPE_CAPSULE_Y = 7;
float GEOMTYPE_CAPSULE_Z = 8;
float GEOMTYPE_CYLINDER_X = 9;
float GEOMTYPE_CYLINDER_Y = 10;
float GEOMTYPE_CYLINDER_Z = 11;
int CONTENTBIT_NONE = 0x00000000i;
int CONTENTBIT_SOLID = 0x00000001i;
int CONTENTBIT_LAVA = 0x00000008i;
int CONTENTBIT_SLIME = 0x00000010i;
int CONTENTBIT_WATER = 0x00000020i;
int CONTENTBIT_FTELADDER = 0x00004000i;
int CONTENTBIT_PLAYERCLIP = 0x00010000i;
int CONTENTBIT_MONSTERCLIP = 0x00020000i;
int CONTENTBIT_BODY = 0x02000000i;
int CONTENTBIT_CORPSE = 0x04000000i;
int CONTENTBIT_Q2LADDER = 0x20000000i;	/* Content bit specific to q2bsp */
int CONTENTBIT_SKY = 0x80000000i;
int CONTENTBITS_POINTSOLID = CONTENTBIT_SOLID|0x00000002i|CONTENTBIT_BODY;	/* Bits that traceline would normally consider solid */
int CONTENTBITS_BOXSOLID = CONTENTBIT_SOLID|0x00000002i|CONTENTBIT_BODY|CONTENTBIT_PLAYERCLIP;	/* Bits that tracebox would normally consider solid */
int CONTENTBITS_FLUID = CONTENTBIT_WATER|CONTENTBIT_SLIME|CONTENTBIT_LAVA|CONTENTBIT_SKY;
float CHANF_RELIABLE = 8;	/* Only valid if the flags argument is not specified. The sound will be sent reliably, which is important if it is intended to replace looping sounds on doors etc. */
float SOUNDFLAG_RELIABLE = 1;	/* The sound will be sent reliably, and without regard to phs. */
float SOUNDFLAG_ABSVOLUME = 16;	/* The sample's volume is not scaled by the volume cvar. Use with caution */
float SOUNDFLAG_FORCELOOP = 2;	/* The sound will restart once it reaches the end of the sample. */
float SOUNDFLAG_NOSPACIALISE = 4;	/* The different audio channels are played at the same volume regardless of which way the player is facing, without needing to use 0 attenuation. */
float SOUNDFLAG_NOREVERB = 32;	/* Disables the use of underwater/reverb effects on this sound effect. */
float SOUNDFLAG_FOLLOW = 64;	/* The sound's origin will updated to follow the emitting entity. */
float SOUNDFLAG_UNICAST = 256;	/* The sound will be sent only by the player specified by msg_entity. Spectators and related splitscreen players will also hear the sound. */
float SOUNDFLAG_SENDVELOCITY = 512;	/* The entity's current velocity will be sent to the client, only useful if doppler is enabled. */
const float SVC_CGAMEPACKET = 83;	/* Direct ssqc->csqc message. Must only be multicast. The data triggers a CSQC_Parse_Event call in the csqc for the csqc to read the contents. The server *may* insert length information for clients connected via proxies which are not able to cope with custom csqc payloads. This should only ever be used in conjunction with the MSG_MULTICAST destination. */
const float MSG_MULTICAST = 4;	/* The byte(s) will be written into the multicast buffer for more selective sending. Messages sent this way will never be split across packets, and using this for csqc-only messages will not break protocol translation. */
const float MSG_ENTITY = 5;	/* The byte(s) will be written into the entity buffer. This is a special value used only inside 'SendEntity' functions. */
const float MULTICAST_ALL = 0;	/* The multicast message is unreliably sent to all players. MULTICAST_ constants are valid arguments for the multicast builtin, which ignores the specified origin when given this constant. */
const float MULTICAST_PHS = 1;	/* The multicast message is unreliably sent to only players that can potentially hear the specified origin. Its quite loose. */
const float MULTICAST_PVS = 2;	/* The multicast message is unreliably sent to only players that can potentially see the specified origin. */
const float MULTICAST_ONE = 6;	/* The multicast message is unreliably sent to the player (AND ALL TRACKING SPECTATORS) specified in the msg_entity global. The specified origin is ignored. */
const float MULTICAST_ONE_NOSPECS = 9;	/* The multicast message is unreliably sent to the player specified in the msg_entity global. The specified origin is ignored. */
const float MULTICAST_ALL_R = 3;	/* The multicast message is reliably sent to all players. The specified origin is ignored. */
const float MULTICAST_PHS_R = 4;	/* The multicast message is reliably sent to only players that can potentially hear the specified origin. Players might still not receive it if they are out of range. */
const float MULTICAST_PVS_R = 5;	/* The multicast message is reliably sent to only players that can potentially see the specified origin. Players might still not receive it if they cannot see the event. */
const float MULTICAST_ONE_R = 7;	/* The multicast message is reliably sent to the player (AND ALL TRACKING SPECTATORS) specified in the msg_entity global. The specified origin is ignored */
const float MULTICAST_INIT	= 8;
const float MULTICAST_ONE_R_NOSPECS = 10;	/* The multicast message is reliably sent to the player specified in the msg_entity global. The specified origin is ignored */
const float PRINT_LOW = 0;
const float PRINT_MEDIUM = 1;
const float PRINT_HIGH = 2;
const float PRINT_CHAT = 3;
const float PVSF_NORMALPVS = 0;	/* Filter first by PVS, then filter this entity using tracelines if sv_cullentities is enabled. */
const float PVSF_NOTRACECHECK = 1;	/* Filter strictly by PVS. */
const float PVSF_USEPHS = 2;	/* Send if we're close enough to be able to hear this entity. */
const float PVSF_IGNOREPVS = 3;	/* Ignores pvs. This entity is visible whereever you are on the map. Updates will be sent regardless of pvs or phs */
const float PVSF_NOREMOVE = 128;	/* Once visible to a client, this entity will remain visible. This can be useful for csqc and corpses. While this flag is set, no CSQC_Remove events will be sent for the entity, but this does NOT mean that it will still receive further updates while outside of the pvs. */
const string INFOKEY_P_IP = "ip";	/* The apparent ip address of the client. This may be a proxy's ip address. */
const string INFOKEY_P_REALIP = "realip";	/* If sv_getrealip is set, this gives the ip as determine using that algorithm. */
const string INFOKEY_P_CSQCACTIVE = "csqcactive";	/* Client has csqc enabled. CSQC ents etc will be sent to this player. */
const string INFOKEY_P_SVPING = "svping";
const string INFOKEY_P_GUID = "guid";	/* Some hash string which should be reasonably unique to this player's quake installation. */
const string INFOKEY_P_CHALLENGE = "challenge";
const string INFOKEY_P_USERID = "*userid";
const string INFOKEY_P_DOWNLOADPCT = "download";	/* The client's download percentage for the current file. Additional files are not known. */
const string INFOKEY_P_TRUSTLEVEL = "trustlevel";
const string INFOKEY_P_PROTOCOL = "protocol";	/* The network protocol the client is using to connect to the server. */
const string INFOKEY_P_VIP = "*VIP";	/* 1 if the player has the VIP 'penalty'. */
const string INFOKEY_P_ISMUTED = "*ismuted";	/* 1 if the player has the 'mute' penalty and is not allowed to use the say/say_team commands. */
const string INFOKEY_P_ISDEAF = "*isdeaf";	/* 1 if the player has the 'deaf' penalty and cannot see other people's say/say_team commands. */
const string INFOKEY_P_ISCRIPPLED = "*ismuted";	/* 1 if the player has the cripple penalty, and their movement values are ignored (.movement is locked to 0). */
const string INFOKEY_P_ISCUFFED = "*ismuted";	/* 1 if the player has the cuff penalty, and is unable to attack or use impulses(.button0 and .impulse fields are locked to 0). */
const string INFOKEY_P_ISLAGGED = "*ismuted";	/* 1 if the player has the fakelag penalty and has an extra 200ms of lag. */
const string INFOKEY_P_PING = "ping";	/* The player's ping time, in milliseconds. */
const string INFOKEY_P_NAME = "name";	/* The player's name. */
const string INFOKEY_P_SPECTATOR = "*spectator";	/* Whether the player is a spectator or not. */
const string INFOKEY_P_TOPCOLOR = "topcolor";	/* The player's upper/shirt colour (palette index). */
const string INFOKEY_P_BOTTOMCOLOR = "bottomcolor";	/* The player's lower/pants/trouser colour (palette index). */
const float STUFFCMD_IGNOREINDEMO = 1;	/* This stuffcmd will NOT be written to mvds/qtv. */
const float STUFFCMD_DEMOONLY = 2;	/* This stuffcmd will ONLY be written into mvds/qtv streams. */
const float STUFFCMD_BROADCAST = 4;	/* The stuffcmd will be broadcast server-wide (according to the mvd filters). */
const float STUFFCMD_UNRELIABLE = 8;	/* The stuffcmd might not arrive. It might also get there faster than ones sent over the reliable channel. */
const float FL_FINDABLE_NONSOLID = 16384;	/* Allows this entity to be found with findradius */
const float FL_LAGGEDMOVE = 65536;	/* Enables anti-lag on rockets etc. */
const float MOVE_TRIGGERS = 16;	/* This trace type will impact only triggers. It will ignore non-solid entities. */
const float MOVE_EVERYTHING = 32;	/* This type of trace will hit solids and triggers alike. Even non-solid entities. */
const float MOVE_LAGGED = 64;	/* Will use antilag based upon the player's latency. Traces will be performed against old positions for entities instead of their current origin. */
const float MOVE_ENTCHAIN = 128;	/* Returns a list of entities impacted via the trace_ent.chain field */
const float MOVE_OTHERONLY = 256;	/* Traces that use this trace type will collide against *only* the entity specified via the 'other' global, and will ignore all owner/solid_not/dimension etc rules, they will still adhere to contents and bsp/bbox rules though. */
const float RESTYPE_MODEL = 0;	/* RESTYPE_* constants are used as arguments with the resourcestatus builtin. */
const float RESTYPE_SOUND = 1;	/* precache_sound */
const float RESTYPE_PARTICLE = 2;	/* particleeffectnum */
const float RESSTATE_NOTKNOWN = 0;	/* RESSTATE_* constants are return values from the resourcestatus builtin. The engine doesn't know about the resource if it is in this state. This means you will need to precache it. Attempting to use it anyway may result in warnings, errors, or silently succeed, depending on engine version and resource type. */
const float RESSTATE_NOTLOADED = 1;	/* The resource was precached, but has been flushed and there has not been an attempt to reload it. If you use the resource normally, chances are it'll be loaded but at the cost of a stall. */
const float RESSTATE_LOADING = 2;	/* Resources in this this state are queued for loading, and will be loaded at the engine's convienience. If you attempt to query the resource now, the engine will stall until the result is available. sounds in this state may be delayed, while models/pics/shaders may be invisible. */
const float RESSTATE_FAILED = 3;	/* Resources in this state are unusable/could not be loaded. You will get placeholders or dummy results. Queries will not stall the engine. The engine may display placeholder content. */
const float RESSTATE_LOADED = 4;	/* Resources in this state are finally usable, everything will work okay. Hurrah. Queries will not stall the engine. */
const float EF_FLAG1 = 16;
const float EF_FLAG2 = 32;
const float SL_ORG_TL = 20;	/* Used with showpic etc, specifies that the x+y values are relative to the top-left of the screen */
const float SL_ORG_TR = 21;
const float SL_ORG_BL = 22;
const float SL_ORG_BR = 23;
const float SL_ORG_MM = 24;
const float SL_ORG_TM = 25;
const float SL_ORG_BM = 26;
const float SL_ORG_ML = 27;
const float SL_ORG_MR = 28;
const float EV_VARIANT = 9;
const float HASH_REPLACE = 256;	/* Used with hash_add. Attempts to remove the old value instead of adding two values for a single key. */
const float HASH_ADD = 512;	/* Used with hash_add. The new entry will be inserted in addition to the existing entry. */
const float CLIENTTYPE_DISCONNECTED = 0;	/* Return value from clienttype() builtin. This entity is a player slot that is currently empty. */
const float CLIENTTYPE_REAL = 1;	/* This is a real player, and not a bot. */
const float CLIENTTYPE_BOT = 2;	/* This player slot does not correlate to a real player, any messages sent to this client will be ignored. */
const float CLIENTTYPE_NOTACLIENT = 3;	/* This entity is not even a player slot. This is typically an error condition. */
const float FILE_READ = 0;	/* The file may be read via fgets to read a single line at a time. */
const float FILE_APPEND = 1;	/* Like FILE_WRITE, but writing starts at the end of the file. */
const float FILE_WRITE = 2;	/* fputs will be used to write to the file. */
const float FILE_READNL = 4;	/* Like FILE_READ, except newlines are not special. fgets reads the entire file into a tempstring. */
const float FILE_MMAP_READ = 5;	/* The file will be loaded into memory. fgets returns a pointer to the first byte (and will always return the same value for this file). Cast this to your datatype. */
const float FILE_MMAP_RW = 6;	/* Like FILE_MMAP_READ, except any changes to the data will be written back to disk once the file is closed. */
#ifdef CSQC
	const float VF_SKYROOM_CAMERA = 222;	/* Controls the camera position of the skyroom (which will be drawn underneath transparent sky surfaces). This should move slightly with the real camera, but not so much that the skycamera enters walls. Requires a skyshader with a blend mode on the first pass (or no passes). */
	const float RF_VIEWMODEL = 1;	/* Specifies that the entity is a view model, and that its origin is relative to the current view position. These entities are also subject to viewweapon bob. */
	const float RF_EXTERNALMODEL = 2;	/* Specifies that this entity should be displayed in mirrors(and may still cast shadows), but will not otherwise be visible. */
	const float RF_USEAXIS = 16;	/* The entity will be oriented according to the current v_forward+v_right+v_up vector values instead of the entity's .angles field. */
	const float RF_NOSHADOW = 32;	/* This entity will not cast shadows. Often useful on view models. */
	const float RF_FRAMETIMESARESTARTTIMES = 64;	/* Specifies that the frame1time, frame2time field are timestamps (denoting the start of the animation) rather than time into the animation. */
	const float MASK_ENGINE = 1;	/* Valid as an argument for addentities. If specified, all non-csqc entities will be added to the scene. */
	const float MASK_VIEWMODEL = 2;	/* Valid as an argument for addentities. If specified, the regular engine viewmodel will be added to the scene. */
	const float PREDRAW_AUTOADD = 0;	/* Valid as a return value from the predraw function. Returning this will cause the engine to automatically invoke addentity(self) for you. */
	const float PREDRAW_NEXT = 1;	/* Valid as a return value from the predraw function. Returning this will simply move on to the next entity without the autoadd behaviour, so can be used for particle/invisible/special entites, or entities that were explicitly drawn with addentity. */
	const float LFIELD_ORIGIN = 0;
	const float LFIELD_COLOUR = 1;
	const float LFIELD_RADIUS = 2;
	const float LFIELD_FLAGS = 3;
	const float LFIELD_STYLE = 4;
	const float LFIELD_ANGLES = 5;
	const float LFIELD_FOV = 6;
	const float LFIELD_CORONA = 7;
	const float LFIELD_CORONASCALE = 8;
	const float LFIELD_CUBEMAPNAME = 9;
	const float LFIELD_AMBIENTSCALE = 10;
	const float LFIELD_DIFFUSESCALE = 11;
	const float LFIELD_SPECULARSCALE = 12;
	const float LFIELD_ROTATION = 13;
	const float LFIELD_DIETIME = 14;
	const float LFIELD_RGBDECAY = 15;
	const float LFIELD_RADIUSDECAY = 16;
	const float LFIELD_STYLESTRING = 17;
	const float LFIELD_NEARCLIP = 18;
	const float LFLAG_NORMALMODE = 1;
	const float LFLAG_REALTIMEMODE = 2;
	const float LFLAG_LIGHTMAP = 4;
	const float LFLAG_FLASHBLEND = 8;
	const float LFLAG_NOSHADOWS = 256;
	const float LFLAG_SHADOWMAP = 512;
	const float LFLAG_CREPUSCULAR = 1024;
	const float LFLAG_ORTHOSUN = 2048;
	const float TEREDIT_RELOAD = 0;
	const float TEREDIT_SAVE = 1;
	const float TEREDIT_SETHOLE = 2;
	const float TEREDIT_HEIGHT_SET = 3;
	const float TEREDIT_HEIGHT_SMOOTH = 4;
	const float TEREDIT_HEIGHT_SPREAD = 5;
	const float TEREDIT_HEIGHT_RAISE = 6;
	const float TEREDIT_HEIGHT_FLATTEN = 18;
	const float TEREDIT_HEIGHT_LOWER = 7;
	const float TEREDIT_TEX_KILL = 8;
	const float TEREDIT_TEX_GET = 9;
	const float TEREDIT_TEX_BLEND = 10;
	const float TEREDIT_TEX_UNIFY = 11;
	const float TEREDIT_TEX_NOISE = 12;
	const float TEREDIT_TEX_BLUR = 13;
	const float TEREDIT_TEX_REPLACE = 19;
	const float TEREDIT_TEX_SETMASK = 25;
	const float TEREDIT_WATER_SET = 14;
	const float TEREDIT_MESH_ADD = 15;
	const float TEREDIT_MESH_KILL = 16;
	const float TEREDIT_TINT = 17;
	const float TEREDIT_RESET_SECT = 20;
	const float TEREDIT_RELOAD_SECT = 21;
	const float TEREDIT_ENT_GET = 26;
	const float TEREDIT_ENT_SET = 27;
	const float TEREDIT_ENT_ADD = 28;
	const float TEREDIT_ENT_COUNT = 29;
#endif
void() breakpoint = #6; /*Trigger a debugging event. FTE will break into the qc debugger. Other engines may crash with a debug execption. */
void(entity e, float chan, string samp, float vol, float atten, optional float speedpct, optional float flags, optional float timeofs) sound = #8; // Starts a sound centered upon the given entity.  chan is the entity sound channel to use, channel 0 will allow you to mix many samples at once, others will replace the old sample 'samp' must have been precached first if specified, 'speedpct' should normally be around 100 (or =0), 200 for double speed or 50 for half speed.  If flags is specified, the reliable flag in the channels argument is used for additional channels. Flags should be made from SOUNDFLAG_* constants timeofs should be negative in order to provide a delay before the sound actually starts.
// void(entity e, float chan, string samp, float vol, float atten) sound = {
	// if (engine == ENG_DPEXT) {
		// sound_builtin();
	// } else {
		// sound_builtin(e,chan,samp,vol,atten);
	// }
// };
// vector(vector v) normalize = #9; /*Shorten or lengthen a direction vector such that it is only one quake unit long. */
// void(string e) error = #10; /*Ends the game with an easily readable error message. */
// void(string e) objerror = #11; /*Displays a non-fatal easily readable error message concerning the self entity, including a field dump. self will be removed! */
// float(vector v) vlen = #12; /*Returns the square root of the dotproduct of a vector with itself. Or in other words the length of a distance vector, in quake units. */
// float(vector v, optional entity reference) vectoyaw = #13; /*Given a direction vector, returns the yaw angle in which that direction vector points. If an entity is passed, the yaw angle will be relative to that entity's gravity direction. */
// entity() spawn = #14; /*Adds a brand new entity into the world! Hurrah, you're now a parent! */
// void(entity e) remove = #15; /*Destroys the given entity and clears some limited fields (including model, modelindex, solid, classname). Any references to the entity following the call are an error. After two seconds, the entity will be reused, in the interim you can unfortunatly still read its fields to see if the reference is no longer valid. */
// void(vector v1, vector v2, float flags, entity ent) traceline = #16;
	// Traces a thin line through the world from v1 towards v2.
	// Will not collide with ent, ent.owner, or any entity who's owner field refers to ent.
	// The passed entity will also be used to determine whether to use a capsule trace, the contents that the trace should impact, and a couple of other extra fields that define the trace.
	// There are no side effects beyond the trace_* globals being written.
	// flags&MOVE_NOMONSTERS will not impact on non-bsp entities.
	// flags&MOVE_MISSILE will impact with increased size.
	// flags&MOVE_HITMODEL will impact upon model meshes, instead of their bounding boxes.
	// flags&MOVE_TRIGGERS will also stop on triggers
	// flags&MOVE_EVERYTHING will stop if it hits anything, even non-solid entities.
	// flags&MOVE_LAGGED will backdate entity positions for the purposes of this builtin according to the indicated player ent's latency, to provide lag compensation.


void(string s, optional string s2, optional string s3, optional string s4, optional string s5, optional string s6, optional string s7, optional string s8) bprint = #23; /*NQ: Concatenates all arguments, and prints the messsage on the console of all connected clients. */

#if defined(QWSSQC)
	void(float msglvl, string s, optional string s2, optional string s3, optional string s4, optional string s5, optional string s6, optional string s7) bprint = #23; /*QW: Concatenates all string arguments, and prints the messsage on the console of only all clients who's 'msg' infokey is set lower or equal to the supplied 'msglvl' argument. */
#endif
void(entity client, string s, optional string s2, optional string s3, optional string s4, optional string s5, optional string s6, optional string s7) sprint = #24; /*NQ: Concatenates all string arguments, and prints the messsage on the named client's console */
// void(entity client, string s, optional string s2, optional string s3, optional string s4, optional string s5, optional string s6, optional string s7) sprint = {
	// if (client.flags & FL_CLIENT) {
		// if (s7) sprint_builtin(client,s,s2,s3,s4,s5,s6,s7);
		// else if (s6) sprint_builtin(client,s,s2,s3,s4,s5,s6);
		// else if (s5) sprint_builtin(client,s,s2,s3,s4,s5);
		// else if (s4) sprint_builtin(client,s,s2,s3,s4);
		// else if (s3) sprint_builtin(client,s,s2,s3);
		// else if (s2) sprint_builtin(client,s,s2);
		// else sprint_builtin(client,s);
	// } else {
		// local string whoops = strcat(s,s2,s3,s4,s5,s6,s7);
		// dprint(whoops);
		// dprint("\n"); // Can't rely on nothing these days
	// }
// }; // Really.  This didn't work at all.  Commented out for now, maybe revisit. -Qmaster
#if defined(QWSSQC)
void(entity client, float msglvl, string s, optional string s2, optional string s3, optional string s4, optional string s5, optional string s6) sprint = #24; /*QW: Concatenates all string arguments, and prints the messsage on the named client's console, but only if that client's 'msg' infokey is set lower or equal to the supplied 'msglvl' argument. */
#endif
.float suppressCenterPrint;
void(entity client, string s) centerprint_builtin = #73;
void(entity client, string s, string s) centerprint_msg = #73;
void(entity client, string s1, string s2) centerprint2 = {
	// Is the centerprint message being used by something else?
	if (!client.suppressCenterPrint && client.flags & FL_CLIENT)
		centerprint_msg(client, s1, s2);
	else {
		// Send message to client console instead
		sprint(client, "(centerprint) ");
		sprint(client, s1);
		sprint(client, s2);
		sprint(client, "\n");
	}
};
void(entity client, string s, string s, string s) centerprint_msg3 = #73;
void(entity client, string s1, string s2, string s3) centerprint3 = {
	// Is the centerprint message being used by something else?
	if (!client.suppressCenterPrint && client.flags & FL_CLIENT)
		centerprint_msg3(client, s1, s2, s3);
	else {
		// Send message to client console instead
		sprint(client, "(centerprint) ");
		sprint(client, s1);
		sprint(client, s2);
		sprint(client, s3);
		sprint(client, "\n");
	}
};
void(entity client, string s, string s, string s, string s) centerprint_msg4 = #73;
// MAIN CENTERPRINT =======================================================================
void(entity client, string s) centerprint = {
	// Is the centerprint message being used by something else?
	if (!client.suppressCenterPrint && client.flags & FL_CLIENT)
		centerprint_builtin(client, s);
	else {
		// Send message to client console instead
		sprint(client, "(centerprint) ");
		sprint(client, s);
		sprint(client, "\n");
	}
};
// MAIN CENTERPRINT =======================================================================
void(entity client, string s1, string s2, string s3, string s4, string s5, string s6, string s7) centerprint_msg7 = #73;
void(entity client, string s1, string s2, string s3, string s4, string s5, string s6, string s7) centerprint7 = {
	// Is the centerprint message being used by something else?
	if (!client.suppressCenterPrint && client.flags & FL_CLIENT)
		centerprint_msg7(client, s1, s2, s3, s4, s5, s6, s7);
	else {
		// Send message to client console instead
		sprint(client, "(centerprint) ");
		sprint(client, s1);
		sprint(client, s2);
		sprint(client, s3);
		sprint(client, s4);
		sprint(client, s5);
		sprint(client, s6);
		sprint(client, s7);
		sprint(client, "\n");
	}
};
void(float lightstyle, string stylestring, optional vector rgb) lightstyle = #35; /* Specifies an auto-animating string that specifies the light intensity for entities using that lightstyle. a is off, z is fully lit. Should be lower case only. rgb will recolour all lights using that lightstyle. */
float(float angle) sin = #60; /* Part of DP_QC_SINCOSSQRTPOW Forgive me father, for I have trigonometry homework. */
float(float angle) cos = #61; /* Part of DP_QC_SINCOSSQRTPOW*/
float(float value) sqrt = #62; /* Part of DP_QC_SINCOSSQRTPOW*/
void(string mapname, optional string newmapstartspot) changelevel = #70; /*Attempts to change the map to the named map. If 'newmapstartspot' is specified, the state of the current map will be preserved, and the argument will be passed to the next map in the 'startspot' global, and the next map will be loaded from archived state if it was previously visited. If not specified, all archived map states will be purged. */
void(entity killer, entity killee) logfrag = #79; /* Part of QW_ENGINE*/
#define unicast(pl,reli) do{ msg_entity = pl; multicast('0 0 0', reli?MULITCAST_ONE_R:MULTICAST_ONE); }while(0)
void(vector where, float set) multicast = #82; /* Part of FTE_QC_MULTICAST Once the MSG_MULTICAST network message buffer has been filled with data, this builtin is used to dispatch it to the given target, filtering by pvs for reduced network bandwidth. */
void(entity to, string str) redirectcmd = #101; /* Part of ??MVDSV_BUILTINS Executes a single console command, and sends the text generated by it to the specified player. The command will be executed at the end of the frame once QC is no longer running - you may wish to pre/postfix it with 'echo'. */
string(float style, optional __out vector rgb) getlightstyle = #0:getlightstyle; /*Obtains the light style string for the given style. */
vector(float style) getlightstylergb = #0:getlightstylergb; /* Obtains the current rgb value of the specified light style. In csqc, this is correct with regard to the current frame, while ssqc gives no guarentees about time and ignores client cvars. Note: use getlight if you want the actual light value at a point. */
void(float style, float val, optional vector rgb) lightstylestatic = #5; /*Sets the lightstyle to an explicit numerical level. From Hexen2. */

void(string slot, string picname, float x, float y, float zone, optional entity player) showpic = #104; /* Part of TEI_SHOWLMP2*/
void(string slot, optional entity player) hidepic = #105; /* Part of TEI_SHOWLMP2*/
void(string slot, float x, float y, float zone, optional entity player) movepic = #106; /* Part of TEI_SHOWLMP2*/
void(string slot, string picname, optional entity player) changepic = #107; /* Part of TEI_SHOWLMP2*/
// int(filestream fhandle, void *ptr, int size) fread = #0:fread; /* Part of FTE_QC_FILE_BINARY Reads binary data out of the file. Returns truncated lengths if the read exceeds the length of the file. */
// int(filestream fhandle, void *ptr, int size) fwrite = #0:fwrite; /* Part of FTE_QC_FILE_BINARY Writes binary data out of the file. */
// int(filestream fhandle, optional int newsize) fsize = #0:fsize; /* Part of FTE_QC_FILE_BINARY Reports the total size of the file, in bytes. Can also be used to truncate/extend the file */
void(string cvar, float val) cvar_setf = #176;
void(string soundname, optional float channel, optional float volume) localsound = #177; /*Plays a sound... locally... probably best not to call this from ssqc. Also disables reverb. */
float(string soundname, float queryonly) getsoundindex = #0:getsoundindex; /*Provides a way to query if a sound is already precached or not. The return value can also be checked for <=255 to see if it'll work over any network protocol. The sound index can also be used for writebyte hacks, but this is discouraged - use SOUNDFLAG_UNICAST instead. */
#if defined(CSQC) || defined(SSQC)
float(string modelname, optional float queryonly) getmodelindex = #200; /*
		Acts as an alternative to precache_model(foo);setmodel(bar, foo); return bar.modelindex;
		If queryonly is set and the model was not previously precached, the builtin will return 0 without needlessly precaching the model. */

__variant(float prnum, string funcname, ...) externcall = #201; /* Part of FTE_MULTIPROGS
		Directly call a function in a different/same progs by its name.
		prnum=0 is the 'default' or 'main' progs.
		prnum=-1 means current progs.
		prnum=-2 will scan through the active progs and will use the first it finds. */

float(string progsname) addprogs = #202; /* Part of FTE_MULTIPROGS
		Loads an additional .dat file into the current qcvm. The returned handle can be used with any of the externcall/externset/externvalue builtins.
		There are cvars that allow progs to be loaded automatically. */

__variant(float prnum, string varname) externvalue = #203; /* Part of FTE_MULTIPROGS
		Reads a global in the named progs by the name of that global.
		prnum=0 is the 'default' or 'main' progs.
		prnum=-1 means current progs.
		prnum=-2 will scan through the active progs and will use the first it finds. */

void(float prnum, __variant newval, string varname) externset = #204; /* Part of FTE_MULTIPROGS
		Sets a global in the named progs by name.
		prnum=0 is the 'default' or 'main' progs.
		prnum=-1 means current progs.
		prnum=-2 will scan through the active progs and will use the first it finds. */

void(entity portal, float state) openportal = #207; /*
		Opens or closes the portals associated with a door or some such on q2 or q3 maps. On Q2BSPs, the entity should be the 'func_areaportal' entity - its style field will say which portal to open. On Q3BSPs, the entity is the door itself, the portal will be determined by the two areas found from a preceding setorigin call. */

#endif
#ifdef SSQC
float(float attributes, string effectname, ...) RegisterTempEnt = #208; /* Part of FTE_PEXT_CUSTOMTENTS*/
void(float type, vector pos, ...) CustomTempEnt = #209; /* Part of FTE_PEXT_CUSTOMTENTS*/
float(optional float sleeptime) fork = #210; /* Part of FTE_MULTITHREADED
		When called, this builtin simply returns. Twice.
		The current 'thread' will return instantly with a return value of 0. The new 'thread' will return after sleeptime seconds with a return value of 1. See documentation for the 'sleep' builtin for limitations/requirements concerning the new thread. Note that QC should probably call abort in the new thread, as otherwise the function will return to the calling qc function twice also. */

#endif
void(optional __variant ret) abort = #211; /* Part of FTE_MULTITHREADED
		QC execution is aborted. Parent QC functions on the stack will be skipped, effectively this forces all QC functions to 'return ret' until execution returns to the engine. If ret is ommited, it is assumed to be 0. */

#ifdef SSQC
void(float sleeptime) sleep = #212; /* Part of FTE_MULTITHREADED
		Suspends the current QC execution thread for 'sleeptime' seconds.
		Other QC functions can and will be executed in the interim, including changing globals and field state (but not simultaneously).
		The self and other globals will be restored when the thread wakes up (or set to world if they were removed since the thread started sleeping). Locals will be preserved, but will not be protected from remove calls.
		If the engine is expecting the QC to return a value (even in the parent/root function), the value 0 shall be used instead of waiting for the qc to resume. */

void(entity player, string key, string value) forceinfokey = #213; /* Part of FTE_FORCEINFOKEY
		Directly changes a user's info without pinging off the client. Also allows explicitly setting * keys, including *spectator. Does not affect the user's config or other servers. */

void(entity player, string key, void *data, int size) forceinfokeyblob = #0:forceinfokeyblob; /*
		Directly changes a user's info without pinging off the client. Also allows explicitly setting * keys, including *spectator. Does not affect the user's config or other servers. */

#endif
#if defined(CSQC) || defined(SSQC)
void(vector org, vector dmin, vector dmax, float colour, float effect, float count) particle2 = #215; /* Part of FTE_HEXEN2*/
void(vector org, vector box, float colour, float effect, float count) particle3 = #216; /* Part of FTE_HEXEN2*/
void(vector org, float radius, float colour, float effect, float count) particle4 = #217; /* Part of FTE_HEXEN2*/
float(float number, float quantity) bitshift = #218; /* Part of EXT_BITSHIFT*/
void(vector pos) te_lightningblood = #219; /* Part of FTE_TE_STANDARDEFFECTBUILTINS*/
#endif
float(string s1, string sub, optional float startidx) strstrofs = #221; /* Part of FTE_STRINGS
		Returns the 0-based offset of sub within the s1 string, or -1 if sub is not in s1.
		If startidx is set, this builtin will ignore matches before that 0-based offset. */

float(string str, float index) str2chr = #222; /* Part of FTE_STRINGS
		Retrieves the character value at offset 'index'. */

string(float chr, ...) chr2str = #223; /* Part of FTE_STRINGS
		The input floats are considered character values, and are concatenated. */

string(float ccase, float redalpha, float redchars, string str, ...) strconv = #224; /* Part of FTE_STRINGS
		Converts quake chars in the input string amongst different representations.
		ccase specifies the new case for letters.
		 0: not changed.
		 1: forced to lower case.
		 2: forced to upper case.
		redalpha and redchars switch between colour ranges.
		 0: no change.
		 1: Forced white.
		 2: Forced red.
		 3: Forced gold(low) (numbers only).
		 4: Forced gold (high) (numbers only).
		 5+6: Forced to white and red alternately.
		You should not use this builtin in combination with UTF-8. */

string(float pad, string str1, ...) strpad = #225; /* Part of FTE_STRINGS
		Pads the string with spaces, to ensure its a specific length (so long as a fixed-width font is used, anyway). If pad is negative, the spaces are added on the left. If positive the padding is on the right. */

// string(infostring old, string key, string value) infoadd = #226; /* Part of FTE_STRINGS Returns a new tempstring infostring with the named value changed (or added if it was previously unspecified). Key and value may not contain the \ character. */
// string(infostring info, string key) infoget = #227; /* Part of FTE_STRINGS Reads a named value from an infostring. The returned value is a tempstring */
#define strcmp strncmp
float(string s1, string s2, optional float len, optional float s1ofs, optional float s2ofs) strncmp = #228; /* Part of FTE_STRINGS
		Compares up to 'len' chars in the two strings. s1ofs allows you to treat s2 as a substring to compare against, or should be 0.
		Returns 0 if the two strings are equal, a negative value if s1 appears numerically lower, and positive if s1 appears numerically higher. */

float(string s1, string s2) strcasecmp = #229; /* Part of FTE_STRINGS
		Compares the two strings without case sensitivity.
		Returns 0 if they are equal. The sign of the return value may be significant, but should not be depended upon. */

float(string s1, string s2, float len, optional float s1ofs, optional float s2ofs) strncasecmp = #230; /* Part of FTE_STRINGS
		Compares up to 'len' chars in the two strings without case sensitivity. s1ofs allows you to treat s2 as a substring to compare against, or should be 0.
		Returns 0 if they are equal. The sign of the return value may be significant, but should not be depended upon. */

string(string s) strtrim = #0:strtrim; /*
		Trims the whitespace from the start+end of the string. */

#if defined(CSQC) || defined(SSQC)
void() calltimeofday = #231; /* Part of FTE_CALLTIMEOFDAY
		Asks the engine to instantly call the qc's 'timeofday' function, before returning. For compatibility with mvdsv.
		timeofday should have the prototype: void(float secs, float mins, float hour, float day, float mon, float year, string strvalue)
		The strftime builtin is more versatile and less weird. */

#endif
#ifdef SSQC
void(float num, float type, .__variant fld) clientstat = #232; /*
		Specifies what data to use in order to send various stats, in a client-specific way.
		'num' should be a value between 32 and 127, other values are reserved.
		'type' must be set to one of the EV_* constants, one of EV_FLOAT, EV_STRING, EV_INTEGER, EV_ENTITY.
		fld must be a reference to the field used, each player will be sent only their own copy of these fields. */

void(float num, float type, string name) globalstat = #233; /*
		Specifies what data to use in order to send various stats, in a non-client-specific way. num and type are as in clientstat, name however, is the name of the global to read in the form of a string (pass "foo"). */

void(float num, float type, __variant *address) pointerstat = #0:pointerstat; /*
		Specifies what data to use in order to send various stats, in a non-client-specific way. num and type are as in clientstat, address however, is the address of the variable you would like to use (pass &foo). */

float(entity player) isbackbuffered = #234; /* Part of FTE_ISBACKBUFFERED
		Returns if the given player's network buffer will take multiple network frames in order to clear. If this builtin returns non-zero, you should delay or reduce the amount of reliable (and also unreliable) data that you are sending to that client. */

#endif
#if defined(CSQC) || defined(SSQC)
void(vector angle) rotatevectorsbyangle = #235; /*
		rotates the v_forward,v_right,v_up matrix by the specified angles. */

void(vector fwd, vector right, vector up) rotatevectorsbyvectors = #236;
float(float mdlindex, string skinname) skinforname = #237;
#endif
#if defined(CSQC) || defined(MENU)
float(string shadername, optional string defaultshader, ...) shaderforname = #238; /* Part of FTE_FORCESHADER
		Caches the named shader and returns a handle to it.
		If the shader could not be loaded from disk (missing file or ruleset_allow_shaders 0), it will be created from the 'defaultshader' string if specified, or a 'skin shader' default will be used.
		defaultshader if not empty should include the outer {} that you would ordinarily find in a shader. */

#endif
#if defined(CSQC) || defined(SSQC)
void(vector org, optional float count) te_bloodqw = #239; /* Part of FTE_TE_STANDARDEFFECTBUILTINS*/
#endif
#ifdef SSQC
void(entity ent) te_muzzleflash = #0:te_muzzleflash;
#endif
#if defined(CSQC) || defined(SSQC)
float(vector viewpos, entity entity) checkpvs = #240; /* Part of FTE_QC_CHECKPVS*/
#endif
#ifdef SSQC
entity(string match, optional float matchnum) matchclientname = #241; /* Part of FTE_QC_MATCHCLIENTNAME*/
#endif
void(string destaddress, string content) sendpacket = #242; /* Part of FTE_QC_SENDPACKET
		Sends a UDP packet to the specified destination. Note that the payload will be prefixed with four 255 bytes as a sort of security feature. */

#ifdef CSQC
vector(entity ent, float tagnum) rotatevectorsbytag = #244;
#endif
#if defined(CSQC) || defined(SSQC)
// float(float dividend, float divisor) mod = #245;
#endif
#ifdef SSQC
float(optional string host, optional string user, optional string pass, optional string defaultdb, optional string driver) sqlconnect = #250; /* Part of FTE_SQL*/
void(float serveridx) sqldisconnect = #251; /* Part of FTE_SQL*/
float(float serveridx, void(float serveridx, float queryidx, float rows, float columns, float eof, float firstrow) callback, float querytype, string query) sqlopenquery = #252; /* Part of FTE_SQL*/
void(float serveridx, float queryidx) sqlclosequery = #253; /* Part of FTE_SQL*/
string(float serveridx, float queryidx, float row, float column) sqlreadfield = #254; /* Part of FTE_SQL*/
string(float serveridx, optional float queryidx) sqlerror = #255; /* Part of FTE_SQL*/
string(float serveridx, string data) sqlescape = #256; /* Part of FTE_SQL*/
string(float serveridx) sqlversion = #257; /* Part of FTE_SQL*/
float(float serveridx, float queryidx, float row, float column) sqlreadfloat = #258; /* Part of FTE_SQL*/
int(float serveridx, float queryidx, float row, float column, __variant *ptr, int maxsize) sqlreadblob = #0:sqlreadblob;
string(float serveridx, __variant *ptr, int maxsize) sqlescapeblob = #0:sqlescapeblob;
#endif
#if defined(CSQC) || defined(SSQC)
int(string) stoi = #259; /* Part of FTE_QC_INTCONV
		Converts the given string into a true integer. Base 8, 10, or 16 is determined based upon the format of the string. */

string(int) itos = #260; /* Part of FTE_QC_INTCONV
		Converts the passed true integer into a base10 string. */

int(string) stoh = #261; /* Part of FTE_QC_INTCONV
		Reads a base-16 string (with or without 0x prefix) as an integer. Bugs out if given a base 8 or base 10 string. :P */

string(int) htos = #262; /* Part of FTE_QC_INTCONV
		Formats an integer as a base16 string, with leading 0s and no prefix. Always returns 8 characters. */

#endif
int(float) ftoi = #0:ftoi; /* Part of FTE_QC_INTCONV
		Converts the given float into a true integer without depending on extended qcvm instructions. */

float(int) itof = #0:itof; /* Part of FTE_QC_INTCONV
		Converts the given true integer into a float without depending on extended qcvm instructions. */

#if defined(CSQC) || defined(SSQC)
float(float modlindex, optional float useabstransforms) skel_create = #263; /* Part of FTE_CSQC_SKELETONOBJECTS
		Allocates a new uninitiaised skeletal object, with enough bone info to animate the given model.
		eg: self.skeletonobject = skel_create(self.modelindex); */

float(float skel, entity ent, float modelindex, float retainfrac, float firstbone, float lastbone, optional float addfrac) skel_build = #264; /* Part of FTE_CSQC_SKELETONOBJECTS
		Animation data (according to the entity's frame info) is pulled from the specified model and blended into the specified skeletal object.
		If retainfrac is set to 0 on the first call and 1 on the others, you can blend multiple animations together according to the addfrac value. The final weight should be 1. Other values will result in scaling and/or other weirdness. You can use firstbone and lastbone to update only part of the skeletal object, to allow legs to animate separately from torso, use 0 for both arguments to specify all, as bones are 1-based. */

typedef struct
{
	int sourcemodelindex; /*frame data will be imported from this model, bones must be compatible*/
	int reserved;
	int firstbone;
	int lastbone;
	float prescale;	/*0 destroys existing data, 1 retains it*/
	float scale[4];	/*you'll need to do lerpfrac manually*/
	int animation[4];
	float animationtime[4];
	/*halflife models*/
	float subblend[2];
	float controllers[5];
} skelblend_t;
float(float skel, int numblends, skelblend_t *weights, int structsize) skel_build_ptr = #0:skel_build_ptr; /*
		Like skel_build, but slightly simpler. */

float(float skel) skel_get_numbones = #265; /* Part of FTE_CSQC_SKELETONOBJECTS
		Retrives the number of bones in the model. The valid range is 1<=bone<=numbones. */

string(float skel, float bonenum) skel_get_bonename = #266; /* Part of FTE_CSQC_SKELETONOBJECTS
		Retrieves the name of the specified bone. Mostly only for debugging. */

float(float skel, float bonenum) skel_get_boneparent = #267; /* Part of FTE_CSQC_SKELETONOBJECTS
		Retrieves which bone this bone's position is relative to. Bone 0 refers to the entity's position rather than an actual bone */

float(float skel, string tagname) skel_find_bone = #268; /* Part of FTE_CSQC_SKELETONOBJECTS
		Finds a bone by its name, from the model that was used to create the skeletal object. */

vector(float skel, float bonenum) skel_get_bonerel = #269; /* Part of FTE_CSQC_SKELETONOBJECTS
		Gets the bone position and orientation relative to the bone's parent. Return value is the offset, and v_forward, v_right, v_up contain the orientation. */

vector(float skel, float bonenum) skel_get_boneabs = #270; /* Part of FTE_CSQC_SKELETONOBJECTS
		Gets the bone position and orientation relative to the entity. Return value is the offset, and v_forward, v_right, v_up contain the orientation.
		Use gettaginfo for world coord+orientation. */

void(float skel, float bonenum, vector org, optional vector fwd, optional vector right, optional vector up) skel_set_bone = #271; /* Part of FTE_CSQC_SKELETONOBJECTS
		Sets a bone position relative to its parent. If the orientation arguments are not specified, v_forward+v_right+v_up are used instead. */

void(float skel, float bonenum, vector org, optional vector fwd, optional vector right, optional vector up) skel_premul_bone = #272; /* Part of FTE_CSQC_SKELETONOBJECTS
		Transforms a single bone by a matrix. You can use makevectors to generate a rotation matrix from an angle. */

void(float skel, float startbone, float endbone, vector org, optional vector fwd, optional vector right, optional vector up) skel_premul_bones = #273; /* Part of FTE_CSQC_SKELETONOBJECTS
		Transforms an entire consecutive range of bones by a matrix. You can use makevectors to generate a rotation matrix from an angle, but you'll probably want to divide the angle by the number of bones. */

void(float skel, float bonenum, vector org, optional vector fwd, optional vector right, optional vector up) skel_postmul_bone = #0:skel_postmul_bone; /*
		Transforms a single bone by a matrix. You can use makevectors to generate a rotation matrix from an angle. */

void(float skeldst, float skelsrc, float startbone, float entbone) skel_copybones = #274; /* Part of FTE_CSQC_SKELETONOBJECTS
		Copy bone data from one skeleton directly into another. */

void(float skel) skel_delete = #275; /* Part of FTE_CSQC_SKELETONOBJECTS
		Deletes a skeletal object. The actual delete is delayed, allowing the skeletal object to be deleted in an entity's predraw function yet still be valid by the time the addentity+renderscene builtins need it. Also uninstanciates any ragdoll currently in effect on the skeletal object. */

float(float modidx, string framename) frameforname = #276; /* Part of FTE_CSQC_SKELETONOBJECTS
		Looks up a framegroup from a model by name, avoiding the need for hardcoding. Returns -1 on error. */

float(float modidx, float framenum) frameduration = #277; /* Part of FTE_CSQC_SKELETONOBJECTS
		Retrieves the duration (in seconds) of the specified framegroup. */

void(float modidx, float framenum, __inout float basetime, float targettime, void(float timestamp, int code, string data) callback) processmodelevents = #0:processmodelevents; /* Part of FTE_GFX_MODELEVENTS
		Calls a callback for each event that has been reached. Basetime is set to targettime. */

float(float modidx, float framenum, __inout float basetime, float targettime, __out int code, __out string data) getnextmodelevent = #0:getnextmodelevent; /*
		Reports the next event within a model's animation. Returns a boolean if an event was found between basetime and targettime. Writes to basetime,code,data arguments (if an event was found, basetime is set to the event's time, otherwise to targettime).
		WARNING: this builtin cannot deal with multiple events with the same timestamp (only the first will be reported). */

float(float modidx, float framenum, int eventidx, __out float timestamp, __out int code, __out string data) getmodeleventidx = #0:getmodeleventidx; /*
		Reports an indexed event within a model's animation. Writes to timestamp,code,data arguments on success. Returns false if the animation/event/model was out of range/invalid. Does not consider looping animations (retry from index 0 if it fails and you know that its a looping animation). This builtin is more annoying to use than getnextmodelevent, but can be made to deal with multiple events with the exact same timestamp. */

#endif
#define dotproduct(v1,v2) ((vector)(v1)*(vector)(v2))
vector(vector v1, vector v2) crossproduct = #0:crossproduct; /* Part of FTE_QC_CROSSPRODUCT
		Small helper function to calculate the crossproduct of two vectors. */

#if defined(CSQC) || defined(SSQC)
float(entity pusher, vector move, vector amove) pushmove = #0:pushmove;
__variant(float action, optional vector pos, optional float radius, optional float quant, ...) terrain_edit = #278; /* Part of FTE_TERRAIN_MAP
		Realtime terrain editing. Actions are the TEREDIT_ constants. */

typedef struct
{
	string	shadername;
	vector	planenormal;
	float	planedist;
	vector	sdir;
	float	sbias;
	vector	tdir;
	float	tbias;
} brushface_t;
int(float modelidx, int brushid, brushface_t *out_faces, int maxfaces, int *out_contents) brush_get = #0:brush_get; /* Part of FTE_RAW_MAP
		Queries a brush's information. You must pre-allocate the face array for the builtin to write to. Return value is the number of faces retrieved, 0 on error. */

int(float modelidx, brushface_t *in_faces, int numfaces, int contents, optional int brushid) brush_create = #0:brush_create; /* Part of FTE_RAW_MAP
		Inserts a new brush into the model. Return value is the new brush's id. */

void(float modelidx, int brushid) brush_delete = #0:brush_delete; /* Part of FTE_RAW_MAP
		Destroys the specified brush. */

float(float modelid, int brushid, int faceid, float selectedstate) brush_selected = #0:brush_selected; /* Part of FTE_RAW_MAP
		Allows you to easily set transient visual properties of a brush. returns old value. selectedstate=-1 changes nothing (called for its return value). */

int(float modelid, int brushid, int faceid, vector *points, int maxpoints) brush_getfacepoints = #0:brush_getfacepoints; /* Part of FTE_RAW_MAP
		Returns the list of verticies surrounding the given face. If face is 0, returns the center of the brush (if space for 1 point) or the mins+maxs (if space for 2 points). */

int(int faceid, brushface_t *in_faces, int numfaces, vector *points, int maxpoints) brush_calcfacepoints = #0:brush_calcfacepoints; /* Part of FTE_RAW_MAP
		Determines the points of the specified face, if the specified brush were to actually be created. */

int(float modelid, vector *planes, float *dists, int numplanes, int *out_brushes, int *out_faces, int maxresults) brush_findinvolume = #0:brush_findinvolume; /* Part of FTE_RAW_MAP
		Allows you to easily obtain a list of brushes+faces within the given bounding region. If out_faces is not null, the same brush might be listed twice. */

void(optional entity ent, optional vector neworigin) touchtriggers = #279; /*
		Triggers a touch events between self and every SOLID_TRIGGER entity that it is in contact with. This should typically just be the triggers touch functions. Also optionally updates the origin of the moved entity. */

#endif
#ifdef SSQC
void(float buf, float fl) WriteFloat = #280;
#endif
#if defined(CSQC) || defined(SSQC)
float(entity skelent, string dollcmd, float animskel) skel_ragupdate = #281; /*
		Updates the skeletal object attached to the entity according to its origin and other properties.
		if animskel is non-zero, the ragdoll will animate towards the bone state in the animskel skeletal object, otherwise they will pick up the model's base pose which may not give nice results.
		If dollcmd is not set, the ragdoll will update (this should be done each frame).
		If the doll is updated without having a valid doll, the model's default .doll will be instanciated.
		commands:
		 doll foo.doll : sets up the entity to use the named doll file
		 dollstring TEXT : uses the doll file directly embedded within qc, with that extra prefix.
		 cleardoll : uninstanciates the doll without destroying the skeletal object.
		 animate 0.5 : specifies the strength of the ragdoll as a whole 
		 animatebody somebody 0.5 : specifies the strength of the ragdoll on a specific body (0 will disable ragdoll animations on that body).
		 enablejoint somejoint 1 : enables (or disables) a joint. Disabling joints will allow the doll to shatter. */
float*(float skel) skel_mmap = #282; /* Map the bones in VM memory. They can then be accessed via pointers. Each bone is 12 floats, the four vectors interleaved (sadly). */
void(entity ent, float bonenum, vector org, optional vector angorfwd, optional vector right, optional vector up) skel_set_bone_world = #283; /* Sets the world position of a bone within the given entity's attached skeletal object. The world position is dependant upon the owning entity's position. If no orientation argument is specified, v_forward+v_right+v_up are used for the orientation instead. If 1 is specified, it is understood as angles. If 3 are specified, they are the forawrd/right/up vectors to use. */
string(float modidx, float framenum) frametoname = #284;
string(float modidx, float skin) skintoname = #285;
float(float resourcetype, float tryload, string resourcename) resourcestatus = #286; /* resourcetype must be one of the RESTYPE_ constants. Returns one of the RESSTATE_ constants. Tryload 0 is a query only. Tryload 1 will attempt to reload the content if it was flushed. */
#endif

float(string name) checkcommand = #294; /* Part of FTE_QC_CHECKCOMMANDChecks to see if the supplied name is a valid command, cvar, or alias. Returns 0 if it does not exist. */
string(string s) argescape = #295; /*Marks up a string so that it can be reliably tokenized as a single argument later. */

#ifdef SSQC
void(string dest, string from, string cmd, string info) clusterevent = #0:clusterevent; /*Only functions in mapcluster mode. Sends an event to whichever server the named player is on. The destination server can then dispatch the event to the client or handle it itself via the SV_ParseClusterEvent entrypoint. If dest is empty, the event is broadcast to ALL servers. If the named player can't be found, the event will be returned to this server with the cmd prefixed with 'error:'. */

string(entity player, optional string newnode) clustertransfer = #0:clustertransfer; /*
		Only functions in mapcluster mode. Initiate transfer of the player to a different node. Can take some time. If dest is specified, returns null on error. Otherwise returns the current/new target node (or null if not transferring). */

#endif
#if defined(CSQC) || defined(SSQC)
float(float mdlidx) modelframecount = #0:modelframecount; /*
		Retrieves the number of frames in the specified model. */

#endif
#if defined(CSQC) || defined(MENU)
void() clearscene = #300; /*
		Forgets all rentities, polygons, and temporary dlights. Resets all view properties to their default values. */

#endif
#ifdef CSQC
void(float mask) addentities = #301; /*
		Walks through all entities effectively doing this:
		 if (ent.drawmask&mask) { if (!ent.predaw()) addentity(ent); }
		If mask&MASK_DELTA, non-csqc entities, particles, and related effects will also be added to the rentity list.
		 If mask&MASK_STDVIEWMODEL then the default view model will also be added. */

#endif
#if defined(CSQC) || defined(MENU)
void(entity ent) addentity = #302; /*
		Copies the entity fields into a new rentity for later rendering via addscene. */

#endif
#ifdef CSQC
void(entity ent) removeentity = #0:removeentity; /*
		Undoes all addentities added to the scene from the given entity, without removing ALL entities (useful for splitscreen/etc, readd modified versions as desired). */

typedef float vec2[2];
typedef float vec3[3];
typedef float vec4[4];
typedef struct trisoup_simple_vert_s { vec3 xyz;vec2 st;vec4 rgba; } trisoup_simple_vert_t;
void(string texturename, int flags, struct trisoup_simple_vert_s *verts, int *indexes, int numindexes) addtrisoup_simple = #0:addtrisoup_simple; /*
		Adds the specified trisoup into the scene as additional geometry. This permits caching geometry to reduce builtin spam. Indexes are a triangle list (so eg quads will need 6 indicies to form two triangles). NOTE: this is not going to be a speedup over polygons if you're still generating lots of new data every frame. */

#endif
#if defined(CSQC) || defined(MENU)
#define setviewprop setproperty
float(float property, ...) setproperty = #303; /*
		Allows you to override default view properties like viewport, fov, and whether the engine hud will be drawn. Different VF_ values have slightly different arguments, some are vectors, some floats. */

void() renderscene = #304; /*
		Draws all entities, polygons, and particles on the rentity list (which were added via addentities or addentity), using the various view properties set via setproperty. There is no ordering dependancy.
		The scene must generally be cleared again before more entities are added, as entities will persist even over to the next frame.
		You may call this builtin multiple times per frame, but should only be called from CSQC_UpdateView. */

#endif
#ifdef CSQC
float(vector org, float radius, vector lightcolours, optional float style, optional string cubemapname, optional float pflags) dynamiclight_add = #305; /*
		Adds a temporary dlight, ready to be drawn via addscene. Cubemap orientation will be read from v_forward/v_right/v_up. */

#endif
void(string texturename, optional float flags, optional float is2d) R_BeginPolygon = #306; /*
		Specifies the shader to use for the following polygons, along with optional flags.
		If is2d, the polygon will be drawn as soon as the EndPolygon call is made, rather than waiting for renderscene. This allows complex 2d effects. */

void(vector org, vector texcoords, vector rgb, float alpha) R_PolygonVertex = #307; /*
		Specifies a polygon vertex with its various properties. */

void() R_EndPolygon = #308; /*
		Ends the current polygon. At least 3 verticies must have been specified. You do not need to call beginpolygon if you wish to draw another polygon with the same shader. */

#if defined(CSQC) || defined(MENU)
#define getviewprop getproperty
__variant(float property) getproperty = #309; /*
		Retrieve a currently-set (typically view) property, allowing you to read the current viewport or other things. Due to cheat protection, certain values may be unretrievable. */

#endif
#ifdef CSQC
vector (vector v) unproject = #310; /*
		Transform a 2d screen-space point (with depth) into a 3d world-space point, according the various origin+angle+fov etc settings set via setproperty. */

vector (vector v) project = #311; /*
		Transform a 3d world-space point into a 2d screen-space point, according the various origin+angle+fov etc settings set via setproperty. */

#endif
#if defined(CSQC) || defined(MENU)
float(vector pos, vector size, float alignflags, string text) drawtextfield = #0:drawtextfield; /*
		Draws a multi-line block of text, including word wrapping and alignment. alignflags bits are RTLB, typically 3. Returns the total number of lines. */

#endif
#ifdef CSQC
void(float width, vector pos1, vector pos2, vector rgb, float alpha, optional float drawflag) drawline = #315; /*
		Draws a 2d line between the two 2d points. */

float(string name) iscachedpic = #316; /*
		Checks to see if the image is currently loaded. Engines might lie, or cache between maps. */

string(string name, optional float trywad) precache_pic = #317; /*
		Forces the engine to load the named image. If trywad is specified, the specified name must any lack path and extension. */

#endif
#if defined(CSQC) || defined(MENU)
void(string imagename, int width, int height, void *pixeldata, optional int datasize, optional int format) r_uploadimage = #0:r_uploadimage; /* Part of FTE_CSQC_RAWIMAGES
		Updates a texture with the specified rgba data (uploading it to the gpu). Will be created if needed. If datasize is specified then the image is decoded (eg .ktx or .dds data) instead of being raw R8G8B8A data. You'll typically want shaderforname to also generate a shader to use the texture. */

int*(string filename, __out int width, __out int height) r_readimage = #0:r_readimage; /* Part of FTE_CSQC_RAWIMAGES
		Reads and decodes an image from disk, providing raw R8G8B8A8 pixel data. Should not be used for dds or ktx etc formats. Returns __NULL__ if the image could not be read for any reason. Use memfree to free the data once you're done with it. */

#endif
#ifdef CSQC
#define draw_getimagesize drawgetimagesize
vector(string picname) drawgetimagesize = #318; /*
		Returns the dimensions of the named image. Images specified with .lmp should give the original .lmp's dimensions even if texture replacements use a different resolution. */

void(string name) freepic = #319; /*
		Tells the engine that the image is no longer needed. The image will appear to be new the next time its needed. */

float(vector position, float character, vector size, vector rgb, float alpha, optional float drawflag) drawcharacter = #320; /*
		Draw the given quake character at the given position.
		If flag&4, the function will consider the char to be a unicode char instead (or display as a ? if outside the 32-127 range).
		size should normally be something like '8 8 0'.
		rgb should normally be '1 1 1'
		alpha normally 1.
		Software engines may assume the named defaults.
		Note that ALL text may be rescaled on the X axis due to variable width fonts. The X axis may even be ignored completely. */

float(vector position, string text, vector size, vector rgb, float alpha, optional float drawflag) drawrawstring = #321; /*
		Draws the specified string without using any markup at all, even in engines that support it.
		If UTF-8 is globally enabled in the engine, then that encoding is used (without additional markup), otherwise it is raw quake chars.
		Software engines may assume a size of '8 8 0', rgb='1 1 1', alpha=1, flag&3=0, but it is not an error to draw out of the screen. */

float(vector position, string pic, vector size, vector rgb, float alpha, optional float drawflag) drawpic = #322; /*
		Draws an shader within the given 2d screen box. Software engines may omit support for rgb+alpha, but must support rescaling, and must clip to the screen without crashing. */

float(vector position, vector size, vector rgb, float alpha, optional float drawflag) drawfill = #323; /*
		Draws a solid block over the given 2d box, with given colour, alpha, and blend mode (specified via flags).
		flags&3=0 simple blend.
		flags&3=1 additive blend */

void(float x, float y, float width, float height) drawsetcliparea = #324; /*
		Specifies a 2d clipping region (aka: scissor test). 2d draw calls will all be clipped to this 2d box, the area outside will not be modified by any 2d draw call (even 2d polygons). */

void(void) drawresetcliparea = #325; /*
		Reverts the scissor/clip area to the whole screen. */

float(vector position, string text, vector size, vector rgb, float alpha, float drawflag) drawstring = #326; /*
		Draws a string, interpreting markup and recolouring as appropriate. */

float(string text, float usecolours, optional vector fontsize) stringwidth = #327; /*
		Calculates the width of the screen in virtual pixels. If usecolours is 1, markup that does not affect the string width will be ignored. Will always be decoded as UTF-8 if UTF-8 is globally enabled.
		If the char size is not specified, '8 8 0' will be assumed. */

void(vector pos, vector sz, string pic, vector srcpos, vector srcsz, vector rgb, float alpha, optional float drawflag) drawsubpic = #328; /*
		Draws a rescaled subsection of an image to the screen. */

#endif
#if defined(CSQC) || defined(MENU)
void(vector pivot, vector mins, vector maxs, string pic, vector rgb, float alpha, float angle) drawrotpic = #0:drawrotpic; /*
		Draws an image rotating at the pivot. To rotate in the center, use mins+maxs of half the size with mins negated. Angle is in degrees. */

void(vector pivot, vector mins, vector maxs, string pic, vector txmin, vector txsize, vector rgb, vector alphaandangles) drawrotsubpic = #0:drawrotsubpic; /*
		Overcomplicated draw function for over complicated people. Positions follow drawrotpic, while texture coords follow drawsubpic. Due to argument count limitations in builtins, the alpha value and angles are combined into separate fields of a vector (tip: use fteqcc's [alpha, angle] feature. */

#endif
#ifdef CSQC
#define getstati_punf(stnum) (float)(__variant)getstati(stnum)
int(float stnum) getstati = #330; /*
		Retrieves the numerical value of the given EV_INTEGER or EV_ENTITY stat. Use getstati_punf if you wish to type-pun a float stat as an int to avoid truncation issues in DP. */

#define getstatbits getstatf
float(float stnum, optional float firstbit, optional float bitcount) getstatf = #331; /*
		Retrieves the numerical value of the given EV_FLOAT stat. If firstbit and bitcount are specified, retrieves the upper bits of the STAT_ITEMS stat (converted into a float, so there are no VM dependancies). */

string(float stnum) getstats = #332; /*
		Retrieves the value of the given EV_STRING stat, as a tempstring.
		Older engines may use 4 consecutive integer stats, with a limit of 15 chars (yes, really. 15.), but FTE Quake uses a separate namespace for string stats and has a much higher length limit. */

__variant(float playernum, float statnum, float stattype) getplayerstat = #0:getplayerstat; /*
		Retrieves a specific player's stat, matching the type specified on the server. This builtin is primarily intended for mvd playback where ALL players are known. For EV_ENTITY, world will be returned if the entity is not in the pvs, use type-punning with EV_INTEGER to get the entity number if you just want to see if its set. STAT_ITEMS should be queried as an EV_INTEGER on account of runes and items2 being packed into the upper bits. */

void(entity e, float mdlindex) setmodelindex = #333; /*
		Sets a model by precache index instead of by name. Otherwise identical to setmodel. */

string(float mdlindex) modelnameforindex = #334; /*
		Retrieves the name of the model based upon a precache index. This can be used to reduce csqc network traffic by enabling model matching. */

#endif
#if defined(CSQC) || defined(SSQC)
float(string effectname) particleeffectnum = #335; /* Part of DP_ENT_TRAILEFFECTNUM, FTE_SV_POINTPARTICLES
		Precaches the named particle effect. If your effect name is of the form 'foo.bar' then particles/foo.cfg will be loaded by the client if foo.bar was not already defined.
		Different engines will have different particle systems, this specifies the QC API only. */

void(float effectnum, entity ent, vector start, vector end) trailparticles = #336; /* Part of FTE_SV_POINTPARTICLES
		Draws the given effect between the two named points. If ent is not world, distances will be cached in the entity in order to avoid framerate dependancies. The entity is not otherwise used. */

void(float effectnum, vector origin, optional vector dir, optional float count) pointparticles = #337; /* Part of FTE_SV_POINTPARTICLES
		Spawn a load of particles from the given effect at the given point traveling or aiming along the direction specified. The number of particles are scaled by the count argument.
		For regular particles, the dir vector is multiplied by the 'veladd' property (while orgadd will push the particles along it). Decals will use it as a hint to align to the correct surface. In both cases, it should normally be a unit vector, but other lengths will still work. If it has length 0 then FTE will assume downwards. */

#endif
#ifdef CSQC
void(string s, ...) cprint = #338; /*
		Print into the center of the screen just as ssqc's centerprint would appear. */

#endif
#if defined(CSQC) || defined(SSQC)
void(string s, ...) print = #339; /* Part of DP_SV_PRINT
		Unconditionally print on the local system's console, even in ssqc (doesn't care about the value of the developer cvar). */

#endif
#ifdef CSQC
string(float keynum) keynumtostring = #340; /*
		Returns a hunam-readable name for the given keycode, as a tempstring. */

#endif
#ifdef MENU
string(float keynum) keynumtostring_csqc = #340; /*
		Returns a hunam-readable name for the given keycode, as a tempstring. */

#endif
#ifdef CSQC
float(string keyname) stringtokeynum = #341; /*
		Looks up the key name in the same way that the bind command would, returning the keycode for that key. */

#endif
#ifdef MENU
float(string keyname) stringtokeynum_csqc = #341; /*
		Looks up the key name in the same way that the bind command would, returning the keycode for that key. */

#endif
#if defined(CSQC) || defined(MENU)
string(float keynum) getkeybind = #342; /*
		Returns the current binding for the given key (returning only the command executed when no modifiers are pressed). */

void(float usecursor, optional string cursorimage, optional vector hotspot, optional float scale) setcursormode = #343; /*
		Pass TRUE if you want the engine to release the mouse cursor (absolute input events + touchscreen mode). Pass FALSE if you want the engine to grab the cursor (relative input events + standard looking). If the image name is specified, the engine will use that image for a cursor (use an empty string to clear it again), in a way that will not conflict with the console. Images specified this way will be hardware accelerated, if supported by the platform/port. */

float(float effective) getcursormode = #0:getcursormode; /*
		Reports the cursor mode this module previously attempted to use. If 'effective' is true, reports the cursor mode currently active (if was overriden by a different module which has precidence, for instance, or if there is only a touchscreen and no mouse). */

#endif
#ifdef CSQC
vector() getmousepos = #344; /*
		Nasty convoluted DP extension. Typically returns deltas instead of positions. Use CSQC_InputEvent for such things in csqc mods. */

float(float inputsequencenum) getinputstate = #345; /*
		Looks up an input frame from the log, setting the input_* globals accordingly.
		The sequence number range used for prediction should normally be servercommandframe < sequence <= clientcommandframe.
		The sequence equal to clientcommandframe will change between input frames. */

void(float sens) setsensitivityscaler = #346; /*
		Temporarily scales the player's mouse sensitivity based upon something like zoom, avoiding potential cvar saving and thus corruption. */

#endif
#if defined(CSQC) || defined(SSQC)
void(optional entity ent) runstandardplayerphysics = #347; /*
		Perform the engine's standard player movement prediction upon the given entity using the input_* globals to describe movement. */

#endif
#ifdef CSQC
string(float playernum, string keyname) getplayerkeyvalue = #348; /*
		Look up a player's userinfo, to discover things like their name, topcolor, bottomcolor, skin, team, *ver.
		Also includes scoreboard info like frags, ping, pl, userid, entertime, as well as voipspeaking and voiploudness. */

float(float playernum, string keyname, optional float assumevalue) getplayerkeyfloat = #0:getplayerkeyfloat; /*
		Cheaper version of getplayerkeyvalue that avoids the need for so many tempstrings. */

int(float playernum, string keyname, optional void *outptr, int size) getplayerkeyblob = #0:getplayerkeyblob; /*
		Obtains a copy of the full data blob. Will write up to size bytes but return the full size. Does not null terminate (but memalloc(ret+1) will, if you want to cast the buffer to a string), and the blob may contain embedded nulls. Ignores all special keys, returning only what is actually there. */

#endif
#if defined(CSQC) || defined(MENU)
void(float seat, string keyname, string newvalue) setlocaluserinfo = #0:setlocaluserinfo; /*
		Change a userinfo key for the local player, equivelent to the setinfo console command. The server will normally forward the setting to other clients. */

string(float seat, string keyname) getlocaluserinfo = #0:getlocaluserinfo; /*
		Reads a local userinfo key for the active seat. This is not quite the same as getplayerkeyvalue, due to latency and possible serverside filtering. */

void(float seat, string keyname, void *outptr, int size) setlocaluserinfoblob = #0:setlocaluserinfoblob; /*
		Sets the userinfo key to a blob that may contain nulls etc. Keys with a leading underscore will be visible to only the server (for user-specific binary settings). */

int(float seat, string keyname, void *outptr, int maxsize) getlocaluserinfoblob = #0:getlocaluserinfoblob; /*
		Obtains a copy of the full data blob. Will write up to size bytes but return the full size. Does not null terminate (but memalloc(ret+1) will, if you want to cast the buffer to a string), and the blob may contain embedded nulls. Ignores all special keys, returning only what is actually there. */

#endif
#ifdef SSQC
int(string keyname, optional void *outptr, int size) getlocalinfo = #0:getlocalinfo; /*
		Obtains a copy of a data blob (with spaces) from the server's private localinfo. Will write up to size bytes and return the actual size. Does not null terminate (but memalloc(ret+1) will, if you want to cast the buffer to a string), and the blob may contain embedded nulls. Ignores all special keys, returning only what is actually there. */

void(string keyname, optional void *outptr, int size) setlocalinfo = #0:setlocalinfo; /*
		Changes the server's private localinfo. This data will be available for the following map, and will *usually* reload with saved games. */

#endif
#if defined(CSQC) || defined(MENU)
float() isdemo = #349; /*
		Returns if the client is currently playing a demo or not. Returns 2 when playing an mvd (where other player's stats can be queried, or the pov can be changed freely). */

#endif
#ifdef CSQC
float() isserver = #350; /* Returns non-zero whenever the local console can directly affect the server (ie: listen servers or single-player). Compat note: DP returns 0 for single-player. */
void(vector origin, vector forward, vector right, vector up, optional float reverbtype) SetListener = #351; /* Sets the position of the view, as far as the audio subsystem is concerned. This should be called once per CSQC_UpdateView as it will otherwise revert to default. For reverbtype, see setup_reverb or treat as 'underwater'. */
typedef struct {
	float flDensity;
	float flDiffusion;
	float flGain;
	float flGainHF;
	float flGainLF;
	float flDecayTime;
	float flDecayHFRatio;
	float flDecayLFRatio;
	float flReflectionsGain;
	float flReflectionsDelay;
	vector flReflectionsPan;
	float flLateReverbGain;
	float flLateReverbDelay;
	vector flLateReverbPan;
	float flEchoTime;
	float flEchoDepth;
	float flModulationTime;
	float flModulationDepth;
	float flAirAbsorptionGainHF;
	float flHFReference;
	float flLFReference;
	float flRoomRolloffFactor;
	int   iDecayHFLimit;
} reverbinfo_t;
void(float reverbslot, reverbinfo_t *reverbinfo, int sizeofreverinfo_t) setup_reverb = #0:setup_reverb; /* Part of FTE_CSQC_REVERB Reconfigures a reverb slot for weird effects. Slot 0 is reserved for no effects. Slot 1 is reserved for underwater effects. Reserved slots will be reinitialised on snd_restart, but can otherwise be changed. These reverb slots can be activated with SetListener. Note that reverb will currently only work when using OpenAL. */
#endif
#if defined(CSQC) || defined(MENU)
void(string cmdname) registercommand = #352; /*
		Register the given console command, for easy console use.
		Console commands that are later used will invoke CSQC_ConsoleCommand. */

#endif
#if defined(CSQC) || defined(SSQC)
float(entity ent) wasfreed = #353; /*
		Quickly check to see if the entity is currently free. This function is only valid during the two-second non-reuse window, after that it may give bad results. Try one second to make it more robust. */

string(string key) serverkey = #354; /*
		Look up a key in the server's public serverinfo string. If the key contains binary data then it will be truncated at the first null. */

float(string key, optional float assumevalue) serverkeyfloat = #0:serverkeyfloat; /*
		Version of serverkey that returns the value as a float (which avoids tempstrings). */

int(string key, optional void *ptr, int maxsize) serverkeyblob = #0:serverkeyblob; /*
		Version of serverkey that returns data as a blob (ie: binary data that may contain nulls). Returns the full blob size, even if truncated (pass maxsize=0 to query required storage). */

#endif
#ifdef SSQC
void(string key, void *ptr, optional int size) setserverkey = #0:setserverkey; /*
		Changes the server's serverinfo. */

#endif
#ifdef CSQC
string(optional string resetstring) getentitytoken = #355; /*
		Grab the next token in the map's entity lump.
		If resetstring is not specified, the next token will be returned with no other sideeffects.
		If empty, will reset from the map before returning the first token, probably {.
		If not empty, will tokenize from that string instead.
		Always returns tempstrings. */

#endif
#if defined(CSQC) || defined(MENU)
float(string s) findfont = #356; /* Part of DP_GFX_FONTS
		Looks up a named font slot. Matches the actual font name as a last resort. */

float(string fontname, string fontmaps, string sizes, float slot, optional float fix_scale, optional float fix_voffset) loadfont = #357; /* Part of DP_GFX_FONTS
		too convoluted for me to even try to explain correct usage. Try drawfont = loadfont("", "cour", "16", -1, 0, 0); to switch to the courier font (optimised for 16 virtual pixels high), if you have the freetype2 library in windows.. */

#endif
#ifdef CSQC
void(string evname, string evargs, ...) sendevent = #359; /*
		Invoke CSEv_evname_evargs in ssqc. evargs must be a string of initials refering to the types of the arguments to pass. v=vector, e=entity(.entnum field is sent), f=float, i=int. 6 arguments max - you can get more if you pack your floats into vectors. */

float() readbyte = #360;
float() readchar = #361;
float() readshort = #362;
float() readlong = #363;
float() readcoord = #364;
float() readangle = #365;
string() readstring = #366;
float() readfloat = #367;
float() readentitynum = #368;
float(string modelname, float(float isnew) updatecallback, float flags) deltalisten = #371; /*
		Specifies a per-modelindex callback to listen for engine-networking entity updates. Such entities are automatically interpolated by the engine (unless flags specifies not to).
		The various standard entity fields will be overwritten each frame before the updatecallback function is called. */

float(vector org, float radius, vector rgb) dynamiclight_spawnstatic = #0:dynamiclight_spawnstatic; /*
		Creates a static persistent light at the given position with the specified colour. Additional properties must be set via dynamiclight_set. */

__variant(float lno, float fld) dynamiclight_get = #372; /*
		Retrieves a property from the given dynamic/rt light. Return type depends upon the light field requested. */

void(float lno, float fld, __variant value) dynamiclight_set = #373; /*
		Changes a property on the given dynamic/rt light. Value type depends upon the light field to be changed. */

string(float efnum, float body) particleeffectquery = #374; /*
		Retrieves either the name or the body of the effect with the given number. The effect body is regenerated from internal state, and can be changed before being reapplied via the localcmd builtin. */

void(string shadername, vector origin, vector up, vector side, vector rgb, float alpha) adddecal = #375; /*
		Adds a temporary clipped decal shader to the scene, centered at the given point with given orientation. Will be drawn by the next renderscene call, and freed by the next clearscene call. */

#endif
#if defined(CSQC) || defined(MENU)
void(entity e, string skinfilename, optional string skindata) setcustomskin = #376; /* Part of FTE_QC_CUSTOMSKINS
		Sets an entity's skin overrides to a new skin object. Releases the entities old skin (refcounted). */

#endif
#ifdef CSQC
float(string skinfilename, optional string skindata) loadcustomskin = #377; /*
		Creates a new skin object and returns it. These are custom per-entity surface->shader lookups. The skinfilename/data should be in .skin format:
		surfacename,shadername - makes the named surface use the named shader (legacy format for compat with q3)
		replace "surfacename" "shadername" - non-legacy equivalent.
		qwskin "foo" - use an unmodified quakeworld player skin (including crop+repalette rules)
		q1lower 0xff0000 - specify an override for the entity's lower colour, in this case to red
		q1upper 0x0000ff - specify an override for the entity's lower colour, in this case to blue
		compose "surfacename" "shader" "imagename@x,y:w,h$s,t,s2,t2?r,g,b,a" - compose a skin texture from multiple images.
		  The texture is determined to be sufficient to hold the first named image, additional images can be named as extra tokens on the same line.
		  Use a + at the end of the line to continue reading image tokens from the next line also, the named shader must use 'map $diffuse' to read the composed texture (compatible with the defaultskin shader). Must be matched with a releasecustomskin call later, and is pointless without applycustomskin. */

void(entity e, float skinobj) applycustomskin = #378; /*
		Updates the entity's custom skin (refcounted). */

void(float skinobj) releasecustomskin = #379; /*
		Lets the engine know that the skin will no longer be needed. Thanks to refcounting any ents with the skin already applied will retain their skin until later changed. It is valid to destroy a skin just after applying it to an ent in the same function that it was created in, as the skin will only be destroyed once its refcount rops to 0. */

#endif
__variant*(int size) memalloc = #384; /* Part of FTE_MEMALLOC
		Allocate an arbitary block of memory */

void(__variant *ptr) memfree = #385; /* Part of FTE_MEMALLOC
		Frees a block of memory that was allocated with memfree */

void(__variant *dst, __variant *src, int size) memcpy = #386; /* Part of FTE_MEMALLOC
		Copys memory from one location to another */

void(__variant *dst, int val, int size) memfill8 = #387; /* Part of FTE_MEMALLOC
		Sets an entire block of memory to a specified value. Pretty much always 0. */

__variant(__variant *dst, float ofs) memgetval = #388; /*
		Looks up the 32bit value stored at a pointer-with-offset. */

void(__variant *dst, float ofs, __variant val) memsetval = #389; /*
		Changes the 32bit value stored at the specified pointer-with-offset. */

__variant*(__variant *base, float ofs) memptradd = #390; /*
		Perform some pointer maths. Woo. */

float(string s) memstrsize = #0:memstrsize; /*
		strlen, except ignores utf-8 */

#if defined(CSQC) || defined(MENU)
string(string conname, string field, optional string newvalue) con_getset = #391; /* Part of FTE_CSQC_ALTCONSOLES
		Reads or sets a property from a console object. The old value is returned. Iterrate through consoles with the 'next' field. Valid properties: 	title, name, next, unseen, markup, forceutf8, close, clear, hidden, linecount */

void(string conname, string messagefmt, ...) con_printf = #392; /* Part of FTE_CSQC_ALTCONSOLES
		Prints onto a named console. */

void(string conname, vector pos, vector size, float fontsize) con_draw = #393; /* Part of FTE_CSQC_ALTCONSOLES
		Draws the named console. */

float(string conname, float inevtype, float parama, float paramb, float paramc) con_input = #394; /* Part of FTE_CSQC_ALTCONSOLES
		Forwards input events to the named console. Mouse updates should be absolute only. */

void(string newcaption) setwindowcaption = #0:setwindowcaption; /* Part of FTE_CSQC_WINDOWCAPTION
		Replaces the title of the game window, as seen when task switching or just running in windowed mode. */

float() cvars_haveunsaved = #0:cvars_haveunsaved; /*
		Returns true if any archived cvar has an unsaved value. */

#endif
float(entity e, float nowreadonly) entityprotection = #0:entityprotection; /*
		Changes the protection on the specified entity to protect it from further edits from QC. The return value is the previous setting. Note that this can be used to unprotect the world, but doing so long term is not advised as you will no longer be able to detect invalid entity references. Also, world is not networked, so results might not be seen by clients (or in other words, world.avelocity_y=64 is a bad idea). */

#if defined(CSQC) || defined(SSQC)
entity(entity from, optional entity to) copyentity = #400; /* Part of DP_QC_COPYENTITY
		Copies all fields from one entity to another. */

#endif
#ifdef SSQC
void(entity ent, float colours) setcolors = #401; /*
		Changes a player's colours. The bits 0-3 are the lower/trouser colour, bits 4-7 are the upper/shirt colours. */

#endif
#if defined(CSQC) || defined(SSQC)
entity(.string field, string match, optional .entity chainfield) findchain = #402; /* Part of DP_QC_FINDCHAIN*/
entity(.float fld, float match, optional .entity chainfield) findchainfloat = #403; /* Part of DP_QC_FINDCHAINFLOAT*/
void(vector org, string modelname, float startframe, float endframe, float framerate) effect = #404; /* Part of DP_SV_EFFECT
		Spawns a self-animating sprite */

void(vector org, vector dir, float count) te_blood = #405; /* Part of DP_TE_BLOOD*/
void(vector mincorner, vector maxcorner, float explosionspeed, float howmany) te_bloodshower = #406; /* Part of _DP_TE_BLOODSHOWER*/
void(vector org, vector color) te_explosionrgb = #407; /* Part of DP_TE_EXPLOSIONRGB*/
void(vector mincorner, vector maxcorner, vector vel, float howmany, float color, float gravityflag, float randomveljitter) te_particlecube = #408; /* Part of DP_TE_PARTICLECUBE*/
void(vector mincorner, vector maxcorner, vector vel, float howmany, float color) te_particlerain = #409; /* Part of DP_TE_PARTICLERAIN*/
void(vector mincorner, vector maxcorner, vector vel, float howmany, float color) te_particlesnow = #410; /* Part of DP_TE_PARTICLESNOW*/
void(vector org, vector vel, float howmany) te_spark = #411; /* Part of DP_TE_SPARK*/
void(vector org) te_gunshotquad = #412; /* Part of _DP_TE_QUADEFFECTS1*/
void(vector org) te_spikequad = #413; /* Part of _DP_TE_QUADEFFECTS1*/
void(vector org) te_superspikequad = #414; /* Part of _DP_TE_QUADEFFECTS1*/
void(vector org) te_explosionquad = #415; /* Part of _DP_TE_QUADEFFECTS1*/
void(vector org) te_smallflash = #416; /* Part of DP_TE_SMALLFLASH*/
void(vector org, float radius, float lifetime, vector color) te_customflash = #417; /* Part of DP_TE_CUSTOMFLASH*/
void(vector org, optional float count) te_gunshot = #418; /* Part of DP_TE_STANDARDEFFECTBUILTINS, FTE_TE_STANDARDEFFECTBUILTINS*/
void(vector org) te_spike = #419; /* Part of DP_TE_STANDARDEFFECTBUILTINS, FTE_TE_STANDARDEFFECTBUILTINS*/
void(vector org) te_superspike = #420; /* Part of DP_TE_STANDARDEFFECTBUILTINS, FTE_TE_STANDARDEFFECTBUILTINS*/
void(vector org) te_explosion = #421; /* Part of DP_TE_STANDARDEFFECTBUILTINS, FTE_TE_STANDARDEFFECTBUILTINS*/
void(vector org) te_tarexplosion = #422; /* Part of DP_TE_STANDARDEFFECTBUILTINS, FTE_TE_STANDARDEFFECTBUILTINS*/
void(vector org) te_wizspike = #423; /* Part of DP_TE_STANDARDEFFECTBUILTINS, FTE_TE_STANDARDEFFECTBUILTINS*/
void(vector org) te_knightspike = #424; /* Part of DP_TE_STANDARDEFFECTBUILTINS, FTE_TE_STANDARDEFFECTBUILTINS*/
void(vector org) te_lavasplash = #425; /* Part of DP_TE_STANDARDEFFECTBUILTINS, FTE_TE_STANDARDEFFECTBUILTINS*/
void(vector org) te_teleport = #426; /* Part of DP_TE_STANDARDEFFECTBUILTINS, FTE_TE_STANDARDEFFECTBUILTINS*/
void(vector org, float color, float colorlength) te_explosion2 = #427; /* Part of DP_TE_STANDARDEFFECTBUILTINS*/
void(entity own, vector start, vector end) te_lightning1 = #428; /* Part of DP_TE_STANDARDEFFECTBUILTINS, FTE_TE_STANDARDEFFECTBUILTINS*/
void(entity own, vector start, vector end) te_lightning2 = #429; /* Part of DP_TE_STANDARDEFFECTBUILTINS, FTE_TE_STANDARDEFFECTBUILTINS*/
void(entity own, vector start, vector end) te_lightning3 = #430; /* Part of DP_TE_STANDARDEFFECTBUILTINS, FTE_TE_STANDARDEFFECTBUILTINS*/
void(entity own, vector start, vector end) te_beam = #431; /* Part of DP_TE_STANDARDEFFECTBUILTINS*/
void(vector dir) vectorvectors = #432; /* Part of DP_QC_VECTORVECTORS*/
void(vector org) te_plasmaburn = #433; /* Part of _DP_TE_PLASMABURN*/
float(entity e, float s) getsurfacenumpoints = #434; /* Part of DP_QC_GETSURFACE*/
vector(entity e, float s, float n) getsurfacepoint = #435; /* Part of DP_QC_GETSURFACE*/
vector(entity e, float s) getsurfacenormal = #436; /* Part of DP_QC_GETSURFACE*/
string(entity e, float s) getsurfacetexture = #437; /* Part of DP_QC_GETSURFACE*/
float(entity e, vector p) getsurfacenearpoint = #438; /* Part of DP_QC_GETSURFACE*/
vector(entity e, float s, vector p) getsurfaceclippedpoint = #439; /* Part of DP_QC_GETSURFACE*/
#endif
#ifdef MENU
float(string name) iscachedpic = #451;
string(string name, optional float trywad) precache_pic = #452;
float(vector position, float character, vector scale, vector rgb, float alpha, optional float flag) drawcharacter = #454;
float(vector position, string text, vector scale, vector rgb, float alpha, optional float flag) drawrawstring = #455;
float(vector position, string pic, vector size, vector rgb, float alpha, optional float flag) drawpic = #456;
float(vector position, vector size, vector rgb, float alpha, optional float flag) drawfill = #457;
void(float x, float y, float width, float height) drawsetcliparea = #458;
void(void) drawresetcliparea = #459;
vector(string picname) drawgetimagesize = #460;
float(vector position, string text, vector scale, vector rgb, float alpha, float flag) drawstring = #467;
float(string text, float usecolours, optional vector fontsize) stringwidth = #468;
void(vector pos, vector sz, string pic, vector srcpos, vector srcsz, vector rgb, float alpha, float flag) drawsubpic = #469;
#endif
void(entity e, string s) clientcommand = #440; /* Part of KRIMZON_SV_PARSECLIENTCOMMAND*/
float(string s) tokenize = #441; /* Part of KRIMZON_SV_PARSECLIENTCOMMAND*/
string(float n) argv = #442; /* Part of KRIMZON_SV_PARSECLIENTCOMMAND*/
void(entity e, entity tagentity, string tagname) setattachment = #443; /* Part of DP_GFX_QUAKE3MODELTAGS*/
#if defined(CSQC) || defined(SSQC)
string(string cvarname) cvar_string = #448; /* Part of DP_QC_CVAR_STRING*/
entity(entity start, .float fld, float match) findflags = #449; /* Part of DP_QC_FINDFLAGS*/
entity(.float fld, float match, optional .entity chainfield) findchainflags = #450; /* Part of DP_QC_FINDCHAINFLAGS*/
float(entity ent, string tagname) gettagindex = #451; /* Part of DP_QC_GETTAGINFO*/
vector(entity ent, float tagindex) gettaginfo = #452; /* Part of DP_QC_GETTAGINFOObtains the current worldspace position+orientation of the bone or tag from the given entity. The return value is the world coord, v_forward, v_right, v_up are also set according to the bone/tag's orientation. */
#endif
#ifdef SSQC
void(entity player) dropclient = #453; /* Part of DP_SV_DROPCLIENT*/
entity() spawnclient = #454; /* Part of DP_SV_BOTCLIENT*/
float(entity client) clienttype = #455; /* Part of DP_SV_BOTCLIENT*/
void(float target, string str) WriteUnterminatedString = #456; /* Part of DP_SV_WRITEUNTERMINATEDSTRING*/
#endif
void(vector org, vector vel, float howmany) te_flamejet = #457; /* Part of _DP_TE_FLAMEJET*/
entity(float entnum) edict_num = #459; /* Part of DP_QC_EDICT_NUM*/
float(float s) asin = #471; /* Part of DP_QC_ASINACOSATANATAN2TAN*/
float(float c) acos = #472; /* Part of DP_QC_ASINACOSATANATAN2TAN*/
float(float t) atan = #473; /* Part of DP_QC_ASINACOSATANATAN2TAN*/
float(float c, float s) atan2 = #474; /* Part of DP_QC_ASINACOSATANATAN2TAN*/
float(float a) tan = #475; /* Part of DP_QC_ASINACOSATANATAN2TAN Forgive me father, for I have a sunbed and I'm not afraid to use it. */
float(string s) strlennocol = #476; /* Part of DP_QC_STRINGCOLORFUNCTIONS Returns the number of characters in the string after any colour codes or other markup has been parsed. */
string(string s) strdecolorize = #477; /* Part of DP_QC_STRINGCOLORFUNCTIONS Flattens any markup/colours, removing them from the string. */
string(float uselocaltime, string format, ...) strftime = #478; /* Part of DP_QC_STRFTIME*/
float(string s, string separator1, ...) tokenizebyseparator = #479; /* Part of DP_QC_TOKENIZEBYSEPARATOR*/
string(string s) strtolower = #480; /* Part of DP_QC_STRING_CASE_FUNCTIONS*/
string(string s) strtoupper = #481; /* Part of DP_QC_STRING_CASE_FUNCTIONS*/
string(string s) cvar_defstring = #482; /* Part of DP_QC_CVAR_DEFSTRING*/
#if defined(CSQC) || defined(SSQC)
void(vector origin, string sample, float volume, float attenuation) pointsound = #483; /* Part of DP_SV_POINTSOUND*/
#endif
string(string search, string replace, string subject) strreplace = #484; /* Part of DP_QC_STRREPLACE*/
string(string search, string replace, string subject) strireplace = #485; /* Part of DP_QC_STRREPLACE*/
#if defined(CSQC) || defined(SSQC)
vector(entity e, float s, float n, float a) getsurfacepointattribute = #486; /* Part of DP_QC_GETSURFACEPOINTATTRIBUTE*/
#endif
#if defined(CSQC) || defined(MENU)
float(string name, optional string initialURI) gecko_create = #487; /* Part of DP_GECKO_SUPPORT
		Create a new 'browser tab' shader with the specified name that can then be drawn via drawpic (shader should not already exist - including from map/model textures or disk). In order to function correctly, this builtin depends upon external plugins being available. Use gecko_navigate to navigate it to a page of your choosing. */

void(string name) gecko_destroy = #488; /* Part of DP_GECKO_SUPPORT
		Destroy a shader. */

void(string name, string URI) gecko_navigate = #489; /* Part of DP_GECKO_SUPPORT
		Sends a command to the media decoder attached to the specified shader. In the case of a browser decoder, this changes the url that the browser displays. 'cmd:[un]focus' will tell the decoder that it has focus. */

float(string name, float key, float eventtype, optional float charcode) gecko_keyevent = #490; /* Part of DP_GECKO_SUPPORT
		Send a key event to a media decoder. This applies only to interactive decoders like browsers. */

void(string name, float x, float y) gecko_mousemove = #491; /* Part of DP_GECKO_SUPPORT
		Sets a media decoder shader's mouse position. Values should be 0-1. */

void(string name, float w, float h) gecko_resize = #492; /* Part of DP_GECKO_SUPPORT
		Request to resize a media decoder. */

vector(string name) gecko_get_texture_extent = #493; /* Part of DP_GECKO_SUPPORT
		Retrieves a media decoder current image pixel sizes. */

string(string shadname, string propname) gecko_getproperty = #0:gecko_getproperty; /*
		Queries the media decoder (especially browser ones) for decoder-specific properties. The cef plugin recognises url, title, status. */

#endif
#ifdef CSQC
float(string file, string id) cin_open = #0:cin_open;
void(string id) cin_close = #0:cin_close;
void(string id, float newstate) cin_setstate = #0:cin_setstate;
float(string id) cin_getstate = #0:cin_getstate;
void(string file) cin_restart = #0:cin_restart;
#endif
float(float caseinsensitive, string s, ...) crc16 = #494; /* Part of DP_QC_CRC16*/
float(string name) cvar_type = #495; /* Part of DP_QC_CVAR_TYPE*/
float() numentityfields = #496; /* Part of DP_QC_ENTITYDATA Gives the number of named entity fields. Note that this is not the size of an entity, but rather just the number of unique names (ie: vectors use 4 names rather than 3). */
float(string fieldname) findentityfield = #0:findentityfield; /*Find a field index by name. */
typedef .__variant field_t;
field_t(float fieldnum) entityfieldref = #0:entityfieldref; /*Returns a field value that can be directly used to read entity fields. Be sure to validate the type with entityfieldtype before using. */
string(float fieldnum) entityfieldname = #497; /* Part of DP_QC_ENTITYDATA Retrieves the name of the given entity field. */

float(float fieldnum) entityfieldtype = #498; /* Part of DP_QC_ENTITYDATA
		Provides information about the type of the field specified by the field num. Returns one of the EV_ values. */

string(float fieldnum, entity ent) getentityfieldstring = #499; /* Part of DP_QC_ENTITYDATA*/
float(float fieldnum, entity ent, string s) putentityfieldstring = #500; /* Part of DP_QC_ENTITYDATA*/
void(float to, string s, float sz) WritePicture = #501; /* Part of DP_SV_WRITEPICTURE Encodes the named image across the network as-is adhering to some size limit. In FTE, this simply writes the string and is equivelent to writestring and sz is ignored. WritePicture should be paired with ReadPicture in csqc. */
#ifdef CSQC
	string() ReadPicture = #501; /*Reads a picture that was written by ReadPicture, and returns a name that can be used in drawpic and other 2d drawing functions. In FTE, this acts as a readstring-with-downloadcheck - the image will appear normally once it has been downloaded, but its size may be incorrect until then. */
	void(float effectindex, entity own, vector org_from, vector org_to, vector dir_from, vector dir_to, float countmultiplier, optional float flags) boxparticles = #502;
	__variant(float entnum, float fieldnum) getentity = #504; /* Looks up fields from non-csqc-visible entities. The entity will need to be within the player's pvs. fieldnum should be one of the GE_ constants. */
#endif
string(string in) uri_escape = #510; /* Part of DP_QC_URI_ESCAPE*/
string(string in) uri_unescape = #511; /* Part of DP_QC_URI_ESCAPE*/
float(entity ent) num_for_edict = #512;
#define uri_post uri_get
float(string uril, float id, optional string postmimetype, optional string postdata) uri_get = #513; /* Part of DP_QC_URI_GET, DP_QC_URI_POST
		uri_get() gets content from an URL and calls a callback "uri_get_callback" with it set as string; an unique ID of the transfer is returned
		returns 1 on success, and then calls the callback with the ID, 0 or the HTTP status code, and the received data in a string
		For a POST request, you will typically want the postmimetype set to application/x-www-form-urlencoded.
		For a GET request, omit the mime+data entirely.
		Consult your webserver/php/etc documentation for best-practise. */
float(string str) tokenize_console = #514; /*Tokenize a string exactly as the console's tokenizer would do so. The regular tokenize builtin became bastardized for convienient string parsing, which resulted in a large disparity that can be exploited to bypass checks implemented in a naive SV_ParseClientCommand function, therefore you can use this builtin to make sure it exactly matches. */
float(float idx) argv_start_index = #515; /*Returns the character index that the tokenized arg started at. */
float(float idx) argv_end_index = #516; /*Returns the character index that the tokenized arg stopped at. */
#if defined(CSQC) || defined(SSQC)
float(optional float timetype) gettime = #519;
#endif
#ifdef CSQC
string(float keynum) keynumtostring_omgwtf = #520;
string(string command, optional float bindmap) findkeysforcommand = #521; /*Returns a list of keycodes that perform the given console command in a format that can only be parsed via tokenize (NOT tokenize_console). This only and always returns two values - if only one key is actually bound, -1 will be returned. The bindmap argument is listed for compatibility with dp-specific defs, but is ignored in FTE. */
string(string command, optional float bindmap) findkeysforcommandex = #0:findkeysforcommandex; /*Returns a list of key bindings in keyname format instead of keynums. Use tokenize to parse. This list may contain modifiers. May return large numbers of keys. */
#endif
void(string s) loadfromdata = #529; /*Reads a set of entities from the given string. This string should have the same format as a .ent file or a saved game. Entities will be spawned as required. If you need to see the entities that were created, you should use parseentitydata instead. */
void(string s) loadfromfile = #530; /*Reads a set of entities from the named file. This file should have the same format as a .ent file or a saved game. Entities will be spawned as required. If you need to see the entities that were created, you should use parseentitydata instead. */
void(float pause) setpause = #531; /*Sets whether the server should or should not be paused. This does not affect auto-paused things like when the console is down. */
float(string mname) precache_vwep_model = #532; /* Part of ZQ_VWEP*/
// float(string filename, strbuf bufhandle) buf_loadfile = #535; /*Appends the named file into a string buffer (which must have been created in advance). The return value merely says whether the file was readable. */
// float(filestream filehandle, strbuf bufhandle, optional float startpos, optional float numstrings) buf_writefile = #536; /* Writes the contents of a string buffer onto the end of the supplied filehandle (you must have already used fopen). Additional optional arguments permit you to constrain the writes to a subsection of the stringbuffer. */
float(optional float forcestate) physics_supported = #0:physics_supported; /*Queries whether rigid body physics is enabled or not. CSQC and SSQC may report different values. If the force argument is specified then the engine will try to activate or release physics (returning the new state, which may fail if plugins or dlls are missing). Note that restarting the physics engine is likely to result in hitches when collision trees get generated. The state may change if a plugin is disabled mid-map. */
void(entity e, float physics_enabled) physics_enable = #540; /*Enable or disable the physics attached to a MOVETYPE_PHYSICS entity. Entities which have been disabled in this way will stop taking so much cpu time. */
void(entity e, vector force, vector relative_ofs) physics_addforce = #541; /*Apply some impulse directional force upon a MOVETYPE_PHYSICS entity. */
void(entity e, vector torque) physics_addtorque = #542; /*Apply some impulse rotational force upon a MOVETYPE_PHYSICS entity. */
void(.../*, string funcname*/) callfunction = #605; /*Invokes the named function. The function name is always passed as the last parameter and must always be present. The others are passed to the named function as-is */
// void(filestream fh, entity e) writetofile = #606; /*Writes an entity's fields to the named frik_file file handle. */
float(string s) isfunction = #607; /* Returns true if the named function exists and can be called with the callfunction builtin. */
string(entity e) generateentitydata = #0:generateentitydata; /*Dumps the entities fields into a string which can later be parsed with parseentitydata. */
string(string dnsname, optional float defport) netaddress_resolve = #625;
string(string fmt, ...) sprintf = #627; /* Part of DP_QC_SPRINTF 'prints' to a formatted temp-string. Mostly acts as in C, however %d assumes floats (fteqcc has arg checking. Use it.). type conversions: l=arg is an int, h=arg is a float, and will work as a prefix for any float or int representation. float representations: d=decimal, e,E=exponent-notation, f,F=floating-point notation, g,G=terse float, c=char code, x,X=hex other representations: i=int, s=string, S=quoted and marked-up string, v=vector, p=pointer so %ld will accept an int arg, while %hi will expect a float arg. entities, fields, and functions will generally need to be printed as ints with %i. */
float(entity e, float s) getsurfacenumtriangles = #628;
vector(entity e, float s, float n) getsurfacetriangle = #629;
string(string digest, string data, ...) digest_hex = #639;
string(string digest, void *data, int length) digest_ptr = #0:digest_ptr; /* Calculates the digest of a single contiguous block of memory (including nulls) using the specified hash function. */

// #pragma noref 0

// Welp.  Yeah.  Pretty ugly but whatever.