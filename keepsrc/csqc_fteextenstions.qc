//Separated off the csqc and menu.qc defs here for convenience
// This file was generated by FTE Quake 5570, dated Oct 18 2019.
// This file can be regenerated by issuing the following command:
// pr_dumpplatform -o fteextensions
/* Available options:
-Ffte       - target only FTE (optimations and additional extensions)
-Tnq        - dump specifically NQ fields
-Tqw        - dump specifically QW fields
-Tcs        - dump specifically CSQC fields
-Tmenu      - dump specifically menuqc fields
-Fdefines   - generate #defines instead of constants
-Faccessors - use accessors instead of basic types via defines
-O          - write to a different qc file
*/
#pragma noref 1
#pragma warning error Q101 /*too many parms. The vanilla qcc didn't validate properly, hence why fteqcc normally treats it as a warning.*/
#pragma warning error Q105 /*too few parms. The vanilla qcc didn't validate properly, hence why fteqcc normally treats it as a warning.*/
#pragma warning error Q106 /*assignment to constant/lvalue. Define them as var if you want to initialise something.*/
#pragma warning error Q208 /*system crc unknown. Compatibility goes out of the window if you disable this.*/
#pragma warning disable F211 /*system crc outdated (eg: dp's csqc). Note that this may trigger emulation.*/
#pragma warning enable F301 /*non-utf-8 strings. Think of the foreigners! Also think of text editors that insist on screwing up your char encodings.*/
#pragma warning enable F302 /*uninitialised locals. They usually default to 0 in qc (except in recursive functions), but its still probably a bug*/
#if !defined(CSQC) && !defined(NQSSQC) && !defined(QWSSQC)&& !defined(MENU)
	#ifdef QUAKEWORLD
		#define QWSSQC
	#else
		#define NQSSQC
	#endif
#endif
#if !defined(SSQC) && (defined(QWSSQC) || defined(NQSSQC))
	#define SSQC
#endif
#define FTE_PEXT_SETVIEW /* NQ's svc_setview works correctly even in quakeworld */
#define DP_ENT_SCALE
#define FTE_PEXT_LIGHTSTYLECOL
#define DP_ENT_ALPHA
#define FTE_PEXT_VIEW2
#define FTE_PEXT_ACURATETIMINGS
#define FTE_PEXT_SOUNDDBL
#define FTE_PEXT_FATNESS
#define DP_HALFLIFE_MAP
#define FTE_PEXT_TE_BULLET
#define FTE_PEXT_HULLSIZE
#define FTE_PEXT_MODELDBL
#define FTE_PEXT_ENTITYDBL
#define FTE_PEXT_ENTITYDBL2
#define FTE_PEXT_FLOATCOORDS
#define FTE_PEXT_VWEAP
#define FTE_PEXT_Q2BSP
#define FTE_PEXT_Q3BSP
#define DP_ENT_COLORMOD
#define FTE_HEXEN2
#define FTE_PEXT_SPAWNSTATIC
#define FTE_PEXT_CUSTOMTENTS
#define FTE_PEXT_256PACKETENTITIES
#define TEI_SHOWLMP2
#define DP_GFX_QUAKE3MODELTAGS
#define FTE_PK3DOWNLOADS
#define PEXT_CHUNKEDDOWNLOADS
#define EXT_CSQC_SHARED
#define PEXT_DPFLAGS
#define EXT_CSQC
#define BX_COLOREDTEXT
#define DP_CON_SET /* The 'set' console command exists, and can be used to create/set cvars. */
#define DP_CON_SETA /* The 'seta' console command exists, like the 'set' command, but also marks the cvar for archiving, allowing it to be written into the user's config. Use this command in your default.cfg file. */
#define DP_EF_ADDITIVE
#define DP_EF_BLUE
#define DP_EF_FULLBRIGHT
#define DP_EF_NODEPTHTEST
#define DP_EF_NODRAW
#define DP_EF_NOGUNBOB
#define DP_EF_NOSHADOW
#define DP_EF_RED
#define DP_ENT_CUSTOMCOLORMAP
#define DP_ENT_EXTERIORMODELTOCLIENT
#define DP_ENT_TRAILEFFECTNUM /* self.traileffectnum=particleeffectnum("myeffectname"); can be used to attach a particle trail to the given server entity. This is equivelent to calling trailparticles each frame. */
#define DP_ENT_VIEWMODEL
#define DP_GECKO_SUPPORT
#define DP_GFX_FONTS
#define DP_GFX_SKINFILES
#define DP_GFX_SKYBOX
#define DP_HALFLIFE_MAP_CVAR
#define DP_INPUTBUTTONS
#define DP_LIGHTSTYLE_STATICVALUE
#define DP_LITSUPPORT
#define DP_MONSTERWALK /* MOVETYPE_WALK is valid on non-player entities. Note that only players receive acceleration etc in line with none/bounce/fly/noclip movetypes on the player, thus you will have to provide your own accelerations (incluing gravity) yourself. */
#define DP_MOVETYPEBOUNCEMISSILE
#define DP_MOVETYPEFOLLOW
#define DP_QC_ASINACOSATANATAN2TAN
#define DP_QC_CHANGEPITCH
#define DP_QC_COPYENTITY
#define DP_QC_CRC16
#define DP_QC_CVAR_DEFSTRING
#define DP_QC_CVAR_STRING
#define DP_QC_CVAR_TYPE
#define DP_QC_EDICT_NUM
#define DP_QC_ENTITYDATA
#define DP_QC_ETOS
#define DP_QC_FINDCHAIN
#define DP_QC_FINDCHAINFLOAT
#define DP_QC_FINDFLAGS
#define DP_QC_FINDCHAINFLAGS
#define DP_QC_FINDFLOAT
#define DP_QC_FS_SEARCH
#define DP_QC_GETSURFACE
#define DP_QC_GETSURFACEPOINTATTRIBUTE
#define DP_QC_GETTAGINFO
#define DP_QC_MINMAXBOUND
#define DP_QC_MULTIPLETEMPSTRINGS /* Superseded by DP_QC_UNLIMITEDTEMPSTRINGS. Functions that return a temporary string will not overwrite/destroy previous temporary strings until at least 16 strings are returned (or control returns to the engine). */
#define DP_QC_RANDOMVEC
#define DP_QC_RENDER_SCENE /* clearscene+addentity+setviewprop+renderscene+setmodel are available to menuqc. WARNING: DP advertises this extension without actually supporting it, FTE does actually support it. */
#define DP_QC_SINCOSSQRTPOW
#define DP_QC_SPRINTF /* Provides the sprintf builtin, which allows for rich formatting along the lines of C's function with the same name. Not to be confused with QC's sprint builtin. */
#define DP_QC_STRFTIME
#define DP_QC_STRING_CASE_FUNCTIONS
#define DP_QC_STRINGBUFFERS
#define DP_QC_STRINGCOLORFUNCTIONS
#define DP_QC_STRREPLACE
#define DP_QC_TOKENIZEBYSEPARATOR
#define DP_QC_TRACEBOX
#define DP_QC_TRACETOSS
#define DP_QC_TRACE_MOVETYPE_HITMODEL
#define DP_QC_TRACE_MOVETYPE_WORLDONLY
#define DP_QC_TRACE_MOVETYPES
#define DP_QC_UNLIMITEDTEMPSTRINGS /* Supersedes DP_QC_MULTIPLETEMPSTRINGS, superseded by FTE_QC_PERSISTENTTEMPSTRINGS. Specifies that all temp strings will be valid at least until the QCVM returns. */
#define DP_QC_URI_ESCAPE
#define DP_QC_URI_GET
#define DP_QC_URI_POST
#define DP_QC_VECTOANGLES_WITH_ROLL
#define DP_QC_VECTORVECTORS
#define DP_QC_WHICHPACK
#define DP_QUAKE2_MODEL
#define DP_QUAKE2_SPRITE
#define DP_QUAKE3_MODEL
#define DP_REGISTERCVAR
#define DP_SND_SOUND7_WIP2
#define DP_SND_STEREOWAV
#define DP_SND_OGGVORBIS
#define DP_SOLIDCORPSE
#define DP_SPRITE32
#define DP_SV_BOTCLIENT
#define DP_SV_CLIENTCAMERA /* Works like svc_setview except also handles pvs. */
#define DP_SV_CLIENTCOLORS /* Provided only for compatibility with DP. */
#define DP_SV_CLIENTNAME /* Provided only for compatibility with DP. */
#define DP_SV_DRAWONLYTOCLIENT
#define DP_SV_DROPCLIENT /* Equivelent to quakeworld's stuffcmd(self,"disconnect\n"); hack */
#define DP_SV_EFFECT
#define DP_SV_EXTERIORMODELFORCLIENT
#define DP_SV_NODRAWTOCLIENT
#define DP_SV_PLAYERPHYSICS /* Allows reworking parts of NQ player physics. USE AT OWN RISK - this necessitates NQ physics and is thus guarenteed to break prediction. */
#define DP_SV_POINTSOUND
#define DP_SV_PRECACHEANYTIME /* Specifies that the various precache builtins can be called at any time. WARNING: precaches are sent reliably while sound events, modelindexes, and particle events are not. This can mean sounds and particles might not work the first time around, or models may take a while to appear (after the reliables are received and the model is loaded from disk). Always attempt to precache a little in advance in order to reduce these issues (preferably at the start of the map...) */
#define DP_SV_PRINT /* Says that the print builtin can be used from nqssqc (as well as just csqc), bypassing the developer cvar issues. */
#define DP_SV_SETCOLOR
#define DP_SV_SPAWNFUNC_PREFIX
#define DP_SV_WRITEPICTURE
#define DP_SV_WRITEUNTERMINATEDSTRING
#define DP_TE_BLOOD
#define DP_TE_CUSTOMFLASH
#define DP_TE_EXPLOSIONRGB
#define DP_TE_PARTICLECUBE
#define DP_TE_PARTICLERAIN
#define DP_TE_PARTICLESNOW
#define DP_TE_SMALLFLASH
#define DP_TE_SPARK
#define DP_TE_STANDARDEFFECTBUILTINS
#define DP_VIEWZOOM
#define EXT_BITSHIFT
#define EXT_DIMENSION_VISIBILITY
#define EXT_DIMENSION_PHYSICS
#define EXT_DIMENSION_GHOST
#define FRIK_FILE
#define FTE_CALLTIMEOFDAY /* Replication of mvdsv functionality (call calltimeofday to cause 'timeofday' to be called, with arguments that can be saved off to a global). Generally strftime is simpler to use. */
#define FTE_CSQC_ALTCONSOLES /* The engine tracks multiple consoles. These may or may not be directly visible to the user. */
#define FTE_CSQC_BASEFRAME /* Specifies that .basebone, .baseframe2, .baselerpfrac, baseframe1time, etc exist in csqc. These fields affect all bones in the entity's model with a lower index than the .basebone field, allowing you to give separate control to the legs of a skeletal model, without affecting the torso animations. */
#define FTE_CSQC_HALFLIFE_MODELS
#define FTE_CSQC_SERVERBROWSER /* Provides builtins to query the engine's serverbrowser servers list from ssqc. Note that these builtins are always available in menuqc. */
#define FTE_CSQC_SKELETONOBJECTS /* Provides container objects for skeletal bone data, which can be modified on a per bone basis if needed. This allows you to dynamically generate animations (or just blend them with greater customisation) instead of being limited to a single animation or two. */
#define FTE_CSQC_RAWIMAGES /* Provides raw rgba image access to csqc. With this, the csprogs can read textures into qc-accessible memory, modify it, and then upload it to the renderer. */
#define FTE_CSQC_RENDERTARGETS /* VF_RT_DESTCOLOUR exists and can be used to redirect any rendering to a texture instead of the screen. */
#define FTE_CSQC_REVERB /* Specifies that the mod can create custom reverb effects. Whether they will actually be used or not depends upon the sound driver. */
#define FTE_CSQC_WINDOWCAPTION /* Provides csqc with the ability to change the window caption as displayed when running windowed or in the task bar when switched out. */
#define FTE_ENT_SKIN_CONTENTS /* self.skin = CONTENTS_WATER; makes a brush entity into water. use -16 for a ladder. */
#define FTE_ENT_UNIQUESPAWNID
#define FTE_EXTENDEDTEXTCODES
#define FTE_FORCESHADER /* Allows csqc to override shaders on models with an explicitly named replacement. Also allows you to define shaders with a fallback if it does not exist on disk. */
#define FTE_FORCEINFOKEY /* Provides an easy way to change a user's userinfo from the server. */
#define FTE_GFX_QUAKE3SHADERS /* specifies that the engine has full support for vanilla quake3 shaders */
#define FTE_GFX_REMAPSHADER /* With the raw power of stuffcmds, the r_remapshader console command is exposed! This mystical command can be used to remap any shader to another. Remapped shaders that specify $diffuse etc in some form will inherit the textures implied by the surface. */
#define FTE_GFX_MODELEVENTS /* Provides a query for per-animation events in model files, including from progs/foo.mdl.events files. */
#define FTE_ISBACKBUFFERED /* Allows you to check if a client has too many reliable messages pending. */
#define FTE_MEMALLOC /* Allows dynamically allocating memory. Use pointers to access this memory. Memory will not be saved into saved games. */
#define FTE_MEDIA_CIN /* playfilm command supports q2 cin files. */
#define FTE_MEDIA_ROQ /* playfilm command supports q3 roq files. */
#define FTE_MULTIPROGS /* Multiple progs.dat files can be loaded inside the same qcvm. Insert new ones with addprogs inside the 'init' function, and use externvalue+externset to rewrite globals (and hook functions) to link them together. Note that the result is generally not very clean unless you carefully design for it beforehand. */
#define FTE_MULTITHREADED /* Faux multithreading, allowing multiple contexts to run in sequence. */
#define FTE_MVD_PLAYERSTATS /* In csqc, getplayerstat can be used to query any player's stats when playing back MVDs. isdemo will return 2 in this case. */
#define FTE_PART_SCRIPT /* Specifies that the r_particledesc cvar can be used to select a list of particle effects to load from particles/*.cfg, the format of which is documented elsewhere. */
#define FTE_PART_NAMESPACES /* Specifies that the engine can use foo.bar to load effect foo from particle description bar. When used via ssqc, this should cause the client to download whatever effects as needed. */
#define FTE_PART_NAMESPACE_EFFECTINFO /* Specifies that effectinfo.bar can load effects from effectinfo.txt for DP compatibility. */
#define FTE_QC_BASEFRAME /* Specifies that .basebone and .baseframe exist in ssqc. These fields affect all bones in the entity's model with a lower index than the .basebone field, allowing you to give separate control to the legs of a skeletal model, without affecting the torso animations, from ssqc. */
#define FTE_QC_FILE_BINARY /* Extends FRIK_FILE with binary read+write, as well as allowing seeking. Requires pointers. */
#define FTE_QC_CHANGELEVEL_HUB /* Adds an extra argument to changelevel which is carried over to the next map in the 'spawnspot' global. Maps will be saved+reloaded until the extra argument is omitted again, purging all saved maps. Saved games will contain a copy of each preserved map. parm1-parm64 globals can be used, giving more space to transfer more player data. */
#define FTE_QC_CHECKCOMMAND /* Provides a way to test if a console command exists, and whether its a command/alias/cvar. Does not say anything about the expected meanings of any arguments or values. */
#define FTE_QC_CHECKPVS
#define FTE_QC_CROSSPRODUCT
#define FTE_QC_CUSTOMSKINS /* The engine supports the use of q3 skins, as well as the use of such skin 'files' to specify rich top+bottom colours, qw skins, geomsets, or texture composition even on non-players.. */
#define FTE_QC_FS_SEARCH_SIZEMTIME
#define FTE_QC_HARDWARECURSORS /* setcursormode exists in both csqc+menuqc, and accepts additional arguments to specify a cursor image to use when this module has focus. If the image exceeds hardware limits (or hardware cursors are unsupported), it will be emulated using regular draws - this at least still avoids conflicting cursors as only one will ever be used, even if console+menu+csqc are all overlayed. */
#define FTE_QC_INFOKEY /* QuakeWorld's infokey builtin works, and reports at least name+topcolor+bottomcolor+ping(in ms)+ip(unmasked, but not always ipv4)+team(aka bottomcolor in nq). Does not require actual localinfo/serverinfo/userinfo, but they're _highly_ recommended to any engines with csqc */
#define FTE_QC_INTCONV /* Provides string<>int conversions, including hex representations. */
#define FTE_QC_MATCHCLIENTNAME
#define FTE_QC_MULTICAST /* QuakeWorld's multicast builtin works along with MSG_MULTICAST, but also with unicast support. */
#define FTE_QC_PAUSED
#define FTE_QC_PERSISTENTTEMPSTRINGS /* Supersedes DP_QC_MULTIPLETEMPSTRINGS. Temp strings are garbage collected automatically, and do not expire while they're still in use. This makes strzone redundant. */
#define FTE_QC_RAGDOLL_WIP
#define FTE_QC_SENDPACKET /* Allows the use of out-of-band udp packets to/from other hosts. Includes the SV_ParseConnectionlessPacket event. */
#define FTE_QC_STUFFCMDFLAGS /* Variation on regular stuffcmd that gives control over how spectators/mvds should be treated. */
#define FTE_QC_TRACETRIGGER
#define FTE_QUAKE2_CLIENT /* This engine is able to act as a quake2 client */
#define FTE_QUAKE2_SERVER /* This engine is able to act as a quake2 server */
#define FTE_QUAKE3_CLIENT /* This engine is able to act as a quake3 client */
#define FTE_QUAKE3_SERVER /* This engine is able to act as a quake3 server */
#define FTE_SPLITSCREEN /* Client supports splitscreen, controlled via cl_splitscreen. Servers require allow_splitscreen 1 if splitscreen is to be used over the internet. Mods that use csqc will need to be aware for this to work properly. per-client networking may be problematic. */
#define FTE_SQL /* Provides sql* builtins which can be used for sql database access */
#define FTE_SQL_SQLITE /* SQL functionality is able to utilise sqlite databases */
#define FTE_STRINGS /* Extra builtins (and additional behaviour) to make string manipulation easier */
#define FTE_SV_POINTPARTICLES /* Specifies that particleeffectnum, pointparticles, and trailparticles exist in ssqc as well as csqc. particleeffectnum acts as a precache, allowing ssqc values to be networked up with csqc for use. Use in combination with FTE_PART_SCRIPT+FTE_PART_NAMESPACES to use custom effects. This extension is functionally identical to the DP version, but avoids any misplaced assumptions about the format of the client's particle descriptions. */
#define FTE_SV_REENTER
#define FTE_TE_STANDARDEFFECTBUILTINS /* Provides builtins to replace writebytes, with a QW compatible twist. */
#define FTE_TERRAIN_MAP /* This engine supports .hmp files, as well as terrain embedded within bsp files. */
#define FTE_RAW_MAP /* This engine supports directly loading .map files, as well as realtime editing of the various brushes. */
#define KRIMZON_SV_PARSECLIENTCOMMAND /* SSQC's SV_ParseClientCommand function is able to handle client 'cmd' commands. The tokenizing parts also work in csqc. */
#define NEH_CMD_PLAY2
#define NEH_RESTOREGAME
#define QSG_CVARSTRING
#define QW_ENGINE
#define QWE_MVD_RECORD /* You can use the easyrecord command to record MVD demos serverside. */
#define TEI_MD3_MODEL
#define TENEBRAE_GFX_DLIGHTS /* Allows ssqc to attach rtlights to entities with various special properties. */
#define ZQ_MOVETYPE_FLY /* MOVETYPE_FLY works on players. */
#define ZQ_MOVETYPE_NOCLIP /* MOVETYPE_NOCLIP works on players. */
#define ZQ_MOVETYPE_NONE /* MOVETYPE_NONE works on players. */
#define ZQ_VWEP
#define ZQ_QC_STRINGS /* The strings-only subset of FRIK_FILE is supported. */
#ifdef CSQC
	float clientcommandframe;	/* This is the input-frame sequence. frames < clientcommandframe have been sent to the server. frame==clientcommandframe is still being generated and can still change. */
	float servercommandframe;	/* This is the input-frame that was last acknowledged by the server. Input frames greater than this should be applied to the player's entity. */
	.float entnum;	/* The entity number as its known on the server. */
	.float drawmask;	/* Acts as a filter in the addentities call. */
	.float() predraw;	/* Called by addentities after the filter and before the entity is actually drawn. Do your interpolation and animation in here. Should return one of the PREDRAW_* constants. */
	.float renderflags;
	vector input_cursor_screen;
	vector input_cursor_trace_start;
	vector input_cursor_trace_endpos;
	float input_cursor_trace_entnum;
	int trace_networkentity;	/* Repots which ssqc entnum was hit when a csqc traceline impacts an ssqc-based brush entity. */
	.float forceshader;	/* Contains a shader handle used to replace all surfaces upon the entity. */
	.float baseframe2;	/* See basebone */
	.float baseframe1time;	/* See basebone */
	.float baseframe2time;	/* See basebone */
	.float baselerpfrac;	/* See basebone */
	.float bonecontrol1;	/* Halflife model format bone controller. On player models, this typically affects the spine's yaw. */
	.float bonecontrol2;	/* Halflife model format bone controller. On player models, this typically affects the spine's yaw. */
	.float bonecontrol3;	/* Halflife model format bone controller. On player models, this typically affects the spine's yaw. */
	.float bonecontrol4;	/* Halflife model format bone controller. On player models, this typically affects the spine's yaw. */
	.float bonecontrol5;	/* Halflife model format bone controller. This typically affects the mouth. */
	.float subblendfrac;	/* Weird animation value specific to halflife models. On player models, this typically affects the spine's pitch, or yaw, or... */
	.float subblend2frac;	/* Weird animation value specific to halflife models. I've no idea what this does, probably nothing for most models. */
	.float basesubblendfrac;	/* See basebone */
	.float basesubblend2frac;	/* See basebone */
	void(float apilevel, string enginename, float engineversion) CSQC_Init;	/* Called at startup. enginename and engineversion are arbitary hints and can take any form. enginename should be consistant between revisions, but this cannot truely be relied upon. */
	void() CSQC_WorldLoaded;	/* Called after the server's model+sound precaches have been executed. Gives a chance for the qc to read the entity lump from the bsp (via getentitytoken). */
	void() CSQC_Shutdown;	/* Specifies that the csqc is going down. Save your persistant settings here. */
	void(float vwidth, float vheight, float notmenu) CSQC_UpdateView;	/* Called every single video frame. The CSQC is responsible for rendering the entire screen. */
	void(float vwidth, float vheight, float notmenu) CSQC_UpdateViewLoading;	/* Alternative to CSQC_UpdateView, called when the engine thinks there should be a loading screen. If present, will inhibit the engine's normal loading screen, deferring to qc to draw it. */
	void(vector viewsize, float scoresshown) CSQC_DrawHud;	/* Part of simple csqc, called after drawing the 3d view whenever CSQC_UpdateView is not defined. */
	void(vector viewsize, float scoresshown) CSQC_DrawScores;	/* Part of simple csqc, called after CSQC_DrawHud whenever CSQC_UpdateView is not defined, and when there are no menus/console active. */
	void(string msg) CSQC_Parse_StuffCmd;	/* Gives the CSQC a chance to intercept stuffcmds. Use the tokenize builtin to parse the message. Unrecognised commands would normally be localcmded, but its probably better to drop unrecognised stuffcmds completely. */
	float(string msg) CSQC_Parse_CenterPrint;	/* Gives the CSQC a chance to intercept centerprints. Return true if you wish the engine to otherwise ignore the centerprint. */
	float(float save, float take, vector inflictororg) CSQC_Parse_Damage;	/* Called as a result of player.dmg_save or player.dmg_take being set on the server. Return true to completely inhibit the engine's colour shift and damage rolls, allowing you to do your own thing.
	You can use punch_roll += (normalize(inflictororg-player.origin)*v_right)*(take+save)*autocvar_v_kickroll; as a modifier for the roll angle should the player be hit from the side, and slowly fade it away over time. */
	void(string printmsg, float printlvl) CSQC_Parse_Print;	/* Gives the CSQC a chance to intercept sprint/bprint builtin calls. CSQC should filter by the client's current msg setting and then pass the message on to the print command, or handle them itself. */
	void() CSQC_Parse_Event;	/* Called when the client receives an SVC_CGAMEPACKET. The csqc should read the data or call the error builtin if it does not recognise the message. */
	float(float evtype, float scanx, float chary, float devid) CSQC_InputEvent;	/* Called whenever a key is pressed, the mouse is moved, etc. evtype will be one of the IE_* constants. The other arguments vary depending on the evtype. Key presses are not guarenteed to have both scan and unichar values set at the same time. */
	__used void() CSQC_Input_Frame;	/* Called just before each time clientcommandframe is updated. You can edit the input_* globals in order to apply your own player inputs within csqc, which may allow you a convienient way to pass certain info to ssqc. */
	void(string rendererdescription) CSQC_RendererRestarted;	/* Called by the engine after the video was restarted. This serves to notify the CSQC that any render targets that it may have cached were purged, and will need to be regenerated. */
	float(string cmd) CSQC_ConsoleCommand;	/* Called if the user uses any console command registed via registercommand. */
	float(string text, string info) CSQC_ConsoleLink;	/* Called if the user clicks a ^[text\infokey\infovalue^] link. Use infoget to read/check each supported key. Return true if you wish the engine to not attempt to handle the link itself.WARNING: link text can potentially come from other players, so be careful about what you allow to be changed. */
	void(float entnum) CSQC_Ent_Spawn;	/* Clumsily defined function for compat with DP. Should call spawn, set that ent's entnum field, and return the entity inside the 'self' global which will then be used for fllowing Ent_Updates. MUST NOT PARSE ANY NETWORK DATA (which makes it kinda useless). */
	void(float isnew) CSQC_Ent_Update;	/* Parses the data sent by ssqc's various SendEntity functions (must use the exact same reads as the ssqc used writes - to debug this rule more easily, you may wish to use sv_csqcdebug). 'self' provides context between frames, and self.entnum should normally report which ssqc entity . Be aware that interpolation will need to happen separately. */
	void() CSQC_Ent_Remove;
	float(float entnum, float channel, string soundname, float vol, float attenuation, vector pos, float pitchmod, float flags) CSQC_Event_Sound;
	float() CSQC_Parse_TempEntity;	/* Please don't use this. Use CSQC_Parse_Event and multicasts instead. The use of serverside protocol translation to handle QW vs NQ protocols mean that you're likely to end up reading slightly different data. Which is bad. Return true to say that you fully handled the tempentity. Return false to have the client attempt to rewind the network stream and parse the message itself. */
	void(string cmdtext) GameCommand;
	float gamespeed;	/* Set by the engine, this is the value of the sv_gamespeed cvar */
	const float GE_MAXENTS = -1;	/* Valid for getentity, ignores the entity argument. Returns the maximum number of entities which may be valid, to avoid having to poll 65k when only 100 are used. */
	const float GE_ACTIVE = 0;	/* Valid for getentity. Returns whether this entity is known to the client or not. */
	const float GE_ORIGIN = 1;	/* Valid for getentity. Returns the interpolated .origin. */
	const float GE_FORWARD = 2;	/* Valid for getentity. Returns the interpolated forward vector. */
	const float GE_RIGHT = 3;	/* Valid for getentity. Returns the entity's right vector. */
	const float GE_UP = 4;	/* Valid for getentity. Returns the entity's up vector. */
	const float GE_SCALE = 5;	/* Valid for getentity. Returns the entity .scale. */
	const float GE_ORIGINANDVECTORS = 6;	/* Valid for getentity. Returns interpolated .origin, but also sets v_forward, v_right, and v_up accordingly. Use vectoangles(v_forward,v_up) to determine the angles. */
	const float GE_ALPHA = 7;	/* Valid for getentity. Returns the entity alpha. */
	const float GE_COLORMOD = 8;	/* Valid for getentity. Returns the colormod vector. */
	const float GE_PANTSCOLOR = 9;	/* Valid for getentity. Returns the entity's lower color (from .colormap), as a palette range value. */
	const float GE_SHIRTCOLOR = 10;	/* Valid for getentity. Returns the entity's lower color (from .colormap), as a palette range value. */
	const float GE_SKIN = 11;	/* Valid for getentity. Returns the entity's .skin index. */
	const float GE_MINS = 12;	/* Valid for getentity. Guesses the entity's .min vector. */
	const float GE_MAXS = 13;	/* Valid for getentity. Guesses the entity's .max vector. */
	const float GE_ABSMIN = 14;	/* Valid for getentity. Guesses the entity's .absmin vector. */
	const float GE_ABSMAX = 15;	/* Valid for getentity. Guesses the entity's .absmax vector. */
	const float GE_MODELINDEX = 200;	/* Valid for getentity. Guesses the entity's .modelindex float. */
	const float GE_MODELINDEX2 = 201;	/* Valid for getentity. Guesses the entity's .vw_index float. */
	const float GE_EFFECTS = 202;	/* Valid for getentity. Guesses the entity's .effects float. */
	const float GE_FRAME = 203;	/* Valid for getentity. Guesses the entity's .frame float. */
	const float GE_ANGLES = 204;	/* Valid for getentity. Guesses the entity's .angles vector. */
	const float GE_FATNESS = 205;	/* Valid for getentity. Guesses the entity's .fatness float. */
	const float GE_DRAWFLAGS = 206;	/* Valid for getentity. Guesses the entity's .drawflags float. */
	const float GE_ABSLIGHT = 207;	/* Valid for getentity. Guesses the entity's .abslight float. */
	const float GE_GLOWMOD = 208;	/* Valid for getentity. Guesses the entity's .glowmod vector. */
	const float GE_GLOWSIZE = 209;	/* Valid for getentity. Guesses the entity's .glowsize float. */
	const float GE_GLOWCOLOUR = 210;	/* Valid for getentity. Guesses the entity's .glowcolor float. */
	const float GE_RTSTYLE = 211;	/* Valid for getentity. Guesses the entity's .style float. */
	const float GE_RTPFLAGS = 212;	/* Valid for getentity. Guesses the entity's .pflags float. */
	const float GE_RTCOLOUR = 213;	/* Valid for getentity. Guesses the entity's .color vector. */
	const float GE_RTRADIUS = 214;	/* Valid for getentity. Guesses the entity's .light_lev float. */
	const float GE_TAGENTITY = 215;	/* Valid for getentity. Guesses the entity's .tag_entity float. */
	const float GE_TAGINDEX = 216;	/* Valid for getentity. Guesses the entity's .tag_index float. */
	const float GE_GRAVITYDIR = 217;	/* Valid for getentity. Guesses the entity's .gravitydir vector. */
	const float GE_TRAILEFFECTNUM = 218;	/* Valid for getentity. Guesses the entity's .traileffectnum float. */
	const string INFOKEY_P_TOPCOLOR_RGB = "topcolor_rgb";	/* The player's upper/shirt colour as an rgb value in a format usable with stov. */
	const string INFOKEY_P_BOTTOMCOLOR_RGB = "bottomcolor_rgb";	/* The player's lower/pants/trouser colour as an rgb value in a format usable with stov. */
	const string INFOKEY_P_MUTED = "ignored";	/* 0: we can see the result of the player's say/say_team commands.   1: we see no say/say_team messages from this player. Use the ignore command to toggle this value. */
	const string INFOKEY_P_VOIP_MUTED = "vignored";	/* 0: we can hear this player when they speak (assuming voip is generally enabled). 1: we ignore everything this player says. Use cl_voip_mute to change the values. */
	const string INFOKEY_P_ENTERTIME = "entertime";	/* Reads the timestamp at which the player entered the game, in terms of csqc's time global. */
	const string INFOKEY_P_FRAGS = "frags";	/* Reads a player's frag count. */
	const string INFOKEY_P_PACKETLOSS = "pl";	/* Reads a player's packetloss, as a percentage. */
	const string INFOKEY_P_VOIPSPEAKING = "voipspeaking";	/* Boolean value that says whether the given player is currently sending voice information. */
	const string INFOKEY_P_VOIPLOUDNESS = "voiploudness";	/* Only valid for the local player. Gives a value between 0 and 1 to indicate to the user how loud their mic is. */
	const string SERVERKEY_IP = "ip";	/* The address of the server we connected to. */
	const string SERVERKEY_SERVERNAME = "servername";	/* The hostname that was last passed to the connect command. */
	const string SERVERKEY_CONSTATE = "constate";	/* The current connection state. Will be set to one of: disconnected (menu-only mode), active (gamestate received and loaded), connecting(connecting, downloading, or precaching content, aka: loading screen). */
	const string SERVERKEY_TRANSFERRING = "transferring";	/* Set to the hostname of the server that we are attempting to connect or transfer to. */
	const string SERVERKEY_LOADSTATE = "loadstate";	/* loadstage, loading image name, current step, max steps
	Stages are: 1=connecting, 2=serverside, 3=clientside
	Key will be empty if we are not loading. */
	const string SERVERKEY_PAUSESTATE = "pausestate";	/* 1 if the server claimed to be paused. 0 otherwise */
	const string SERVERKEY_DLSTATE = "dlstate";	/* The progress of any current downloads. Empty string if no download is active, otherwise a tokenizable string containing this info:
	files-remaining, total-size, unknown-sizes-flag, file-localname, file-remotename, file-percent, file-rate, file-received-bytes, file-total-bytes
	If the current file info is omitted, then we are waiting for a download to start. */
	const string SERVERKEY_PROTOCOL = "protocol";	/* The protocol we are connected to the server with. */
	const string SERVERKEY_MAXPLAYERS = "maxplayers";	/* The number of player/spectator slots allocated on the server. */
	const float STAT_HEALTH = 0;	/* Player's health. */
	const float STAT_WEAPONMODELI = 2;	/* This is the modelindex of the current viewmodel (renamed from the original name 'STAT_WEAPON' due to confusions). */
	const float STAT_AMMO = 3;	/* player.currentammo */
	const float STAT_ARMOR = 4;
	const float STAT_WEAPONFRAME = 5;
	const float STAT_SHELLS = 6;
	const float STAT_NAILS = 7;
	const float STAT_ROCKETS = 8;
	const float STAT_CELLS = 9;
	const float STAT_ACTIVEWEAPON = 10;	/* player.weapon */
	const float STAT_TOTALSECRETS = 11;
	const float STAT_TOTALMONSTERS = 12;
	const float STAT_FOUNDSECRETS = 13;
	const float STAT_KILLEDMONSTERS = 14;
	const float STAT_ITEMS = 15;	/* self.items | (self.items2<<23). In order to decode this stat properly, you need to use getstatbits(STAT_ITEMS,0,23) to read self.items, and getstatbits(STAT_ITEMS,23,11) to read self.items2 or getstatbits(STAT_ITEMS,28,4) to read the visible part of serverflags, whichever is applicable. */
	const float STAT_VIEWHEIGHT = 16;	/* player.view_ofs_z */
	const float STAT_VIEW2 = 20;	/* This stat contains the number of the entity in the server's .view2 field. */
	const float STAT_VIEWZOOM = 21;	/* Scales fov and sensitiity. Part of DP_VIEWZOOM. */
	const float VF_DRAWWORLD = 19;	/* boolean. If set to 1, the engine will draw the world and static/persistant rtlights. If 0, the world will be skipped and everything will be fullbright. */
	const float VF_DRAWENGINESBAR = 20;	/* boolean. If set to 1, the sbar will be drawn, and viewsize will be honoured automatically. */
	const float VF_DRAWCROSSHAIR = 21;	/* boolean. If set to 1, the engine will draw its default crosshair. */
	const float VF_CL_VIEWANGLES = 33;
	const float VF_CL_VIEWANGLES_X = 34;
	const float VF_CL_VIEWANGLES_Y = 35;
	const float VF_CL_VIEWANGLES_Z = 36;
	#define VF_LPLAYER VF_ACTIVESEAT
	const float VF_ACTIVESEAT = 202;	/* The 'seat' number, used when running splitscreen. */
	const float VF_VIEWENTITY = 206;	/* Changes the RF_EXTERNALMODEL flag on entities to match the new selection, and removes entities flaged with RF_VIEWENTITY. Requires cunning use of .entnum and typically requires calling addentities(MASK_VIEWMODEL) too. */
#endif
#ifdef MENU
	void() m_init;
	void() m_shutdown;
	void(vector screensize) m_draw;	/* Provides the menuqc with a chance to draw. Will be called even if the menu does not have focus, so be sure to avoid that. COMPAT: screensize is not provided in DP. */
	void(vector screensize, float opaque) m_drawloading;	/* Additional drawing function to draw loading screens. If opaque is set, then this function must ensure that the entire screen is overdrawn (even if just by a black drawfill). */
	float(float evtype, float scanx, float chary, float devid) Menu_InputEvent;	/* If present, this is called instead of m_keydown and m_keyup
	Called whenever a key is pressed, the mouse is moved, etc. evtype will be one of the IE_* constants. The other arguments vary depending on the evtype. Key presses are not guarenteed to have both scan and unichar values set at the same time. */
	void(float scan, float chr) m_keydown;
	void(float scan, float chr) m_keyup;
	void(float wantmode) m_toggle;
	float(string cmd) m_consolecommand;
	float(string ext) checkextension = #1; /*Checks if the named extension is supported by the running engine. */
	void(string err,...) error = #2;
	void(string err,...) objerror = #3;
	void(string text,...) print = #4; /* Part of DP_SV_PRINT*/
	void(string text,...) bprint = #5;
	void(float clientnum, string text,...) msprint = #6;
	void(string text,...) cprint = #7;
	vector(vector) normalize = #8;
	float(vector) vlen = #9;
	float(vector) vectoyaw = #10;
	vector(vector) vectoangles = #11;
	float() random = #12;
	void(string,...) localcmd = #13;
	float(string name) cvar = #14;
	void(string name, string value) cvar_set = #15;
	void(string text) dprint = #16;
	string(float) ftos = #17;
	float(float) fabs = #18;
	string(vector) vtos = #19;
	string(entity) etos = #20; /* Part of DP_QC_ETOS*/
	float(string) stof = #21; /* Part of FRIK_FILE, FTE_QC_INFOKEY, FTE_STRINGS, QW_ENGINE, ZQ_QC_STRINGS*/
	entity() spawn = #22;
	void(entity) remove = #23;
	entity(entity start, .string field, string match) find = #24;
	entity(entity start, .__variant field, __variant match) findfloat = #25; /* Part of DP_QC_FINDFLOAT*/
	entity(.string field, string match) findchain = #26; /* Part of DP_QC_FINDCHAIN*/
	entity(.__variant field, __variant match) findchainfloat = #27; /* Part of DP_QC_FINDCHAINFLOAT*/
	string(string file) precache_file = #28;
	string(string sample) precache_sound = #29;
	void() coredump = #30;
	void() traceon = #31;
	void() traceoff = #32;
	void(entity) eprint = #33;
	float(float) rint = #34;
	float(float) floor = #35;
	float(float) ceil = #36;
	entity(entity) nextent = #37;
	float(float) sin = #38; /* Part of DP_QC_SINCOSSQRTPOW*/
	float(float) cos = #39; /* Part of DP_QC_SINCOSSQRTPOW*/
	float(float) sqrt = #40; /* Part of DP_QC_SINCOSSQRTPOW*/
	vector() randomvector = #41;
	float(string name, string value, float flags) registercvar = #42; /* Part of DP_REGISTERCVAR*/
	float(float,...) min = #43; /* Part of DP_QC_MINMAXBOUND*/
	float(float,...) max = #44; /* Part of DP_QC_MINMAXBOUND*/
	float(float min,float value,float max) bound = #45; /* Part of DP_QC_MINMAXBOUND*/
	float(float,float) pow = #46; /* Part of DP_QC_SINCOSSQRTPOW*/
	void(entity src, entity dst) copyentity = #47; /* Part of DP_QC_COPYENTITY*/
	// filestream(string filename, float mode) fopen = #48; /* Part of FRIK_FILE*/
	// void(filestream fhandle) fclose = #49; /* Part of FRIK_FILE*/
	// string(filestream fhandle) fgets = #50; /* Part of FRIK_FILE*/
	// void(filestream fhandle, string s) fputs = #51; /* Part of FRIK_FILE*/
	float(string) strlen = #52; /* Part of FRIK_FILE, FTE_STRINGS, ZQ_QC_STRINGS*/
	string(string, optional string, optional string, optional string, optional string, optional string, optional string, optional string) strcat = #53; /* Part of FRIK_FILE, FTE_STRINGS, ZQ_QC_STRINGS*/
	string(string s, float start, float length) substring = #54; /* Part of FRIK_FILE, FTE_STRINGS, ZQ_QC_STRINGS*/
	vector(string) stov = #55; /* Part of FRIK_FILE, FTE_STRINGS, ZQ_QC_STRINGS*/
	string(string) strzone = #56; /* Part of FRIK_FILE, FTE_STRINGS, ZQ_QC_STRINGS*/
	void(string) strunzone = #57; /* Part of FRIK_FILE, FTE_STRINGS, ZQ_QC_STRINGS*/
	float(string) tokenize = #58; /* Part of KRIMZON_SV_PARSECLIENTCOMMAND*/
	string(float) argv = #59; /* Part of KRIMZON_SV_PARSECLIENTCOMMAND*/
	float() isserver = #60;
	float() clientcount = #61;
	float() clientstate = #62;
	void(string map) changelevel = #64;
	void(string sample, optional float channel, optional float volume) localsound = #65;
	vector() getmousepos = #66;
	float(optional float timetype) gettime = #67;
	void(string data) loadfromdata = #68;
	void(string data) loadfromfile = #69;
	float(float val, float m) mod = #70;
	string(string name) cvar_string = #71; /* Part of DP_QC_CVAR_STRING*/
	void() crash = #72;
	void() stackdump = #73;
	float(entity) etof = #79;
	entity(float) ftoe = #80;
	float(string) validstring = #81;
	float(string str) altstr_count = #82;
	string(string str) altstr_prepare = #83;
	string(string str, float num) altstr_get = #84;
	string(string str, float num, string set)  altstr_set = #85;
	entity(entity start, .float field, float match) findflags = #87; /* Part of DP_QC_FINDFLAGS*/
	entity(.float field, float match) findchainflags = #88; /* Part of DP_QC_FINDCHAINFLAGS*/
	void(entity ent, string mname) setmodel = #90; /*Menuqc-specific version. */
	void(string mname) precache_model = #91; /*Menuqc-specific version. */
	void(entity ent, vector neworg) setorigin = #92; /*Menuqc-specific version. */
#endif
#if defined(CSQC) || defined(MENU)
	const float RESTYPE_PIC = 3;	/* precache_pic. Status results are an amalgomation of the textures used by the named shader. */
	const float RESTYPE_SKIN = 4;	/* setcustomskin */
	const float RESTYPE_TEXTURE = 5;	/* Individual textures within shaders. These are not directly usable, but may be named as part of a skin file, or a shader. */
	const float VF_MINDIST = 23;	/* The distance of the near clip plane from the view position. Should generally not be <=0, as this would introduce NANs. */
	const float VF_MAXDIST = 24;	/* The distance of the far clip plane from the view position. If 0, will be considered infinite. */
	const float VF_PERSPECTIVE = 200;	/* 1: regular rendering. Fov specifies the angle. 0: isometric-style. Fov specifies the number of Quake Units each side of the viewport, and mindist restrictions are removed, pvs culling should be disabled. */
	const float VF_MIN = 1;	/* The top-left of the 3d viewport in screenspace. The VF_ values are used via the setviewprop/getviewprop builtins. */
	const float VF_MIN_X = 2;
	const float VF_MIN_Y = 3;
	const float VF_SIZE = 4;	/* The width+height of the 3d viewport in screenspace. */
	const float VF_SIZE_X = 5;
	const float VF_SIZE_Y = 6;
	const float VF_VIEWPORT = 7;	/* vector+vector. Two argument shortcut for VF_MIN and VF_SIZE */
	const float VF_FOV = 8;	/* sets both fovx and fovy. consider using afov instead. */
	const float VF_FOVX = 9;	/* horizontal field of view. does not consider aspect at all. */
	const float VF_FOVY = 10;	/* vertical field of view. does not consider aspect at all. */
	const float VF_ORIGIN = 11;	/* The origin of the view. Not of the player. */
	const float VF_ORIGIN_X = 12;
	const float VF_ORIGIN_Y = 13;
	const float VF_ORIGIN_Z = 14;
	const float VF_ANGLES = 15;	/* The angles the view will be drawn at. Not the angle the client reports to the server. */
	const float VF_ANGLES_X = 16;
	const float VF_ANGLES_Y = 17;
	const float VF_ANGLES_Z = 18;
	const float VF_AFOV = 203;	/* Aproximate fov. Matches the 'fov' cvar. The engine handles the aspect ratio for you. */
	const float VF_SCREENVSIZE = 204;	/* Provides a reliable way to retrieve the current virtual screen size (even if the screen is automatically scaled to retain aspect). */
	const float VF_SCREENPSIZE = 205;	/* Provides a reliable way to retrieve the current physical screen size (cvars need vid_restart for them to take effect). */
	const float VF_RT_DESTCOLOUR = 212;	/* The texture name to write colour info into, this includes both 3d and 2d drawing.
	Additional arguments are: format (IMGFMT_*), sizexy.
	Written to by both 3d and 2d rendering.
	Note that any rendertarget textures may be destroyed on video mode changes or so. Shaders can name render targets by prefixing texture names with '$rt:', or $sourcecolour. */
	const float VF_RT_DESTCOLOUR1 = 213;	/* Like VF_RT_DESTCOLOUR, for multiple render targets. */
	const float VF_RT_DESTCOLOUR2 = 214;	/* Like VF_RT_DESTCOLOUR, for multiple render targets. */
	const float VF_RT_DESTCOLOUR3 = 215;	/* Like VF_RT_DESTCOLOUR, for multiple render targets. */
	const float VF_RT_SOURCECOLOUR = 209;	/* The texture name to use with shaders that specify a $sourcecolour map. */
	const float VF_RT_DEPTH = 210;	/* The texture name to use as a depth buffer. Also used for shaders that specify $sourcedepth. 1-based. Additional arguments are: format (IMGFMT_D*), sizexy. */
	const float VF_RT_RIPPLE = 211;	/* The texture name to use as a ripplemap (target for shaders with 'sort ripple'). Also used for shaders that specify $ripplemap. 1-based. Additional arguments are: format, sizexy. */
	const float VF_ENVMAP = 220;	/* The cubemap name to use as a fallback for $reflectcube, if a shader was unable to load one. Note that this doesn't automatically change shader permutations or anything. */
	const float VF_USERDATA = 221;	/* Pointer (and byte size) to an array of vec4s. This data is then globally visible to all glsl via the w_user uniform. */
	const float IMGFMT_R8G8B8A8 = 1;	/* Typical 32bit rgba pixel format. */
	const float IMGFMT_R16G16B16A16F = 2;	/* Half-Float pixel format. Requires gl3 support. */
	const float IMGFMT_R32G32B32A32F = 3;	/* Regular Float pixel format. Requires gl3 support. */
	const float IMGFMT_D16 = 4;	/* 16-bit depth pixel format. Must not be used with VF_RT_DESTCOLOUR*. */
	const float IMGFMT_D24 = 5;	/* 24-bit depth pixel format. Must not be used with VF_RT_DESTCOLOUR*. */
	const float IMGFMT_D32 = 6;	/* 32-bit depth pixel format. Must not be used with VF_RT_DESTCOLOUR*. */
	const float IMGFMT_R8 = 7;	/* Single channel red-only 8bit pixel format. */
	const float IMGFMT_R16F = 8;	/* Single channel red-only Half-Float pixel format. Requires gl3 support. */
	const float IMGFMT_R32F = 9;	/* Single channel red-only Float pixel format. Requires gl3 support. */
	const float IMGFMT_A2B10G10R10 = 10;	/* Packed 32-bit packed 10-bit colour pixel format. Requires gl3 support. */
	const float IMGFMT_R5G6B5 = 11;	/* Packed 16-bit colour pixel format. */
	const float IMGFMT_R4G4B4A4 = 12;	/* Packed 16-bit colour pixel format, with alpha */
	const float IMGFMT_R8G8 = 13;	/* 16-bit two-channel pixel format. */
	const float IMGFMT_R32G32B32F = 14;	/* A pixel format that matches QC's vector type. */
	const float RF_DEPTHHACK = 4;	/* Hacks the depth values such that the entity uses depth values as if it were closer to the screen. This is useful when combined with viewmodels to avoid weapons poking in to walls. */
	const float RF_ADDITIVE = 8;	/* Shaders from this entity will temporarily be hacked to use an additive blend mode instead of their normal blend mode. */
	const float IE_KEYDOWN = 0;	/* Specifies that a key was pressed. Second argument is the scan code. Third argument is the unicode (printable) char value. Fourth argument denotes which keyboard(or mouse, if its a mouse 'scan' key) the event came from. Note that some systems may completely separate scan codes and unicode values, with a 0 value for the unspecified argument. */
	const float IE_KEYUP = 1;	/* Specifies that a key was released. Arguments are the same as IE_KEYDOWN. On some systems, this may be fired instantly after IE_KEYDOWN was fired. */
	const float IE_MOUSEDELTA = 2;	/* Specifies that a mouse was moved (touch screens and tablets typically give IE_MOUSEABS events instead, use in_windowed_mouse 0 to test code to cope with either). Second argument is the X displacement, third argument is the Y displacement. Fourth argument is which mouse or touch event triggered the event. */
	const float IE_MOUSEABS = 3;	/* Specifies that a mouse cursor or touch event was moved to a specific location relative to the virtual screen space. Second argument is the new X position, third argument is the new Y position. Fourth argument is which mouse or touch event triggered the event. */
	const float IE_ACCELEROMETER = 4;
	const float IE_FOCUS = 5;	/* Specifies that input focus was given. parama says mouse focus, paramb says keyboard focus. If either are -1, then it is unchanged. */
	const float IE_JOYAXIS = 6;	/* Specifies that what value a joystick/controller axis currently specifies. x=axis, y=value. Will be called multiple times, once for each axis of each active controller. */
	const float IE_GYROSCOPE = 7;
	const float SLIST_HOSTCACHEVIEWCOUNT = 0;
	const float SLIST_HOSTCACHETOTALCOUNT = 1;
	const float SLIST_MASTERQUERYCOUNT = 2;
	const float SLIST_MASTERREPLYCOUNT = 3;
	const float SLIST_SERVERQUERYCOUNT = 4;
	const float SLIST_SERVERREPLYCOUNT = 5;
	const float SLIST_SORTFIELD = 6;
	const float SLIST_SORTDESCENDING = 7;
	const float SLIST_TEST_CONTAINS = 0;
	const float SLIST_TEST_NOTCONTAIN = 1;
	const float SLIST_TEST_LESSEQUAL = 2;
	const float SLIST_TEST_LESS = 3;
	const float SLIST_TEST_EQUAL = 4;
	const float SLIST_TEST_GREATER = 5;
	const float SLIST_TEST_GREATEREQUAL = 6;
	const float SLIST_TEST_NOTEQUAL = 7;
	const float SLIST_TEST_STARTSWITH = 8;
	const float SLIST_TEST_NOTSTARTSWITH = 9;
#endif



#ifdef CSQC
	string(float keynum) keynumtostring_menu = #609;
	float(string key) stringtokeynum_menu = #614;
	float(entity e, float channel, string newsample, float volume, float attenuation, float pitchpct, float flags, float timeoffset) soundupdate = #0:soundupdate; /* Changes the properties of the current sound being played on the given entity channel. newsample may be empty, and will be ignored in this case. timeoffset is relative to the current position (subtract the result of getsoundtime for absolute positions). Negative volume can be used to stop the sound. Return value is a fractional value based upon the number of audio devices that could be updated - test against TRUE rather than non-zero. */
	float(entity e, float channel) getsoundtime = #533; /* Returns the current playback time of the sample on the given entity's channel. Beware CHAN_AUTO (in csqc, channels are not limited by network protocol). */
	float(entity e, float channel) getchannellevel = #0:getchannellevel; /* */
#endif
#ifdef MENU
	void(float dest) setkeydest = #601;
	float() getkeydest = #602;
	string(float keynum) keynumtostring = #609; /*Converts a qscancode key number into a mostly-human-readable name, matching the bind command. */
	string(string command, optional float bindmap) findkeysforcommand = #610;
	float(string key) stringtokeynum = #614; /*Returns the qscancode of a key from its name. Names are identical to the bind command. ctrl/shift/alt modifiers are ignored. */
#endif
#if defined(CSQC) || defined(MENU)
	float(string sample) soundlength = #534; /*Provides a way to query the duration of a sound sample, allowing you to set up a timer to chain samples. */
	void(float trg) setmousetarget = #603;
	float() getmousetarget = #604;
	vector(float vidmode, optional float forfullscreen) getresolution = #608; /*Supposed to query the driver for supported video modes. FTE does not query drivers in this way, nor would it trust drivers anyway. */
	float(float type) gethostcachevalue = #611; /* Part of FTE_CSQC_SERVERBROWSER*/
	string(float type, float hostnr) gethostcachestring = #612; /* Part of FTE_CSQC_SERVERBROWSER*/
	void() resethostcachemasks = #615; /* Part of FTE_CSQC_SERVERBROWSER*/
	void(float mask, float fld, string str, float op) sethostcachemaskstring = #616; /* Part of FTE_CSQC_SERVERBROWSER*/
	void(float mask, float fld, float num, float op) sethostcachemasknumber = #617; /* Part of FTE_CSQC_SERVERBROWSER*/
	void() resorthostcache = #618; /* Part of FTE_CSQC_SERVERBROWSER*/
	void(float fld, float descending) sethostcachesort = #619; /* Part of FTE_CSQC_SERVERBROWSER*/
	void(optional float dopurge) refreshhostcache = #620; /* Part of FTE_CSQC_SERVERBROWSER*/
	float(float fld, float hostnr) gethostcachenumber = #621; /* Part of FTE_CSQC_SERVERBROWSER*/
	float(string key) gethostcacheindexforkey = #622; /* Part of FTE_CSQC_SERVERBROWSER*/
	void(string key) addwantedhostcachekey = #623; /* Part of FTE_CSQC_SERVERBROWSER*/
	string() getextresponse = #624; /* Part of FTE_CSQC_SERVERBROWSER*/
	float(float key, string bind, optional float bindmap, optional float modifier) setkeybind = #630;
	vector() getbindmaps = #631;
	float(vector bm) setbindmaps = #632;
	#define K_TAB	9
	#define K_ENTER	13
	#define K_ESCAPE	27
	#define K_SPACE	32
	#define K_BACKSPACE	127
	#define K_UPARROW	128
	#define K_DOWNARROW	129
	#define K_LEFTARROW	130
	#define K_RIGHTARROW	131
	#define K_LALT	132
	#define K_RALT	-245
	#define K_LCTRL	133
	#define K_RCTRL	-246
	#define K_LSHIFT	134
	#define K_RSHIFT	-247
	#define K_F1	135
	#define K_F2	136
	#define K_F3	137
	#define K_F4	138
	#define K_F5	139
	#define K_F6	140
	#define K_F7	141
	#define K_F8	142
	#define K_F9	143
	#define K_F10	144
	#define K_F11	145
	#define K_F12	146
	#define K_INS	147
	#define K_DEL	148
	#define K_PGDN	149
	#define K_PGUP	150
	#define K_HOME	151
	#define K_END	152
	#define K_KP_HOME	164
	#define K_KP_UPARROW	165
	#define K_KP_PGUP	166
	#define K_KP_LEFTARROW	161
	#define K_KP_5	162
	#define K_KP_RIGHTARROW	163
	#define K_KP_END	158
	#define K_KP_DOWNARROW	159
	#define K_KP_PGDN	160
	#define K_KP_ENTER	172
	#define K_KP_INS	157
	#define K_KP_DEL	167
	#define K_KP_SLASH	168
	#define K_KP_MINUS	170
	#define K_KP_PLUS	171
	#define K_KP_NUMLOCK	154
	#define K_KP_STAR	169
	#define K_KP_EQUALS	173
	#define K_MOUSE1	512
	#define K_MOUSE2	513
	#define K_MOUSE3	514
	#define K_MOUSE4	517
	#define K_MOUSE5	518
	#define K_MOUSE6	519
	#define K_MOUSE7	520
	#define K_MOUSE8	521
	#define K_MOUSE9	522
	#define K_MOUSE10	523
	#define K_MWHEELUP	515
	#define K_MWHEELDOWN	516
	#define K_LWIN	-239
	#define K_RWIN	-240
	#define K_APP	-241
	#define K_SEARCH	-242
	#define K_POWER	-130
	#define K_VOLUP	-243
	#define K_VOLDOWN	-244
	#define K_JOY1	768
	#define K_JOY2	769
	#define K_JOY3	770
	#define K_JOY4	771
	#define K_AUX1	784
	#define K_AUX2	785
	#define K_AUX3	786
	#define K_AUX4	787
	#define K_AUX5	788
	#define K_AUX6	789
	#define K_AUX7	790
	#define K_AUX8	791
	#define K_AUX9	792
	#define K_AUX10	793
	#define K_AUX11	794
	#define K_AUX12	795
	#define K_AUX13	796
	#define K_AUX14	797
	#define K_AUX15	798
	#define K_AUX16	799
	#define K_AUX17	800
	#define K_AUX18	801
	#define K_AUX19	802
	#define K_AUX20	803
	#define K_AUX21	804
	#define K_AUX22	805
	#define K_AUX23	806
	#define K_AUX24	807
	#define K_AUX25	808
	#define K_AUX26	809
	#define K_AUX27	810
	#define K_AUX28	811
	#define K_AUX29	812
	#define K_AUX30	813
	#define K_AUX31	814
	#define K_AUX32	815
	#define K_PAUSE	153
	#define K_PRINTSCREEN	174
	#define K_CAPSLOCK	155
	#define K_SCROLLLOCK	156
	#define K_SEMICOLON	59
	#define K_PLUS	43
	#define K_MINUS	45
	#define K_TILDE	126
	#define K_BACKQUOTE	96
	#define K_BACKSLASH	92
	#define K_GP_A	826
	#define K_GP_B	827
	#define K_GP_X	828
	#define K_GP_Y	829
	#define K_GP_LSHOULDER	824
	#define K_GP_RSHOULDER	825
	#define K_GP_LTRIGGER	830
	#define K_GP_RTRIGGER	831
	#define K_GP_BACK	821
	#define K_GP_START	820
	#define K_GP_LTHUMB	822
	#define K_GP_RTHUMB	823
	#define K_GP_DPAD_UP	816
	#define K_GP_DPAD_DOWN	817
	#define K_GP_DPAD_LEFT	818
	#define K_GP_DPAD_RIGHT	819
	#define K_GP_GUIDE	-202
	#define K_GP_UNKNOWN	-255
	#define K_GP_LTHUMB_UP	832
	#define K_GP_LTHUMB_DOWN	833
	#define K_GP_LTHUMB_LEFT	834
	#define K_GP_LTHUMB_RIGHT	835
	#define K_GP_RTHUMB_UP	836
	#define K_GP_RTHUMB_DOWN	837
	#define K_GP_RTHUMB_LEFT	838
	#define K_GP_RTHUMB_RIGHT	839
#endif