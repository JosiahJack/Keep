//=============================================================================
//       ___  ___  __            __   __  
// |__/ |__  |__  |__)     |\/| /  \ |  \
// |  \ |___ |___ |        |  | \__/ |__/                                                    
//
// Compiled by Qmaster
//
// Attributions: Arcane Dimensions (AD)
//
//
// Distribution / Copyright / Permissions 
//
// Please do not use any of these assets in ANY COMMERCIAL PROJECT.
// and remember to give credit if you use any of these assets. Please credit
// the appropriate authors of the various content used.  Refer to the credits
// folder.
//				  
// The QC files in this MOD are based on 1.06 source files by ID Software.
// These files are released under the terms of GNU General Public License v2 or
// later. You may use the source files as a base to build your own MODs as long
// as you release them under the same license and make the source available.
// Please also give proper credit. Check http://www.gnu.org for details.
//
// Quake is a registered trademark of id Software, Inc.
//
// All of these resources may be electronically distributed only at 
// NO CHARGE to the recipient.
//
// Stats:
// Entity count: 1
// Function count: 8
//
// Implements: Item Progression System
//
// Description:
// Allows for a set of different items to be picked up in sequence from any one
// of multiple item_progspawn's in different locations.  No matter which is
// picked up first, the order is preserved for which item is presnet and picked
// up.  Useful to ensure that the player always gets weapons in the same order.
//
// * All spawn markers have the same item to pickup
// * The list determines the order the players gets items
// * Can only work with ITEM class types (no monsters etc)
// * The entity state system does not work with this system
// * Can have multiple progression lists in the same map
// * Extensive error and info checking reported to console
// * Works very closely with item touch2 functions
//=============================================================================
 
float PROG_NOTELEFX = 32;	// No teleport FX at spawn marker
 
// QUAKED item_progspawn (1 .8 .2) (-16 -16 0) (16 16 56) x x x x x NOTELEFX x x NOT_EASY NOT_NORMAL NOT_HARD NOT_DM
// -------- KEYS --------
// targetname : Must exist and be the same for all markers in same list
// target  : Must point to the first item in the progresion list
// target2 : targets to fire when the spawn marker is used
// message : message to display when triggered
// -------- SPAWNFLAGS --------
// NOTELEFX    : No tele FX effect when changing item at spawn marker
// -------- NOTES --------
// Spawn location for progression list
void(entity targ) item_proglist_setup = { // [FUNCTION]
	if (!(targ.flags & FL_ITEM)) return;// Only works with items

	targ.touch = targ.think = SUB_Null;	// No more thinking/animation
	targ.nextthink = -1;				// Never fire think
	targ.effects = 0;					// reset effects
	targ.modelindex = 0;				// Make sure no model
	setmodel (targ, "");				// invisible
	setsize (targ, VEC_ORIGIN, VEC_ORIGIN);	// No size, no impact
	targ.movetype = MOVETYPE_NONE;		// Stationary
	targ.solid = SOLID_NOT;				// no world interaction
	targ.estate = ESTATE_OFF;			// Entity state off
	targ.takedamage = DAMAGE_NO;		// No pain/death triggers
	targ.velocity = targ.avelocity = '0 0 0';	// Frozen inplace
};

void() item_progspawn_animateskin = { // [FUNCTION]
	if (self.state == STATE_OFF) return; // Spawn marker turned off?
	if (self.item_skinanim == FALSE) return; // Skin animation disabled
	
	self.item_skinanim_no = self.item_skinanim_no + 1;
	if (self.item_skinanim_no > 3) self.item_skinanim_no = 0; // Increase animation skin number, check range
	self.skin = self.item_skinanim_no; // Update skin
	self.think = item_progspawn_animateskin; // Keep looping (slower than usual think timer)
	self.nextthink = time + 0.3;
};

void(entity targ) item_progspawn_off = { // [FUNCTION]
	targ.movetype = MOVETYPE_NONE;
	targ.solid = SOLID_NOT;
	setmodel (targ, "");
	setsize (targ, VEC_ORIGIN, VEC_ORIGIN);
	if (targ.attachment) { // Turn off any ammo lids
		setmodel(targ.attachment,"");
		setsize(targ.attachment, VEC_ORIGIN, VEC_ORIGIN);
	}
	targ.state = STATE_OFF; // Turn off spawn marker and skin animation
	targ.item_skinanim = FALSE;
	if (query_configflag(SVR_PARTICLES) && targ.part_emitter) misc_particle_off(targ.part_emitter); // Always switch particle emitter off
};

void(entity targ, entity spnlist) item_progspawn_on = { // [FUNCTION]
	targ.movetype = MOVETYPE_NONE;
	targ.solid = SOLID_TRIGGER;
	targ.skin = targ.frame = 0;
	setmodel (targ, spnlist.mdl);
	setsize (targ, spnlist.bbmins, spnlist.bbmaxs);
	setorigin (targ, targ.oldorigin);
	targ.velocity = '0 0 0';
	targ.angles = '0 0 0';
	targ.state = STATE_ON;
	targ.estate = ESTATE_ON;
	if (spnlist.bbmins_z < 0) targ.origin_z = targ.oldorigin_z - spnlist.bbmins_z; // Keys, Runes and Artifacts are setup -24 map units lower.  Shift the models back up by adding a double negative
	targ.part_active = spnlist.part_active; // Update particle emitter style
	targ.respawn_style = spnlist.respawn_style;
	targ.respawn_ofs = spnlist.respawn_ofs;
	targ.items = spnlist.items; // Some particle styles read item inventory
	targ.moditems = spnlist.moditems;
	
	// Are particles enabled? (quake.rc option)
	if (query_configflag(SVR_PARTICLES) == SVR_PARTICLES) {
		if (spnlist.spawnflags & ITEM_NOEFFECTS && targ.part_emitter) misc_particle_off(targ.part_emitter); // Is item particle effects blocked?
		else if (targ.part_active < 1 && targ.part_emitter) misc_particle_off(targ.part_emitter); // Is the particle style defined?
		else if (targ.part_active > 0) { // Can't do anything if no particle style
			if (!targ.part_emitter) targ.part_emitter = spawn_pemitter(targ, targ, targ.part_active, PARTICLE_START_ON); // Has the particle emitter been created?
			else {
				// Make sure the particle style is updated
				targ.part_emitter.part_style = targ.part_active;
				misc_particle_style(targ.part_emitter);
				misc_particle_on(targ.part_emitter);
			}
		}
	}
	
	// Setup special lid and frame poses for ammo boxes only
	if (spnlist.classgroup == CG_AMMOITEM) {
		if (spnlist.angles_y < 1) targ.angles_y = rint(random()*359); // Setup random rotation or fixed angle (defined on item)
		else targ.angles = spnlist.angles;
		
		// Setup extra frames for rockets/plasma
		if (spnlist.frame_override) {
			if (spnlist.frame_box == -1) targ.frame = rint(1 + random()*6); // frame options -1=random 0=nothing, 1-7=exact.  Always generate a new frame number for respawning items
			else if (spnlist.frame_box > 7) spnlist.frame_box = 1;

			if (spnlist.frame_box > 0) targ.frame = spnlist.frame_box;

			// Turn off any ammo lids
			if (targ.attachment) {
				setmodel(targ.attachment,"");
				setsize(targ.attachment, VEC_ORIGIN, VEC_ORIGIN);
			}
		} else if (spnlist.spawnflags & A_LID && spnlist.headmdl != "") { // Setup lid attachment
			if (!targ.attachment) {
				targ.attachment = spawn();
				targ.attachment.owner = targ;
			}

			// Setup LID attachment entity (match angles/origin)
			targ.attachment.solid = SOLID_NOT;
			targ.attachment.movetype = targ.movetype;
			setmodel(targ.attachment, spnlist.headmdl);
			setsize (targ.attachment, targ.mins, targ.maxs); // Give the lid the same bbox setup so it can move
			setorigin(targ.attachment, targ.origin + '0 0 1'); // Start lid off the ground and remove ground flag.  This will let the lid naturally settle on the surface
			targ.attachment.flags = targ.attachment.flags - (targ.attachment.flags & FL_ONGROUND);
			targ.attachment.angles = targ.angles; // Match angle and stored frame setup from ammo box
			if (spnlist.frame_box == 0) targ.attachment.frame = rint(1 + random()*6); // lid frame options 0=random, 1-7=exact.  Always generate a new lid position for respawning items
			else if (spnlist.frame_box > 7) spnlist.frame_box = 1;

			if (spnlist.frame_box > 0) targ.attachment.frame = spnlist.frame_box;
			
			// LID has different skins for shells and spikes
			if (targ.classtype == CT_AMMOSHELLS) targ.attachment.skin = targ.skin;
			else targ.attachment.skin = 2 + targ.skin;
		}
	}
	
	// Skin Exceptions and Animations
	if (spnlist.classgroup == CG_ARMOR) targ.skin = spnlist.skin;
	else if (spnlist.classgroup == CG_KEY) targ.skin = spnlist.skin;
	else if (spnlist.classtype == CT_AMMOITEMPACK) targ.skin = spnlist.exactskin;
	else if (spnlist.classgroup == CG_HEALTH && spnlist.item_skinanim) {
		targ.item_skinanim = spnlist.item_skinanim;
		targ.item_skinanim_no = 0;
		targ.think = item_progspawn_animateskin;
		targ.nextthink = time + 0.1;
	}
};

void() item_progspawn_touch = { // [FUNCTION]
	local entity oself;

	// SELF  = spawn marker (only works once)
	// OTHER = always player (lots of checks at beginning)
	// SELF.OWNER = List Controller
	// SELF.OWNER.STATE = off means its finished or broken
	// SELF.OWNER.TARGET = Targetname of NEXT item in list
	// SELF.OWNER.MOVETARGET = Entity of NEXT item
	// SELF.OWNER.TARGET2 = Targetname of all spawn marker(s)	

	if (self.touchedvoid) {entity_hide(self); return;} // Duplicate of item_touch functionality
	if ( !(other.flags & FL_CLIENT) ) return;
	if ( other.health < 1 ) return;
	if ( other.flags & FL_NOTARGET ) return;
	if (self.state == STATE_OFF) return; // Has been used ONCE already or disabled?
	if (self.owner.state == STATE_OFF) return; // Is the progression list controller active?

	// PICKUP CONDITIONS
	if (self.owner.movetarget.classgroup == CG_HEALTH) {
		if (health_pickupcondition(other, self.owner.movetarget)) return;		
	} else if (self.owner.movetarget.classgroup == CG_ARMOR) {
		if (armor_pickupcondition(other, self.owner.movetarget)) return;		
	} else if (self.owner.movetarget.classgroup == CG_KEY) {
		if (key_pickupcondition(other, self.owner.movetarget)) return;
	} else if (self.owner.movetarget.classgroup == CG_RUNE) {
		if (query_configflag(self.owner.movetarget.customkey)) return;
	}
	
	item_progspawn_off(self); // Spawn markers only work ONCE, switch it off
	if (self.target2 != "") trigger_strs(self.target2, other); // Fire any targets/messages on the spawn marker
	if (self.message != "") centerprint (other, self.message);
	
	// ITEM FUNCTIONALITY
	// Need to switch around self (item) otherwise the item touch functions won't work. The .other should still be a player
	if (self.owner.movetarget.touch2) {
		oself = self; self = self.owner.movetarget;
		self.touch2();
		self = oself;
	}

	// PROGRESSION LIST (All error checking done in controller setup)
	if (self.owner.movetarget.target == "") self.owner.state = STATE_OFF; // Reached the end of the list.
	else {
		self.goalentity = find(world, targetname, self.owner.movetarget.target); // Find next entity in progression list
		if (!self.goalentity) self.owner.state = STATE_OFF; // Entity not found. End of list condition.
		else self.owner.movetarget = self.goalentity;
	}

	// SPAWN MARKERS
	self.goalentity = find(world, targetname, self.owner.target2);
	while (self.goalentity) {
		if (self.owner.state == STATE_OFF) item_progspawn_off(self.goalentity); // End of list, reset all markers to off
		else if (self.goalentity.state == STATE_ON) { // List is active, check which spawn markers are active
			if (!(self.goalentity.spawnflags & PROG_NOTELEFX)) Tent_Point(TE_TELEPORT,self.goalentity.origin); // Show teleporter particle effect.
			item_progspawn_on(self.goalentity, self.owner.movetarget); // Switch marker to new item
		} else item_progspawn_off(self.goalentity); // default = Spawn marked off/disabled

		self.goalentity = find(self.goalentity, targetname, self.owner.target2); // Find next spawn marker in list
	}
};

void() item_proglist_controller_setup = { // [FUNCTION]
	local float error_ekey, error_flag, error_targ, error_spawn, exit_targ, respawn_spnflag, float_spnflag, coop_warning;
	
	self.waitmin = self.waitmin2 = 0; // Setup counters for total list items and spawn markers
	error_ekey = error_flag = error_targ = error_spawn = FALSE; // Setup all error conditions
	exit_targ = coop_warning = respawn_spnflag = float_spnflag = FALSE;

	// All these error checks are done on the controller so that they only happen once, otherwise all spawn markers would generate them to the console! (too much spam)
	// CHECK progression list for errors
	self.sighttarget = self.target;
	self.goalentity = find(world, targetname, self.sighttarget);
	dprint("\b[-- Progression List Info --]\b\n"); 
	dprint("--------------------------------------\n");
	dprint("No Ekey Item Targ Class\n");
	while (self.goalentity) {
		self.waitmin = self.waitmin + 1; // Increase counter and setup next target string
		self.sighttarget = self.goalentity.target;
		if (self.waitmin < 9) dprint("0"); // Zero pad list numbers (alignment reasons)
		dprint(ftos(self.waitmin));
		if (self.goalentity.progspawnlist) dprint(" Yes "); // All entities in list have to marked with new entity key
		else { dprint(" No  "); error_ekey = TRUE; }
		// All entities in list have to be ITEM class
		if (self.goalentity.flags & FL_ITEM) dprint(" Yes ");
		else { dprint(" No  "); error_flag = TRUE; }
		// Some entities don't work well with prog lists + coop
		if (self.goalentity.classgroup == CG_KEY) coop_warning = TRUE;
		// Don't need respawn or float spawnflags
		if (self.goalentity.spawnflags & ITEM_RESPAWN) respawn_spnflag = TRUE;
		if (self.goalentity.spawnflags & ITEM_FLOATING) float_spnflag = TRUE;
		
		// FATAL ERROR: Empty target strings when used with the FIND command will return player entity instead of world!
		if (self.goalentity.target != "") dprint(" Yes ");
		else { dprint(" END "); exit_targ = TRUE; }
		dprint(" "); dprint(self.goalentity.classname); // Finally show item class type (good for multiple lists)
		dprint("\n");
		
		if (exit_targ) self.goalentity = world; // Any FATAL exit conditions found yet?
		else {
			self.goalentity = find(world, targetname, self.sighttarget); // Find next entity in prog list
			if (self.waitmin == 1 && !self.goalentity) error_targ = TRUE; // Check for 2nd entity target being setup wrong
		}
		
	}
	dprint("--------------------------------------\n"); // Close table

	// CHECK spawn markers for errors
	self.goalentity = find(world, targetname, self.target2);
	while (self.goalentity) {
		self.waitmin2 = self.waitmin2 + 1; // Count spawn markers
		if (self.goalentity.classtype != CT_PROGSPAWN) error_spawn = TRUE; // All spawn markers need to be same entity type
		self.goalentity = find(self.goalentity, targetname, self.target2); // Find next spawn marker
	}
	
	// ERROR check if entity key is defined on all of list?
	if (error_ekey) {
		dprint("\b[PROG_LIST]\b missing progspawnlist key!\n");
		spawn_marker(self.movetarget.origin, SPNMARK_YELLOW);
		self.state = STATE_OFF;
	}
	// ERROR check if prog list contains wrong entity types?
	if (error_flag) {
		dprint("\b[PROG_LIST]\b wrong entity type!\n");
		spawn_marker(self.movetarget.origin, SPNMARK_YELLOW);
		self.state = STATE_OFF;
	}
	// ERROR check if progression list ONLY has 1 item
	if (self.waitmin == 1) {
		dprint("\b[PROG_LIST]\b Only 1 item in list!\n");
		spawn_marker(self.movetarget.origin, SPNMARK_YELLOW);
		self.state = STATE_OFF;
	}
	// ERROR check if 2nd item in list actually exists?
	if (self.waitmin == 1 && error_targ) {
		dprint("\b[PROG_LIST]\b 2nd list item missing!\n");
		spawn_marker(self.movetarget.origin, SPNMARK_YELLOW);
		self.state = STATE_OFF;
	}
	// WARNINGS if extra spawnflags are used on items
	if (respawn_spnflag) dprint("\b[PROG_LIST]\b RESPAWN spawnflag ignored!\n");
	
	// ERROR check if spawn markers contain wrong entity types?
	if (error_spawn) {
		dprint("\b[PROG_SPN]\b wrong entity type!\n");
		spawn_marker(self.movetarget.origin, SPNMARK_YELLOW);
		self.state = STATE_OFF;
	}
	// ERROR check if list & spawn totals match up?
	if (self.waitmin != self.waitmin2) {
		dprint("\b[TOTAL]\b List ("); dprint(ftos(self.waitmin));
		dprint(") Spn ("); dprint(ftos(self.waitmin2));
		dprint(") Dont match!\n");
		spawn_marker(self.movetarget.origin, SPNMARK_YELLOW);
		self.state = STATE_OFF;
	}

	// Any errors occured? - Close table
	if (self.state == STATE_OFF) dprint("--------------------------------------\n\n");
	else {
		// FINALLY Setup all spawn markers
		self.goalentity = find(world, targetname, self.target2);
		while (self.goalentity) {
			// Create touch functionality
			self.goalentity.touch = item_progspawn_touch;
			// Copy over first item in list to spawn marker
			item_progspawn_on(self.goalentity, self.movetarget);
			// Setup link back to controller
			self.goalentity.owner = self;
			// Find next spawn marker
			self.goalentity = find(self.goalentity, targetname, self.target2);
		}
		
		// Display progression list setup information
		dprint("\bTOTALS\b List ("); dprint(ftos(self.waitmin));
		dprint(") Spawns ("); dprint(ftos(self.waitmin2));
		dprint(")\n\n");
	}
};

// The first item in the progression list is unique, this would be the perfect location for the controller.  Has it been setup yet?
void() item_proglist_controller = { // [FUNCTION]
	if (self.movetarget.progspawncont) return;

	self.movetarget.progspawncont = spawn();
	self.movetarget.progspawncont.classtype = CT_CONTROL;
	self.movetarget.progspawncont.classgroup = CG_PROGRESSION;
	self.movetarget.progspawncont.solid = SOLID_NOT;
	self.movetarget.progspawncont.movetype = MOVETYPE_NONE;
	setorigin(self.movetarget.progspawncont, self.movetarget.origin+'0 0 32');
	setsize(self.movetarget.progspawncont, VEC_ORIGIN, VEC_ORIGIN);
	self.movetarget.progspawncont.owner = self.movetarget; // Always have a link to first item, as it can change
	self.movetarget.progspawncont.target = self.target; // targetname of first item in list.  Start of the progression list
	self.movetarget.progspawncont.movetarget = self.movetarget; // entity pointer to start of list
	self.movetarget.progspawncont.target2 = self.targetname; // spawn markers (never changes).  All Spawn marker(s) should be same name
	self.movetarget.progspawncont.state = STATE_ON; // Start controller in ON state (errors switch it off)
	self.movetarget.progspawncont.nextthink = time + 0.5; // Allow for all entities to spawn and link
	self.movetarget.progspawncont.think = item_proglist_controller_setup;
};

void() item_progspawn_setup = { // [FUNCTION]
	if (SUB_HideIfNoTargetname()) return; // Cannot use this spawn if targetname missing.
	if (SUB_HideIfNoTarget()) return; // Target has to point to first item in list!

	self.movetarget = find(world, targetname, self.target); // Find target entity (Does entity actually exist!)
	if (!self.movetarget) { dprint("\b[PROG_SPN]\b missing target entity!\n"); spawn_marker(self.origin, SPNMARK_YELLOW); entity_hide(self); return; }

	self.state = STATE_ON; // Spawn location ready for items
	item_proglist_controller(); // Setup and enable controller entity
};

void() item_progspawn = { // [ENTITY]
	self.classtype = CT_PROGSPAWN;
	self.classgroup = CG_PROGRESSION;
	self.solid = SOLID_NOT; // No world interaction or movement
	self.movetype = MOVETYPE_NONE;
	self.bbmins = self.bbmaxs = VEC_ORIGIN;
	setsize(self, self.bbmins, self.bbmaxs);
	self.oldorigin = self.origin;
	self.angles = '0 0 0'; // reset all values to zero (used later)
	self.skin = self.frame = 0;
	self.velocity = self.avelocity = '0 0 0';
	self.state = STATE_OFF;
	self.nextthink = time + 0.1 + (random()*0.4); // Allow time for everything to spawn
	self.think = item_progspawn_setup;	
};