void() vanilla_water_check;

/*======================================================================
 AI (monster) FUNCTIONALITY
 
 Visibility checks
 - float(entity targ) visible
 - float(entity targ, vector s_offset, vector t_offset, float nomonsters) visxray
 - float(entity targ, vector s_offset, vector targang, float nomonsters) visang
 - float(entity targ) visblocked
 - float (entity targ, vector s_ofset, vector t_ofset) visblocked_wide
 - float(entity targ) infront
 
 Distance checks
 - float(entity targ) range
 - float(entity targ, float flat2d) range_distance
 - float (entity source, entity targ) rangeattack_check
 
 Angle checks
 - float(entity source, entity targ, float offset, float reverse) targangle
 - float(entity source, entity targ) targzone
 
 Hunt & Target Enemies
 - void() HuntTarget
 - void() FoundTarget
 - void(float wakeupothers) FoundHuntTarget
 - float() FindTarget
 
 AI animation movement (used mostly in monsters QC file)
 - void(float dist) ai_forward
 - void(float dist) ai_back
 - void(float dist) ai_pain
 - void(float dist) ai_painforward
 - void() ai_turn
 - float() FacingIdeal
 - void() ai_face
 - void() ai_resetangles
 - void(float dist) ai_charge
 - void(float dist) ai_chargenoturn
 - void() ai_charge_side
 - void() ai_charge_front
 
 AI ATTACK states
 - void() ai_run_melee
 - void() ai_run_missile
 - void() ai_run_jump 
 - void(float dist) ai_run_slide
 - void(float dist) ai_run_sidestep
 - void(float dist) ai_run_backward
 
 AI interactions with Breakable System
 - float(entity source, entity targ, float ignorenoshoot) ai_foundbreakable
 - void(float brkdmg) ai_damagebreakable
 - void(float brkdmg) ai_jumpbreakable
 
 AI melee checks and damage
 - float(float attackdist) ai_checkmelee
 - void() ai_melee
 - void(float dmg_multiplier) ai_meleesmash
 - void() ai_melee_side

======================================================================*/

/*======================================================================
 check_liquidblock
 - Checks pointcontents of source+target because traceline parms
   are not 100% reliable for flagging water/air content
 - One function check for all the different visibility functions
 - Designed to work with the new liquidblock entity flag
======================================================================*/
float(vector org_source, vector org_targ) check_liquidblock = {
	local float pc_source, pc_targ;
	
	// Is r_wateralpha set or monsters forced to check liquid surfaces?
	if (liquid_alpha == 1 || self.liquidblock) {
		// Check point contents first
		pc_source = pointcontents(org_source);
		pc_targ = pointcontents(org_targ);
		if (pc_source != pc_targ) return TRUE; // Are point content different? (like water/air)
		
		if (trace_inopen && trace_inwater) return TRUE; // Standard traceline check (not 100% reliable)
	}
	return FALSE; 	// No liquid check required
};

/*======================================================================
 visible (target entity)
 Conditions added to water surface check
 - most maps are compiled with transparent water nowadays
======================================================================*/
float(entity targ) visible = {
	local vector spot1, spot2;
	
	spot1 = self.origin + self.view_ofs;
	spot2 = targ.origin + targ.view_ofs;
	traceline (spot1, spot2, TRUE, self);	// see through other monsters
	
	// Debug system (enabled via axe) uses funcs from subs_soc.qc
	// This will draw a diamond model where the AI is looking
	if (self.debuglvl) {
		if (!debugent1) debugent1 = spawn_devmarker(self.origin);
		spot1 = vectoangles(self.origin - trace_endpos);
		makevectors(spot1);
		spot2 = trace_endpos + (v_up * -16) + (v_forward * 50);
		setorigin(debugent1,'0 0 0');
		setorigin(debugent1, spot2);
	}

	// Check for liquid surface block condition
	if (check_liquidblock(spot1, spot2) == TRUE) return FALSE;

	if (trace_fraction == 1) return TRUE;
	return FALSE;
};

/*======================================================================
 visxray (variable options)
  Returns TRUE if there is no blocking, FALSE if something in the way
  Custom options for variable source/target offsets and monster blocking
  (nomonsters) TRUE = no block, FALSE = blocked
  self is excluded from any trace starting points
======================================================================*/
float(entity targ, vector s_offset, vector t_offset, float nomonsters) visxray = {
	local vector spot1, spot2;

	// Bmodels don't have proper origins
	if (self.bsporigin) spot1 = bmodel_origin(self) + s_offset;
	else spot1 = self.origin + s_offset;

	spot2 = targ.origin + t_offset;
	traceline (spot1, spot2, nomonsters, self);	// custom options
	
	// Check for liquid surface block condition
	if (check_liquidblock(spot1, spot2) == TRUE) return FALSE;

	// monster blocking changes which test to use
	if (nomonsters) {
		// Has the traceline gone from source>target without anything blocking?
		if (trace_fraction == 1) return TRUE;
		return FALSE;
	} else {
		// Is the entity hit by the traceline the targ destination?
		if (trace_ent == targ) return TRUE;
		return FALSE;
	}
};

/*======================================================================
 visang (works similar to visxray function)
  The enemy location is based on the source facing angles
  Returns TRUE if there is no blocking, FALSE if something in the way
  Custom options for variable source offsets and monster blocking
  (nomonsters) TRUE = no block, FALSE = blocked
  self is excluded from any trace starting points
======================================================================*/
float(entity targ, vector s_offset, vector targang, float nomonsters) visang = {
	local vector spot1, spot2;

	// Bmodels don't have proper origins
	if (self.bsporigin) spot1 = bmodel_origin(self) + s_offset;
	else spot1 = self.origin + s_offset;

	// Use supplied ang + v_forward for direction
	makevectors(targang);
	spot2 = spot1 + (v_forward * 4096);
	
	// Trace a line using angle vector instead of enemy origin
	traceline (spot1, spot2, nomonsters, self);
	
	// Check for liquid surface block condition
	if (check_liquidblock(spot1, spot2) == TRUE) return FALSE;

	// monster blocking changes which test to use
	if (nomonsters) {
		// Has the traceline gone from source>target without anything blocking?
		if (trace_fraction == 1) return TRUE;
		return FALSE;
	} else {
		// Is the entity hit by the traceline the targ destination?
		if (trace_ent == targ) return TRUE;
		return FALSE;
	}
};

/*======================================================================
 visblocked (target entity)
 check to see if sightline is blocked by other monsters
 Really only used in CheckAttack functions (was in org ID code)
======================================================================*/
float(entity targ) visblocked = {
	local vector spot1, spot2;
	
	spot1 = self.origin + self.view_ofs;
	spot2 = targ.origin + targ.view_ofs;
	traceline (spot1, spot2, FALSE, self);	// blocked by monsters

	// Check for liquid surface block condition
	if (check_liquidblock(spot1, spot2) == TRUE) return FALSE;

	// Original ID behaviour for this type of function
	// Traceline entity hit = enemy?
	if (trace_ent == targ) return FALSE;
	return TRUE;
};

/*======================================================================
 viswide (target entity)
  check to see if sightline is blocked by other monsters
  extra wide check using 3 traces, +/- 16 left/right and origin
  All three traces have to complete for a positive result
======================================================================*/
float (entity targ, vector s_ofset, vector t_ofset) visblocked_wide = {
	local vector spot1, spot2, spot3, tr_line;
	local float tr_leftmon, tr_rightmon, tr_result;

	tr_line = '0 0 0';
	tr_leftmon = tr_rightmon = 0;
	makevectors(self.angles);

	// Traceline 1 - MIDDLE
	spot1 = self.origin + s_ofset_x * v_forward + s_ofset_y * v_right + s_ofset_z * v_up;
	spot2 = targ.origin + t_ofset;
	traceline (spot1, spot2, FALSE, self);

	// Is trace entity the same as the target entity?
	if (trace_ent == targ) tr_line_x = 1;
	// Check for liquid surface block condition
	// Only need to do this once for the central traceline
	// If this fails then the left/right should as well
	if (check_liquidblock(spot1, spot2) == TRUE) tr_line_x = 0;

	// Traceline 2 - 32 units LEFT
	spot3 = spot1 - (v_right * 16);
	traceline (spot3, spot2, FALSE, self);
	// Work out if clear shot, hit world or another entity
	if (trace_ent == targ) tr_line_y = 1;
	else if (trace_ent != world) tr_leftmon = 1;

	if (self.debuglvl) {
		if (!debugent2) debugent2 = spawn_devmarker(self.origin);
		setorigin(debugent2, trace_endpos);
	}
		
	// Traceline 3 - 32 units RIGHT
	spot3 = spot1 + (v_right * 16);
	traceline (spot3, spot2, FALSE, self);
	// Work out if clear shot, hit world or another entity
	if (trace_ent == targ) tr_line_z = 1;
	else if (trace_ent != world) tr_rightmon = 1;

	if (self.debuglvl) {
		if (!debugent3) debugent3 = spawn_devmarker(self.origin);
		setorigin(debugent3, trace_endpos);
	}

	// Default = no clear shot (keep aim/moving)
	tr_result = TRUE;
	// SIMPLE 3 complete traces = nothing blocking visibility
	if (tr_line_x + tr_line_y + tr_line_z == 3) tr_result = FALSE;
	// Central trace is good but either side has hit something?
	else if (tr_line_x) {
		// Hit a monster on either side = always fail!
		if (tr_leftmon || tr_rightmon) tr_result = TRUE;
		// The crssbow bolt is fired from the LEFT side, only right can be clear
		else if (self.classtype == CT_MONDCROSS) {
			if (tr_line_y == 0 && tr_line_z == 1) tr_result = FALSE;
		}
		// Default - space available on either side
		else if (tr_line_y + tr_line_z == 1) tr_result = FALSE;
	}

	if (self.debuglvl) {
		dprint("Trace ("); dprint(ftos(tr_line_x));
		dprint(" "); dprint(ftos(tr_line_y));
		dprint(" "); dprint(ftos(tr_line_z));
		dprint(") Ent ("); dprint(ftos(tr_leftmon));
		dprint(" "); dprint(ftos(tr_rightmon));
		dprint(") = ("); dprint(ftos(tr_result));
		dprint(")\n");	
	}
	return tr_result;
};

/*======================================================================
 infront (target entity)
 - relies on self being set correctly before entering this function
 - returns 1 if the entity is in front (in sight) of self
======================================================================*/
float(entity targ) infront = {
	local vector vec;
	local float dot;
	
	makevectors (self.angles);	// sets v_forward, etc globals
	vec = normalize (targ.origin - self.origin);
	dot = vec * v_forward;
	
	if ( dot > 0.3) return TRUE;
	else return FALSE;
};

/*======================================================================
 range (target entity)
  returns the range catagorization of an entity reletive to self
  uses constants defined in defs.qc
======================================================================*/
float(entity targ) range = {
	local vector	spot1, spot2;
	local float		r;
		
	spot1 = self.origin + self.view_ofs;
	spot2 = targ.origin + targ.view_ofs;
	r = vlen (spot1 - spot2);
	
	if (r < MON_RANGE_MELEE) return RANGE_MELEE;		// <120 = MELEE
	else if (r < MON_RANGE_NEAR) {
		// PM:  Extend melee range for huge monsters like the dragon.
		if (r < (self.maxs_x + targ.maxs_x) * SQRT2 + 30) return RANGE_MELEE; // <120 = MELEE
		else return RANGE_NEAR;							// <500 = NEAR
	}
	else if (r < MON_RANGE_MID) return RANGE_MID;		// <1000 = MID
	return RANGE_FAR;									// >1000 = FAR
};

/*======================================================================
 range_distance (target entity)
 	returns the vector distance between two points
======================================================================*/
float(entity targ, float flat2d) range_distance = {
	local vector spot1, spot2;
	local float r;
		
	spot1 = self.origin + self.view_ofs;
	spot2 = targ.origin + targ.view_ofs;
	if (flat2d) { spot1_z = spot2_z = 0; }
	r = vlen (spot1 - spot2);
	
	return r;
};

/*======================================================================
 rangeattack_check
  check to see if (source) can get a clear shot at (targ)
  Ignores any water/air content checks
======================================================================*/
float (entity source, entity targ) rangeattack_check = {
	local vector spot1, spot2;
	local float r;

	// origin+offset, otherwise cannot see player up/down slopes
	spot1 = source.origin + source.view_ofs;
	spot2 = targ.origin + targ.view_ofs;
	r = vlen(spot1 - spot2);
	
	// Maximum range attack (was 600 taken from shambler, changed to 1000)
	if (r > MON_RANGE_MID) return FALSE;

	// Monsters without melee should always range anything really close
	if (!source.th_melee && r < MON_RANGE_MELEE) return TRUE;

	traceline (spot1, spot2, FALSE, source);	// trace hits monsters (infighting)
	if (trace_ent != targ) return FALSE;			// don't have a clear shot

	// Does the world define any water transparency
	if (liquid_alpha == 1 || source.liquidblock) {	
		// sight line crossed contents
		if (trace_inopen && trace_inwater) return FALSE;
	}

	return TRUE;
};

/*======================================================================
 targangle
  Returns what angle the target entity is relative to the source entity
  Useful for checking where the player is located.
  source, targ = entity origins to create vector angle
  reverse = the creation of the vector can be reversed
  offset = shift the final angle clockwise. (frontal sight cone 315-45)
======================================================================*/
float(entity source, entity targ, float offset, float reverse) targangle = {
	local float targ_dir, targ_ang;

	// Calculate vector angle between two points (source, target)
	if (reverse) targ_dir = vectoyaw(source.origin - targ.origin);
	else targ_dir = vectoyaw(targ.origin - source.origin);

	targ_ang = anglemod( (source.angles_y - targ_dir) + offset );
	return targ_ang;
};

// Modified version of targangle not using entities but supplied origins
// Targets Y angles needs to be supplied as no entity reference available
float(vector source, vector targ, float offset, float reverse, float dst_ang) viewangle = {
	local float targ_dir, targ_ang;

	// Calculate vector angle between two points (source, target)
	if (reverse) targ_dir = vectoyaw(source - targ);
	else targ_dir = vectoyaw(targ - source);

	targ_ang = anglemod( (dst_ang - targ_dir) + offset );
	return targ_ang;
};

/*======================================================================
 targzone (source entity, target entity)
 - Checks which zone the target enemy is located in relation to source (self)
  0 = Behind (315-45), 1 = Left (45-135), 2 = Front (135-225), Right = (225-315)
======================================================================*/
float(entity source, entity targ) targzone = {
	local float target_ang;
	
	// Work out angle the angle of the player based on the monster (source)
	// Add 45 degree offset to shift clockwise the frontal sight cone
	target_ang = targangle(source, targ, 45, TRUE);

	if (target_ang > 270) return TARGET_RIGHT;
	else if (target_ang > 180) return TARGET_FRONT;
	else if (target_ang > 90) return TARGET_LEFT;
	else return TARGET_BACK;
};


/*======================================================================
 HuntTarget
  Main routine - constantly running/turning towards the enemy
======================================================================*/
void() HuntTarget = {
	if (self.health < 1) return; // Dead monsters don't hunt!

	self.oldorigin = self.origin; // Save origin
	self.goalentity = self.enemy; // Focus on enemy
	self.ideal_yaw = vectoyaw(self.enemy.origin - self.origin);
	self.nextthink = time + 0.1; // Some monsters have special wakeup animations before attacking
	self.think = self.th_run; // Start running

	// Default 1s wait (NM adjusted) before attacking
	if (self.ryuflags & RYU_ALERT)
		SUB_AttackFinished (0.5);   // alert monsters don't wait as long...
	else
		if (!self.attack_instant) SUB_AttackFinished (1); // wait a while before first attack	
};

/*======================================================================
 FoundTarget
 - An enemy target has been found, wakeup and hunt target
 - Used by FindTarget once an enemy target has been found
 - used by T_Damage (combat.qc) for infighting
======================================================================*/
void() FoundTarget = {
	if (self.health < 1) return FALSE;	// Dead monsters don't hunt!

	// Check for Liquid surface block entity key if the monster has range attack, can NOW see through liquid surface
	if (self.liquidblock == TRUE && self.th_missile) self.liquidblock = FALSE;

	// If current enemy is alive and can take damage then wakeup the rest of the groupsight group using global entity
	if (self.sightgroup != "") {
		if (self.enemy.health > 0 && self.enemy.takedamage > DAMAGE_NO) {
			if (self.charmed) {
				if ((self.charmer == self.enemy) || (self.charmer == self.enemy.charmer)) {
					self.enemy = world;
					return;
				}
			}
			sightgroup_entity = self;		// Highlight target for others
			sightgroup_entity_time = time;	// reset wakeup timer
			if (self.enemy.flags & FL_CLIENT) monster_sightsound();
			HuntTarget ();					// Keep running after enemy
			return;
		}
	} else {
		//----------------------------------------------------------------------
		// DEFAULT wakeup method for all monsters
		//----------------------------------------------------------------------
		if ( (self.enemy.flags & FL_CLIENT) ) {
			if ( self.charmed ) {
				if ( ((self.charmer == self.enemy) || (self.charmer == self.enemy.charmer)) ) {
					self.enemy = world;
					return ;
				}
			}
			sight_entity = self;			// Highlight an angry monster for others
			sight_entity_time = time;		// reset wakeup timer
		} else {
			if (self.enemy.flags & FL_MONSTER) {
				if ( self.charmed ) {
					if ( (self.charmer == self.enemy.charmer) ) {
						self.enemy = world;
						return;
					}
				}
				sight_entity = self;		// Highlight an angry monster for others
				sight_entity_time = time;	// reset wakeup timer
			} // else, we don't stay angry at non monster or non player!
		}
	}
	
	//----------------------------------------------------------------------
	// This will cause a group of monsters to all attack the same target
	// Using the global sight enemy system which works with FindTarget()
	// Always check for an empty sighttarget first because the
	// the global sight entity could have an empty targetname
	//----------------------------------------------------------------------
	if (self.sighttarget != "") {
		if (self.enemy.targetname == self.sighttarget) {
			// Make sure the sight target is alive before chasing it
			self.oldenemy = find(world, targetname, self.sighttarget);
			if (self.oldenemy.health > 0) {
				if (self.oldenemy.takedamage > DAMAGE_NO) {
					if (self.charmed) {
						if ((self.charmer == self.enemy) || (self.charmer == self.enemy.charmer)) {
							self.enemy = world;
							return;
						}
					}
					sight_entity = self.enemy;		// Highlight target for others
					sight_entity_time = time;		// Reset wakeup timer
					monster_sightsound();			// Always make wakeup noise!
				}
			}
			self.oldenemy = world;
		}
	}
	
	self.show_hostile = time + 1;		// Wake up other monsters
	monster_sightsound();				// Make sight sound regardless of who hit us
	HuntTarget ();						// Keep running after enemy
};

/*======================================================================
 FoundHuntTarget
 - This is a combination of FoundTarget and HuntTarget
 - Does not do any sight sound, needs to be done outside this func
 - Does not pause or wait for any monster, straight to combat
 - Has no end funtion state, can decide this afterwards
======================================================================*/
void(float wakeupothers) FoundHuntTarget = {
	if (self.health < 1) return;	// Dead monsters don't hunt!
	if (!self.enemy) return;

	// Passive mode active and about to switch state?
	if (check_passivestate_switch(self)) return;

	// Check for Liquid surface block entity key
	// if the monster has range attack, can NOW see through liquid surface
	if (self.liquidblock == TRUE && self.th_missile) self.liquidblock = FALSE;

	if (self.enemy.flags & FL_CLIENT && wakeupothers == TRUE) {
		if (self.charmed) {
			if ((self.charmer == self.enemy) || (self.charmer == self.enemy.charmer)) {
				self.enemy = world;
				return;
			}
		}
		sight_entity = self;			// Highlight an angry monster for others
		sight_entity_time = time;		// reset wakeup timer
	}
	
	self.show_hostile = time + 1;		// wake up other monsters
	self.oldorigin = self.origin;		// Save origin
	self.goalentity = self.enemy;		// Focus on enemy
	self.ideal_yaw = vectoyaw(self.enemy.origin - self.origin);

	// Default 1s wait (NM adjusted) before attacking
	if (self.ryuflags & RYU_ALERT)
		SUB_AttackFinished (0.5);   // alert monsters don't wait as long...
	else
		if (!self.attack_instant) SUB_AttackFinished (1); // wait a while before first attack
};

/*======================================================================
 FindTarget
 - Main routine for finding a target
 - Returns TRUE if an enemy was sighted
======================================================================*/
float() FindTarget = {
	local entity client, playtarg, selected, head;
	local float r, dist;

	if (self.health < 1) return FALSE;	// Dead monsters don't hunt!
	if (intermission_running > 0) return FALSE; // If intermission is running, no sight checks
	if ((cinematic_running > 0 || cutscene > 0) && !coop) return FALSE; // If cinematic is running in singleplayer, no sight checks

	// Wraith AI - - - -
    if (self.movetype == MOVETYPE_NOCLIP) {  // Most monsters aren't wraiths.
        if (pointcontents (self.origin + self.view_ofs) == CONTENT_SOLID) return FALSE;   // Don't let wraiths see targets while in the wall.
	}

	self.enemyexit = FALSE; // Reset any combat exit conditions

	// Horn of Conjouring affected monsters only...these monsters are always friendly (to the player who summoned them) followers
	if ( self.charmed ) {
		self.effects = (self.effects | EF_DIMLIGHT);
		if ( (self.huntingcharmer > FALSE) ) {
			UpdateCharmerGoal ();
			r = vlen ((self.origin - self.goalentity.origin));
			if ( (r < MIN_CHARMER_DISTANCE) ) {
				if ( ((self.huntingcharmer == MOVETYPE_WALK) && (r > TOOCLOSE_CHARMER_DISTANCE)) ) return FALSE; // 

				StopHuntingCharmer ();
				return TRUE;
			}
		} else {
			if ( (vlen ((self.origin - self.charmer.origin)) > MAX_CHARMER_DISTANCE) ) {
				HuntCharmer ();
				return FALSE;
			} else {
 				if ( (vlen ((self.origin - self.charmer.origin)) < TOOCLOSE_CHARMER_DISTANCE) ) {
					FleeCharmer ();
					return FALSE;
				}
 			}
		}
	}

	//----------------------------------------------------------------------
	// SIGHT TARGET CHECK
	// Does the global sight entity match the enemy sight group?
	// Always check for an empty sighttarget first because the
	// the global sight entity could have an empty targetname
	//----------------------------------------------------------------------
	if (self.sighttarget != "") {
		if (sight_entity.targetname == self.sighttarget) {
			// Make sure the sight target is alive before chasing it
			if (sight_entity.health < 0) self.sighttarget = "";
			else {
				// If using enerytarget system, switch off tracking entity first
				if (self.enemy.classtype == CT_ENEMYTARGET) SUB_switchEnemyTarget();
				self.enemy = sight_entity;	// Switch to new enemy
				self.passive_state = MON_PASSIVESTATE_OFF;
				FoundTarget ();				// Run+turn towards new enemy
				return TRUE;
			}
		}
	}
	//----------------------------------------------------------------------
	// SIGHT GROUP CHECK
	// This is designed to co-ordination wakeup and attack as a group
	// Check the gobal entity has the same sightgroup string (trigger)
	// sightgroup + NO Ambush = ALL wake up when sight of combat/fire/player
	// sightgroup + Ambush = All wake up when sight of player
	// sightgroup + passive + No Ambush = All wake up sight of combat/fire
	// sightgroup + passive + Ambush = All wake up with direct damage ONLY
	//----------------------------------------------------------------------
	if (self.sightgroup != "") {
		// Let ambush still override wakeup (ambush=req direct damage)
		if (sightgroup_entity_time >= time - 0.1) {
			if (self.sightgroup == sightgroup_entity.sightgroup) {
				self.enemy = sightgroup_entity.enemy;	// Monster who wokeup
				self.passive_state = MON_PASSIVESTATE_OFF;
				FoundTarget ();							// Run+turn at new enemy
				return TRUE;
			}
		}
	}
	//----------------------------------------------------------------------
	// PASSIVE SYSTEM CHECK
	// passive_state + NO ambush = wake up when sight of combat/fire, unless cowardly or passive temperament
	// passive_state + Ambush = wake up from direct damage ONLY
	//----------------------------------------------------------------------
	if (check_passivestate_switch(self)) return FALSE;

	// if the first spawnflag bit is set, the monster will only wake up on
	// really seeing the player, not another monster getting angry
	// Zombies had their ambush/crucified spawnflag mix up fixed, fixed in mon_zombie.qc
	// sight_entity is assigned to self by a monster getting angry
	// sight_entity_time is also set at the same time
	if (sight_entity_time >= time - 0.1 && !(self.spawnflags & MON_AMBUSH) && !self.charmed ) {
		client = sight_entity;		// Global variable, angry monster nearby
		if (client.enemy == self.enemy) return TRUE; // we were already angry at this thing? get outta here
	} else {
		if ( self.charmed ) {
			selected = world;
			dist = CHARMED_RADIUS;
			head = findradius (self.origin,CHARMED_RADIUS);
			while (head) {
				if ( (!(head.flags & FL_NOTARGET) && (head.flags & FL_MONSTER)) ) {
					if ( ((visible (head) && (visible_distance < dist)) && (head.health > FALSE)) ) {
						if ( (((head != self) && (head != self.charmer)) && (head.charmer != self.charmer)) ) {
							selected = head;
							dist = visible_distance;
						}
					}
				}
				head = head.chain;
			}
			if ((selected == world)) return FALSE;
 			client = selected;
		} else {
			client = checkclient ();		// Find a client in current PVS
			if ( !client ) return ( FALSE );	// If no client found, return
		}
	}

	//----------------------------------------------------------------------
	// Checkclient is *supposed* to find ONLY players in the current PVS
	// but it seems the code does something slightly different
	// Checkclient will return other 'objects' (monsters) who are mad
	// at the player, which is suppose to be caught with sight_enemy
	// Find the player entity (client,.enemy,world) for specific checks
	//----------------------------------------------------------------------
	if (client.flags & FL_CLIENT) playtarg = client;
	else {
		if (client.enemy) playtarg = client;
		else playtarg = find(world,targetname,"player");
	}

	// If current enemy = client (player), already got *that* target
	if (client == self.enemy) return FALSE; // if we assigned to a nearby angry monster sight_entity above, we'd never be here if this if were true, FYI

	// Check for debug mode, menu system active
	if (playtarg.flags & FL_NOTARGET && !self.charmed) return FALSE;

	enemy_range = range (client);
	if (enemy_range == RANGE_FAR) return FALSE; // >1000 = FAR do nothing, too far away
		
	// Do not wake up unless the client (player/monster) is visible
	enemy_vis = visible(client);
	if (!enemy_vis) return FALSE;

	if (!self.charmed) {
		// (Distance >128 && < 500) Is client infront+side and hostile?
		// show_hostile flag is set when the player fires a weapon
		if (enemy_range == RANGE_NEAR) {
			if (client.show_hostile < time && !infront (client))
				return FALSE;
		} else if (enemy_range == RANGE_MID) {
				if (!infront (client)) return FALSE; // (Distance < 1000) Is client infront?
		}
	}

	// the only two things that alert monsters when invisible besides damage:
	// - firing a weapon
	// - bumping into a dog
	if (playtarg.items & IT_INVISIBILITY) {
		if (self.classtype == CT_MONDOG && client.flags & FL_CLIENT) {
			if (r != RANGE_MELEE) return FALSE;
		} else if (client.show_hostile < time) {
			return FALSE;
		}
	}

	// At this point if the enemy is <120 (melee range) the enemy
	// will always wake up and turn around towards the player

	// Finally got a target, check if its a player
	// This is an odd sitation because at this point client *should* be
	// the player/client and this code tries to fix the problem by
	// searching through enemy of enemy chains
	self.enemy = client;
	if (self.charmed) self.passive_state = FALSE;

	// Don't hurt other player charmed pets!
	if ( !(client.flags & FL_CLIENT) && !self.charmed && !self.enemy.charmed ) {
		// Is the enemy of the enemy a player?
		self.enemy = self.enemy.enemy;
		if ( !(client.enemy.flags & FL_CLIENT) ) {
			self.enemy = world;
			return FALSE;
		}
	}			
	FoundTarget ();			// Run+turn towards new enemy
	return TRUE;			// stop previous routine got a target
};

void() ai_face = {
	if (self.health < 1) return;// Unusual check, caught elsewhere
	self.ideal_yaw = vectoyaw(self.enemy.origin - self.origin);
	ChangeYaw (); 				// Done in code
};

void(float dist) ai_forward = {
	vanilla_water_check();
	walkmove (self.angles_y, dist);
};

// ai_forward + ai_face
void(float dist) ai_faceforward = {
	ai_face();
	ai_forward(dist);
};

void(float dist) ai_back = {
	vanilla_water_check();
	walkmove ( (self.angles_y+180), dist);
};

void(float dist) ai_backface = {
	ai_face();
	ai_back(dist);
};

// ai_pain (just uses ai_back, at some point a randomized backwards stagger vector was planned, but I'm not going to change expected behavior -Qmaster)
void(float dist) ai_pain ={ai_back (dist);};

void(float dist) ai_painforward = {
	vanilla_water_check();
	walkmove (self.angles_y, dist); // Not sure why Id used ideal_yaw when other functions use angles_y, commonized
};

// ai_turn (Very costly function, re-using FindTarget again)
void() ai_turn = {
	if (FindTarget()) return;
	ChangeYaw();			// Code function
};

float() FacingIdeal = {
	local float delta;
	
	delta = anglemod(self.angles_y - self.ideal_yaw);
	if (delta > 45 && delta < 315) return FALSE;
	else return TRUE;
};

void() ai_trackenemy = {
	if (visible(self.enemy)) {
		self.attack_track = self.enemy.origin;
		ai_face();
	}
};

void() ai_resetangles = {
	self.angles_x = self.angles_z = 0; // There is a chance when finished a monster jump that some of the angles (X/Z) values are wrong and need resetting.  Should only be used after jump functions
};

// ai_charge (generic), The monster is in a melee attack, so get as close as possible to .enemy
void(float dist) ai_charge = {
	vanilla_water_check();
	ai_face ();
	movetogoal (dist);
};

//----------------------------------------------------------------------
// ai_chargenoturn (generic)
//----------------------------------------------------------------------
void(float dist) ai_chargenoturn = {
	vanilla_water_check();
	movetogoal (dist);
};

//----------------------------------------------------------------------
// ai_charge_side (generic)
//----------------------------------------------------------------------
void() ai_charge_side = {
	local	vector	dtemp;
	local	float	heading;
	
	vanilla_water_check();

	// aim to the left of the enemy for a flyby
	self.ideal_yaw = vectoyaw(self.enemy.origin - self.origin);
	ChangeYaw ();

	makevectors (self.angles);
	dtemp = self.enemy.origin - (30 * v_right);
	heading = vectoyaw(dtemp - self.origin);
	
	walkmove(heading, 20);
};

//----------------------------------------------------------------------
// ai_charge_front (generic)
//----------------------------------------------------------------------
void() ai_charge_front = {
	local	float	heading;
	
	vanilla_water_check();
	ai_face();			// Turn towards enemy first

	makevectors (self.angles);
	heading = vectoyaw(self.enemy.origin - self.origin);
	
	walkmove(heading, 10);
};

/*======================================================================
 ai_run_melee
 - Turn and close until within an angle to launch a melee attack
======================================================================*/
void() ai_run_melee = {
	self.ideal_yaw = enemy_yaw;		// This is defined in ai_run
	ChangeYaw ();					// Code function

	//----------------------------------------------------------------------
	// Facing towards the ENEMY target? (ideal_yaw)
	//----------------------------------------------------------------------
	if (FacingIdeal()) {
		self.th_melee ();
		self.attack_state = AS_STRAIGHT;
	}
};

/*======================================================================
 ai_run_missile
 - Turn in place until within an angle to launch a missile attack
======================================================================*/
void() ai_run_missile = {
	self.ideal_yaw = enemy_yaw;		// This is defined in ai_run
	ChangeYaw ();					// Code function
	
	//----------------------------------------------------------------------
	// Facing towards the ENEMY target? (ideal_yaw)
	//----------------------------------------------------------------------
	if (FacingIdeal()) {
		self.th_missile ();
		self.attack_state = AS_STRAIGHT;
	}
};

/*======================================================================
 ai_run_jump
 - Turn in place until within an angle to jump attack
======================================================================*/
void() ai_run_jump = {
	self.ideal_yaw = enemy_yaw;		// This is defined in ai_run
	ChangeYaw ();					// Code function
	
	//----------------------------------------------------------------------
	// Facing towards the ENEMY target? (ideal_yaw)
	//----------------------------------------------------------------------
	if (FacingIdeal()) {
		self.th_jump ();
		self.attack_state = AS_STRAIGHT;
	}
};

/*======================================================================
 ai_run_slide
 - Strafe sideways, but stay at aproximately the same range
======================================================================*/
void(float dist) ai_run_slide = {
	local float	ofs;

	vanilla_water_check();

	// It is better to re-calcuate this than wait for ai_run to update
	self.ideal_yaw = vectoyaw(self.enemy.origin - self.origin);	
	// self.ideal_yaw = enemy_yaw;		// This is defined in ai_run
	ChangeYaw ();						// Code function
	if (self.lefty > 0) ofs = 90;
	else ofs = -90;
	
	// Tests if monsters can strafe or not by moving the monster
	if (walkmove (self.ideal_yaw + ofs, dist)) return;
	
	// Switch strafe sides for later use	
	self.lefty = rint(1 - self.lefty);
	if (walkmove (self.ideal_yaw - ofs, dist)) return;
	
	// Try moving backwards if both sides are blocked
	walkmove (self.ideal_yaw - 180, dist);
};

/*======================================================================
 ai_run_sidestep
 - Turn 90 degrees and move to the side
======================================================================*/
void(float dist) ai_run_sidestep = {
	local float	ofs;

	vanilla_water_check();

	if (self.attack_sidestep < time) {
		self.attack_sidestep = time + 4 + random()*4;
		self.lefty = rint(1 - self.lefty);
	}
	if (self.lefty > 0) ofs = 85;
	else ofs = -85;

	// Work out angle to face for enemy and then turn +/- 90 degrees
	// so that the monster is moving sideways to the enemy
	self.ideal_yaw = vectoyaw(self.enemy.origin - self.origin) + ofs;	
	ChangeYaw ();
	
	// Tests if monsters can move sideways
	if (walkmove (self.ideal_yaw, dist)) return;
	// Switch strafe sides for later use
	self.attack_sidestep = -1;
};

/*======================================================================
 ai_run_backwards
 - Turn 180 degrees and move backwards
======================================================================*/
void(float dist) ai_run_backward = {
	vanilla_water_check();

	// Work out angle to face for enemy and then turn +/- 90 degrees
	// so that the monster is moving sideways to the enemy
	self.ideal_yaw = vectoyaw(self.enemy.origin - self.origin) + 180;	
	ChangeYaw ();
	
	// Tests if monsters can move backwards
	if (walkmove (self.ideal_yaw, dist)) return;
	// Cannot walk backwards, move sideways instead
	self.attack_state = AS_SIDESTEP;
};

/*======================================================================
 ai_foundbreakable
  Check if the monster is allowed to break the breakable!?!
======================================================================*/
float(entity source, entity targ, float ignorenoshoot) ai_foundbreakable = {
	// Found a breakable in the way?
	if (targ.classtype == CT_FUNCBREAK || targ.classtype == CT_FUNCBREAKMDL) {
		// Check if a monster and nomonster damage/trigger allowed?
		if (source.flags & FL_MONSTER && targ.spawnflags & BREAK_NOMONSTER) return FALSE;
		// Ignoring noshoot spawnflag? (designed for jump/missile events)
		else if (ignorenoshoot == TRUE) return TRUE;
		// is breakable explosive damage only and attacker can use explosives?
		else if (targ.brktrigmissile && source.attack_explosive) return TRUE;
		// Can the breakable be damaged?
		else if (targ.spawnflags & BREAK_NOSHOOT) return FALSE;
		// Its a breakable that breaks!
		else return TRUE;
	}
	return FALSE;
};

/*======================================================================
 ai_tracebreakable
  Check if the monster (self) can see any breakables infront (target)
  Triple trace infront (self.angles) origin, +upward and +downward
======================================================================*/
float BRKTRACE_DIST = 128;
float BRKTRACE_ANG = 0.35;

float(float tracedist, float traceang) ai_tracebreakable = {
	local vector spot1, spot2;
	local float mon_height;
	
	// Take current facing angle of monster
	makevectors(self.angles);
	spot1 = self.origin;

	// Work out look up/down height for additional tracelines
	mon_height = (self.maxs_z - self.mins_z) * traceang;
	
	// Trace directly infront of entity using angles
	spot2 = spot1 + (v_forward * tracedist);
	traceline (spot1, spot2, FALSE, self);
	if (ai_foundbreakable(self, trace_ent, FALSE)) return TRUE;

	// Trace from origin and look UP!
	spot2 = spot1 + (v_forward * tracedist) + (v_up * mon_height);
	traceline (spot1, spot2, FALSE, self);
	if (ai_foundbreakable(self, trace_ent, FALSE)) return TRUE;

	// Trace from origin and look DOWN!
	spot2 = spot1 + (v_forward * tracedist) - (v_up * mon_height);
	traceline (spot1, spot2, FALSE, self);
	if (ai_foundbreakable(self, trace_ent, FALSE)) return TRUE;

	// No breakable found
	return FALSE;
};

/*======================================================================
 ai_immunebreakable
  Check if a breakable/pushable is immune to damage from monsters
======================================================================*/
float(entity source, entity targ) ai_immunebreakable = {
	// Found a breakable? (BSP or model)
	if (targ.classtype == CT_FUNCBREAK || targ.classtype == CT_FUNCBREAKMDL) {
		// Check no damage spawnflag?
		if (source.flags & FL_MONSTER && targ.spawnflags & BREAK_NOMONSTER)
			return TRUE;
	}
	// Found a pushable?
	else if (targ.classtype == CT_FUNCPUSHABLE) {
		// Check no damage spawnflag?
		if (source.flags & FL_MONSTER && targ.spawnflags & PUSH_NOMONSTER)
			return TRUE;
	}
	return FALSE;
};

/*======================================================================
 ai_damagebreakable
  If any breakables found, damage them to see if they will break
  Use the triple trace forward, upward and dowward to find breakables
======================================================================*/
void(float brkdmg) ai_damagebreakable = {
	local float ldmg;
	
	// Setup damage modifier
	ldmg = (random() + random() + random()) * brkdmg;

	// Triple trace directly infront of monster using angles
	if (ai_tracebreakable(BRKTRACE_DIST, BRKTRACE_ANG)) {
		// Check for any monster damage modifier on breakable
		if (self.flags & FL_MONSTER && trace_ent.brkmondmg > 0)
			ldmg = ldmg * trace_ent.brkmondmg;
		// Apply damage to breakable
		T_Damage (trace_ent, self, self, ldmg, DAMARMOR);
	}
};

/*======================================================================
 ai_jumpbreakable
  Check if the monster can trigger a breakable from jump attack
  Expecting SELF = monster and OTHER = breakable
======================================================================*/
void(float brkdmg) ai_jumpbreakable = {
	if (ai_foundbreakable(self, other, TRUE) && other.brktrigjump != 0) {
		// Found a breakable which is prone to jump damage
		trigger_ent(other, self);
	}
	else ai_damagebreakable(brkdmg);	// Damage any breakables
};

/*======================================================================
 CheckBlockedBreakable
  See if any breakables are in the way (running forward)
======================================================================*/
void() CheckBlockedBreakable = {
	local float brklen;

	// Still busy attacking? do nothing	
	if (time < self.attack_finished) return;

	// Double check a DEFAULT melee range exist, use knights
	if (self.th_melee && !self.meleerange)
		self.meleerange = MONAI_MELEEKNIGHT;

	// Triple trace directly infront of monster using angles
	if (ai_tracebreakable(BRKTRACE_DIST, BRKTRACE_ANG)) {
		if (ai_foundbreakable(self, trace_ent, FALSE)) {
			// Find out exactly how far away breakable bounding box is
			brklen = fabs(vlen(self.origin - trace_endpos));
			
			// Check breakable within melee/missile range?
			// Added extra check for explosive damage on breakbles (1.8)
			if (self.attack_explosive && trace_ent.brktrigmissile) {
				SUB_AttackFinished (1+random());
				self.attack_state = AS_MISSILE;
			}
			else if (brklen < self.meleerange && self.th_melee) {
				SUB_AttackFinished (1+random());
				self.attack_state = AS_MELEE;
			}
			else if (self.th_missile) {
				SUB_AttackFinished (1+random());
				self.attack_state = AS_MISSILE;
			}
		}
	}
};

/*======================================================================
 ai_checkmelee
  Check if the monster (self) can attack enemy (target)
  and returns TRUE if the monster is within XYZ range
======================================================================*/
float(float attackdist, float attackzaxis) ai_checkmelee = {
	local vector	spot1, spot2;
	local float 	delta, zdiff;

	// Setup default
	if (attackzaxis <= 0) attackzaxis = MONAI_MELEEZAXIS;
	
	// Calculate distance and z axis difference seperate
	spot1 = SUB_orgEnemyTarget();
	spot2 = self.origin;
	zdiff = fabs(spot1_z - spot2_z);
	spot1_z = spot2_z = 0;				// Flatten Z axis before vector length
	delta = vlen(spot1 - spot2);		// Calculate vector distance

	// Is the enemy too far away and the zaxis is wrong (too low/high)
	if (delta <= attackdist && zdiff <= MONAI_MELEEZAXIS) return TRUE;
	else return FALSE;
};

/*======================================================================
 ai_melee (generic)
 - slashing type of damage facing forward
   really assuming the monster is stationary while attacking
======================================================================*/
void() ai_melee = {
	local float ldmg;

	if (!self.enemy) return;			// removed before stroke
	ai_damagebreakable(10);				// Damage any breakables
	if (!ai_checkmelee(MONAI_MELEEFRONT,FALSE)) return;	// Too far away

	// Can the target bleed? - no blood/damage, quick exit
	// This candamage test not in origina id code (sync'd to melee_side)
	if (!CanDamage (self.enemy, self)) return;

	ldmg = (random() + random() + random()) * 3;
	T_Damage (self.enemy, self, self, ldmg, DAMARMOR);

	// Only spawn blood/gore/sound every second
	if (self.meleetimer < time) {
		self.meleetimer = time + 1;
		SpawnMeatSpray (self, self.enemy, random() * 100);
	}

	// Check for poisonous blades!
	if (self.poisonous) PoisonDeBuff(self.enemy);
	
	// Some melee weapons have swing and hit as separate sounds
	// This is trigger_once per melee combat swing
	if (self.meleecontact) {
		self.meleecontact = FALSE;
		if (self.meleehitsound != "") sound (self, CHAN_WEAPON, self.meleehitsound, 1, ATTN_NORM);
	}
};

/*======================================================================
 ai_meleesmash (generic)
 - large smashing damage overhead attack, usually a single strike
   really assuming the monster is stationary while attacking
======================================================================*/
void(float dmg_multiplier) ai_meleesmash = {
	local float ldmg;

	if (!self.enemy) return;						// removed before stroke
	ai_damagebreakable(3*dmg_multiplier);			// Damage any breakables
	// Is the enemy too far away, ++ extra Z height
	if (!ai_checkmelee(self.meleerange,MONAI_MELEEZTALL)) return;	// Too far away

	// Can the target bleed? - no blood/damage, quick exit
	// This candamage test not in origina id code (sync'd to melee_side)
	if (!CanDamage (self.enemy, self)) return;

	// This function is designed for monsters attacking players or infighting
	// If this is infighting do more damage as it will look more impressive
	// Also if this damage is enough to kill in a single blow, gib for effect
	if (self.enemy.flags & FL_MONSTER) dmg_multiplier = dmg_multiplier * 2;

	// 1-9 damage
	ldmg = (random() + random() + random()) * dmg_multiplier;
	if (ldmg < 1) ldmg = 1;
	if (self.enemy.health < ldmg) ldmg = ldmg*3;
	T_Damage (self.enemy, self, self, ldmg, DAMARMOR);

	// Lots of blood and gore
	SpawnMeatSpray (self, self.enemy, crandom() * 100);
	SpawnMeatSpray (self, self.enemy, crandom() * 100);
	
	// Check for poisonous blades!
	if (self.poisonous) PoisonDeBuff(self.enemy);

	// Some melee weapons have swing and hit as separate sounds
	// This is trigger_once per melee combat swing
	if (self.meleecontact) {
		self.meleecontact = FALSE;
		if (self.meleehitsound) sound (self, CHAN_WEAPON, self.meleehitsound, 1, ATTN_NORM);
	}
};

/*======================================================================
 ai_melee_side (generic)
 - move forward/side and attack (can cause animation sliding errors)
   this is really designed for glancing blows and monsters which are
   moving fast like they are charging at the player
======================================================================*/
void() ai_melee_side = {
	local float ldmg;

	if (!self.enemy) return;	// removed before stroke
	ai_damagebreakable(10);		// Damage any breakables
	ai_charge_side();					// move (20 units) to the side of enemy
	if (!ai_checkmelee(MONAI_MELEESIDE,FALSE)) return;	// Too far away

	// Can the target bleed? - no blood/damage, quick exit
	if (!CanDamage (self.enemy, self)) return;

	ldmg = (random() + random() + random()) * 3;
	T_Damage (self.enemy, self, self, ldmg, DAMARMOR);
	SpawnMeatSpray (self, self.enemy, random() * 50);

	// Check for poisonous blades!
	if (self.poisonous) PoisonDeBuff(self.enemy);

	// Some melee weapons have swing and hit as separate sounds
	// This is trigger_once per melee combat swing
	// No check if meleehitsound is defined or not
	if (self.meleecontact) {
		self.meleecontact = FALSE;
		sound (self, CHAN_WEAPON, self.meleehitsound, 1, ATTN_NORM);
	}
};

/*======================================================================
 ai_shockwave
 - produce a large ground slam/shockwave effect
 - Used by hammer ogres, golems and barons
======================================================================*/
void() ai_shockwave_think = {
	self.wait = rint((time - self.ltime)*10);
	if (self.wait > 6) {
		SUB_Remove();
	} else {
		self.frame = self.wait;
		if (self.wait > 4) {
			if (!self.delay) self.delay = time;
			self.alpha = 1-((time - self.delay)*5);
		}
		self.angles_y = anglemod(self.angles_y + rint(random()*20));
		self.nextthink = time + TIME_MINTICK;
	}
};

//----------------------------------------------------------------------
void(vector imp_vec, float imp_damage, float imp_radius, float imp_forward, float imp_up) ai_shockwave = {
	local entity swave, sjump;
	local vector impact, fvel;
	local float vdist, vpercent, vdamage, vpart, impzdiff;
	
	// Big impact, flash effect
	self.effects = self.effects | EF_MUZZLEFLASH;

	// Play impact sound and work out where the impact is going to happen
	sound (self, CHAN_WEAPON, self.meleehitsound, 1, ATTN_IDLE);
	makevectors (self.angles);
	// Replaced this crazy mess with function attack_vector
	//impact = self.origin + v_forward*imp_vec_x + v_right*imp_vec_y + v_up*imp_vec_z;
	impact = self.origin + attack_vector(imp_vec);

	// Push all entities within a certain radius outwards
	// Do this find search before spawning ring and particles
	// findradius will find ALL entities regardless of type
	sjump = findradius(impact, imp_radius);
	while(sjump) {
		// Ignore monster (self)
		if (sjump != self) {
			// Check for player + blast belt? - play active sound
			if (sjump.flags & FL_CLIENT && sjump.moditems & IT_ARTBLASTBELT)
				PlayBlastBeltSound(sjump);
			// Only affect players and other monsters AND breakables (BSP+model)
			else if (sjump.flags & FL_CLIENT || sjump.flags & FL_MONSTER || sjump.classgroup == CG_BREAKABLE) {
				// Exclude breakable/pushable immune to monster damage
				// This does not catch breakables excluded from player damage
				if (ai_immunebreakable(self, sjump)) {
					dprint("[SHOCKWAVE] Breakable (");
					dprint(ftos(sjump.classtype));
					dprint(") spnflg ("); dprint(ftos(sjump.spawnflags));
					dprint(") Immune\n");
				}
				// Exclude statues, stone/heavy monsters and bosses!
				else if (sjump.classgroup != CG_STONE && sjump.bossflag == FALSE) {
					// Is the entity on the ground or a breakable?
					// The test for breakables exceptions is done earlier
					// Breakable bmodel/model don't have onground flag set
					// The onground test is really to catch player/monsters
					if (sjump.flags & FL_ONGROUND || sjump.classgroup == CG_BREAKABLE) {
						// Is the entity too far above or below the impact?
						impzdiff = fabs(sjump.origin_z - impact_z);
						if (impzdiff < MONAI_IMPACTZAXIS) {
							// Distance between impact and enemy/entity
							vdist = vlen(sjump.origin - impact);
							// Percentage of impact force
							vpercent = 1 - (vdist / imp_radius);
							vdamage = rint(imp_damage * vpercent);
							// Impact damage radius is half for breakables
							// Otherwise whole rooms would be destroyed!
							if (sjump.classgroup == CG_BREAKABLE) {
								if (vdist > (imp_radius * 0.5)) vdamage = 0;
							}
							// Only apply impact damage to players (not monsters)
							// The damage was previously a meleerange with +/- 48 zaxis
							// Been changed to a radius damage as its radius impact!
							// Percentage (distance) of the impact damaged specified
							// This will STILL not apply if blast belt or jumping :P
							// Breakable's need source (self) for impact direction
							// to spawn breakable pieces away from impact location
							if (vdamage > 0) {
								if (sjump.classgroup == CG_BREAKABLE)
									T_Damage (sjump, self, self, imp_damage*vpercent, DAMARMOR);
								else
									T_Damage (sjump, world, world, imp_damage*vpercent, DAMARMOR);
							}
							
							// Monsters have less impact
							if (sjump.flags & FL_MONSTER) vpercent = vpercent * 0.75;
							// Attacker facing angle
							makevectors(self.angles);									
							// Combine forward/up force with existing velocity
							fvel = (v_forward * (imp_forward * vpercent)) + (v_up * (imp_up * vpercent));
							sjump.velocity = sjump.velocity + fvel;
							sjump.flags = sjump.flags - (sjump.flags & FL_ONGROUND);
						}
					}
				}
			}
		}
		sjump = sjump.chain;
	}

	// Spawn impact model ring on the ground
	swave = spawn();
	swave.mdl = MODEL_PROJ_RINGSHOCK;	
	setmodel(swave,swave.mdl);
	setsize(swave, VEC_ORIGIN, VEC_ORIGIN);
	setorigin(swave, impact);		// on floor, slight up (2 pixels)
	swave.solid = SOLID_NOT;		// No interaction with world
	swave.movetype = MOVETYPE_NONE;	// Static item, no movement
	swave.think = ai_shockwave_think;
	swave.nextthink = time + TIME_MINTICK;	// High time loop
	swave.ltime = swave.nextthink;
	
	// Spawn particle explosion where impact is located
	vpart = 64 + rint(random()*64);
	particle_explode(impact, vpart, 0.5, PARTICLE_BURST_FIRE, PARTICLE_BURST_SHOCKWAVE); 
};

// From Drake
// This is 'walkmove' without the vertical movement.
float(float yaw, float dist) flat_move = {
    local   entity  swap;

	vanilla_water_check();
    swap = self.enemy;
    self.enemy = world;     // This prevents 'self' from going up/down.
    dist = walkmove (yaw, dist);    // After this, dist = TRUE or FALSE.
    self.enemy = swap;
    return dist;
};

// From Drake
// This is 'movetogoal' without the vertical movement.
void(float dist) flat_goal = {
    local   entity  swap;

	vanilla_water_check();
    swap = self.enemy;
    self.enemy = world;     // This prevents 'self' from going up/down.
    movetogoal (dist);
    self.enemy = swap;
};