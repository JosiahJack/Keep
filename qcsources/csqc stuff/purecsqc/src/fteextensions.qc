/*
This file was automatically generated by FTE QuakeWorld v1.03
This file can be regenerated by issuing the following command:
pr_dumpplatform 
Available options:
-Ffte       - target only FTE (optimations and additional extensions)
-Tnq        - dump specifically NQ fields
-Tqw        - dump specifically QW fields
-Tcs        - dump specifically CSQC fields
-Tmenu      - dump specifically menuqc fields
-Fdefines   - generate #defines instead of constants
-Faccessors - use accessors instead of basic types via defines
-O          - write to a different qc file
*/
#pragma noref 1
#pragma warning error Q101 /*too many parms*/
#pragma warning error Q105 /*too few parms*/
#pragma warning error Q208 /*system crc unknown*/
#pragma warning enable F301 /*non-utf-8 strings*/
#pragma warning enable F302 /*uninitialised locals*/
#if !defined(CSQC) && !defined(NQSSQC) && !defined(QWSSQC)&& !defined(MENU)
#ifdef QUAKEWORLD
#define QWSSQC
#else
#define NQSSQC
#endif
#endif
#if !defined(SSQC) && (defined(QWSSQC) || defined(NQSSQC))
#define SSQC
#endif
#define strbuf float
#define searchhandle float
#define hashtable float
#define infostring string
#define filestream float
entity self;	/* The magic me */
#if defined(CSQC) || defined(SSQC)
entity other;	/* Valid in touch functions, this is the entity that we touched. */
entity world;	/* The null entity. Hurrah. Readonly after map spawn time. */
float time;	/* The current game time. Stops when paused. */
#endif
#ifdef CSQC
float cltime;	/* A local timer that ticks relative to local time regardless of latency, packetloss, or pause. */
#endif
#if defined(CSQC) || defined(SSQC)
float frametime;	/* The time since the last physics/render/input frame. */
#endif
#ifdef CSQC
float player_localentnum;	/* This is entity number the player is seeing from/spectating, or the player themself, can change mid-map. */
float player_localnum;	/* The 0-based player index, valid for getplayerkeyvalue calls. */
float maxclients;	/* Maximum number of player slots on the server. */
float clientcommandframe;	/* This is the input-frame sequence. frames < clientcommandframe have been sent to the server. frame==clientcommandframe is still being generated and can still change. */
float servercommandframe;	/* This is the input-frame that was last acknowledged by the server. Input frames greater than this should be applied to the player's entity. */
#endif
#if defined(QWSSQC)
entity newmis;	/* A named entity that should be run soon, to reduce the effects of latency. */
#endif
#ifdef SSQC
float force_retouch;	/* If positive, causes all entities to check for triggers. */
#endif
#if defined(CSQC) || defined(SSQC)
string mapname;	/* The short name of the map. */
#endif
#if defined(NQSSQC)
float deathmatch;
float coop;
float teamplay;
#endif
#ifdef SSQC
float serverflags;
float total_secrets;
float total_monsters;
float found_secrets;
float killed_monsters;
float parm1, parm2, parm3, parm4, parm5, parm6, parm7, parm8, parm9, parm10, parm11, parm12, parm13, parm14, parm15, parm16;
#endif
#ifdef CSQC
float intermission;
#endif
#if defined(CSQC) || defined(SSQC)
vector v_forward, v_up, v_right;
#endif
#ifdef CSQC
vector view_angles;
#endif
#if defined(CSQC) || defined(SSQC)
float trace_allsolid, trace_startsolid, trace_fraction;
vector trace_endpos, trace_plane_normal;
float trace_plane_dist;
entity trace_ent;
float trace_inopen;
float trace_inwater;
#endif
#ifdef CSQC
float input_timelength;
vector input_angles;
vector input_movevalues;
float input_buttons;
float input_impulse;
#endif
#ifdef SSQC
entity msg_entity;
void() main;
void() StartFrame;
void() PlayerPreThink;
void() PlayerPostThink;
void() ClientKill;
void() ClientConnect;
void() PutClientInServer;
void() ClientDisconnect;
void() SetNewParms;
void() SetChangeParms;
#endif
void end_sys_globals;
#if defined(CSQC) || defined(SSQC)
.float modelindex;
.vector absmin;
.vector absmax;
#endif
#ifdef SSQC
.float ltime;
#endif
#ifdef CSQC
.float entnum;	/* The entity number as its known on the server. */
.float drawmask;	/* Acts as a filter in the addentities call. */
.float() predraw;	/* Called by addentities after the filter and before the entity is actually drawn. Do your interpolation and animation in here. Should return one of the PREDRAW_* constants. */
#endif
#if defined(QWSSQC)
.float lastruntime;
#endif
#if defined(CSQC) || defined(SSQC)
.float movetype;
.float solid;
.vector origin;
.vector oldorigin;
.vector velocity;
.vector angles;
.vector avelocity;
#endif
#ifdef CSQC
.float pmove_flags;
#endif
#if defined(NQSSQC)
.vector punchangle;
#endif
#if defined(CSQC) || defined(SSQC)
.string classname;
#endif
#ifdef CSQC
.float renderflags;
#endif
#if defined(CSQC) || defined(SSQC)
.string model;
.float frame;
#endif
#ifdef CSQC
.float frame1time;	/* The absolute time into the animation/framegroup specified by .frame. */
.float frame2;
.float frame2time;	/* The absolute time into the animation/framegroup specified by .frame2. */
.float lerpfrac;	/* If 0, use frame1 only. If 1, use frame2 only. Mix them together for values between. */
#endif
#if defined(CSQC) || defined(SSQC)
.float skin;
.float effects;
.vector mins;
.vector maxs;
.vector size;
.void() touch;
#endif
#ifdef SSQC
.void() use;
#endif
#if defined(CSQC) || defined(SSQC)
.void() think;
.void() blocked;
.float nextthink;
#endif
#ifdef SSQC
.entity groundentity;
.float health;
.float frags;
.float weapon;
.string weaponmodel;
.float weaponframe;
.float currentammo;
.float ammo_shells;
.float ammo_nails;
.float ammo_rockets;
.float ammo_cells;
.float items;
.float takedamage;
#endif
#if defined(CSQC) || defined(SSQC)
.entity chain;
#endif
#ifdef SSQC
.float deadflag;
.vector view_ofs;
.float button0;
.float button1;
.float button2;
.float impulse;
.float fixangle;
.vector v_angle;
#endif
#if defined(NQSSQC)
.float idealpitch;
#endif
#ifdef SSQC
.string netname;
#endif
#if defined(CSQC) || defined(SSQC)
.entity enemy;
.float flags;
.float colormap;
#endif
#ifdef SSQC
.float team;
.float max_health;
.float teleport_time;
.float armortype;
.float armorvalue;
.float waterlevel;
.float watertype;
.float ideal_yaw;
.float yaw_speed;
.entity aiment;
.entity goalentity;
.float spawnflags;
.string target;
.string targetname;
.float dmg_take;
.float dmg_save;
.entity dmg_inflictor;
#endif
#if defined(CSQC) || defined(SSQC)
.entity owner;
#endif
#ifdef SSQC
.vector movedir;
.string message;
.float sounds;
.string noise;
.string noise1;
.string noise2;
.string noise3;
#endif
void end_sys_fields;
#ifdef MENU
float time;	/* The current local time. Increases while paused. */
#endif
#ifdef SSQC
float input_timelength;
vector input_angles;
vector input_movevalues;
float input_buttons;
float input_impulse;
#endif
#if defined(NQSSQC)
.float lastruntime;	/* This field used to be used to avoid running an entity multiple times in a single frame due to quakeworld's out-of-order thinks. It is no longer used by FTE due to precision issues, but may still be updated for compatibility reasons. */
#endif
#if defined(CSQC) || defined(QWSSQC)
.vector punchangle;
#endif
#if defined(CSQC) || defined(SSQC)
.float gravity;
.float hull;	/* Overrides the hull used by the entity for walkmove/movetogoal and not traceline/tracebox. */
.entity movechain;	/* This is a linked list of entities which will be moved whenever this entity moves, logically they are attached to this entity. */
.void() chainmoved;	/* Called when the entity is moved as a result of being part of another entity's .movechain */
.void(float old, float new) contentstransition;	/* This function is called when the entity moves between water and air. If specified, default splash sounds will be disabled allowing you to provide your own. */
.float dimension_solid;	/* This is the bitmask of dimensions which the entity is solid within. */
.float dimension_hit;	/* This is the bitmask of dimensions which the entity will be blocked by. If other.dimension_solid & self.dimension_hit, our traces will impact and not proceed. If its false, the traces will NOT impact, allowing self to pass straight through. */
.float hitcontentsmask;
.float scale;	/* Multiplier that resizes the entity. 1 is normal sized, 2 is double sized. scale 0 is remapped to 1. In SSQC, this is limited to 1/16th precision, with a maximum just shy of 16. */
.float fatness;	/* How many QuakeUnits to push the entity's verticies along their normals by. */
.float alpha;	/* The transparency of the entity. 1 means opaque, 0.0001 means virtually invisible. 0 is remapped to 1, for compatibility. */
.float modelflags;	/* Used to override the flags set in the entity's model. Should be set according to the MF_ constants. Use effects|=EF_NOMODELFLAGS to ignore the model's flags completely. The traileffectnum field is more versatile. */
.void() customphysics;	/* Called once each physics frame, overriding the entity's .movetype field and associated logic. You'll probably want to use tracebox to move it through the world. Be sure to call .think as appropriate. */
.entity tag_entity;
.float tag_index;
.float skeletonindex;	/* This object serves as a container for the skeletal bone states used to override the animation data. */
.vector colormod;
.vector glowmod;
.vector gravitydir;	/* Specifies the direction in which gravity acts. Must be normalised. '0 0 0' also means down. Use '0 0 1' if you want the player to be able to run on ceilings. */
.vector(vector org, vector ang) camera_transform;	/* Provides portal transform information for portal surfaces attached to this entity. Also used to open up pvs in ssqc. */
#endif
#ifdef SSQC
.float pmove_flags;
#endif
#if defined(CSQC) || defined(SSQC)
.float geomtype;
.float friction;
.float erp;
.float jointtype;
.float mass;
.float bouncefactor;
.float bouncestop;
#endif
#if defined(CSQC) || defined(QWSSQC)
.float idealpitch;
#endif
#if defined(CSQC) || defined(SSQC)
.float pitch_speed;
#endif
#ifdef SSQC
.float maxspeed;
.float items2;
.entity view2;
.vector movement;	/* These are the directions that the player is currently trying to move in (ie: which +forward/+moveright/+moveup etc buttons they have held), expressed relative to that player's angles. Order is forward, right, up. */
.float vw_index;
.entity nodrawtoclient;	/* This entity will not be sent to the player named by this field. They will be invisible and not emit dlights/particles. Does not work in MVD-recorded game. */
.entity drawonlytoclient;	/* This entity will be sent *only* to the player named by this field. To other players they will be invisible and not emit dlights/particles. Does not work in MVD-recorded game. */
.entity viewmodelforclient;	/* This entity will be sent only to the player named by this field, and this entity will be attached to the player's view as an additional weapon model. */
.entity exteriormodeltoclient;	/* This entity will be invisible to the player named by this field, except in mirrors or mirror-like surfaces, where it will be visible as normal. It may still cast shadows as normal, and generate lights+particles, depending on client settings. Does not affect how other players see the entity. */
.float button3;	/* DP_INPUTBUTTONS (note in qw, we set 1 to equal 3, to match zquake/fuhquake/mvdsv) */
.float button4;
.float button5;
.float button6;
.float button7;
.float button8;
.float viewzoom;
.float glow_size;
.float glow_color;
.float glow_trail;
.float traileffectnum;	/* This should be set to the result of particleeffectnum, in order to attach a custom trail effect to an entity as it moves. */
.vector color;	/* This affects the colour of realtime lights that were enabled via the pflags field. */
.float light_lev;	/* This is the radius of an entity's light. This is not normally used by the engine, but is used for realtime lights (ones that are enabled with the pflags field). */
.float style;	/* Used by the light util to decide how an entity's light should animate. On an entity with pflags set, this also affects realtime lights. */
.float pflags;	/* Realtime lighting flags */
.float clientcolors;
.float dimension_see;	/* This is the dimension mask (bitfield) that the client is allowed to see. Entities and events not in this dimension mask will be invisible. */
.float dimension_seen;	/* This is the dimension mask (bitfield) that the client is visible within. Clients that cannot see this dimension mask will not see this entity. */
.float dimension_ghost;	/* If this entity is visible only within these dimensions, it will become transparent, as if a ghost. */
.float dimension_ghost_alpha;	/* If this entity is subject to dimension_ghost, this is the scaler for its alpha value. If 0, 0.5 will be used instead. */
.float playerclass;
.float drawflags;	/* Various flags that affect lighting values and scaling. Typically set to 96 in quake for proper compatibility with DP_QC_SCALE. */
.float hasted;
.float light_level;	/* Used by hexen2 to indicate the light level where the player is standing. */
.float abslight;	/* Allows overriding light levels. Use drawflags to state that this field should actually be used. */
.float(entity playerent, float changedflags) SendEntity;	/* Called by the engine whenever an entity needs to be (re)sent to a client's csprogs, either because SendFlags was set or because data was lost. Must write its data to the MSG_ENTITY buffer. Will be called at the engine's leasure. */
.float SendFlags;	/* Indicates that something in the entity has been changed, and that it needs to be updated to all players that can see it. The engine will clear it at some point, with the cleared bits appearing in the 'changedflags' argument of the SendEntity method. */
.float Version;	/* Obsolete, set a SendFlags bit instead. */
.float pvsflags;	/* Reconfigures when the entity is visible to clients */
.float uniquespawnid;	/* Incremented by 1 whenever the entity is respawned. Persists across remove calls, for when the two-second grace period is insufficient. */
.float() customizeentityforclient;	/* Called just before an entity is sent to a client (non-csqc protocol). This gives you a chance to tailor 'self' according to what 'other' should see. */
#endif
#ifdef CSQC
.float forceshader;	/* Contains a shader handle used to replace all surfaces upon the entity. */
.float baseframe;	/* See basebone */
.float baseframe2;	/* See basebone */
.float baseframe1time;	/* See basebone */
.float baseframe2time;	/* See basebone */
.float baselerpfrac;	/* See basebone */
.float basebone;	/* The base* frame animations are equivelent to their non-base versions, except that they only affect bone numbers below the 'basebone' value. This means that the base* animation can affect the legs of a skeletal model independantly of the normal animation fields affecting the torso area. For more complex animation than this, use skeletal objects. */
.float bonecontrol1;	/* Halflife model format bone controller. On player models, this typically affects the spine's yaw. */
.float bonecontrol2;	/* Halflife model format bone controller. On player models, this typically affects the spine's yaw. */
.float bonecontrol3;	/* Halflife model format bone controller. On player models, this typically affects the spine's yaw. */
.float bonecontrol4;	/* Halflife model format bone controller. On player models, this typically affects the spine's yaw. */
.float bonecontrol5;	/* Halflife model format bone controller. This typically affects the mouth. */
.float subblendfrac;	/* Weird animation value specific to halflife models. On player models, this typically affects the spine's pitch. */
.float basesubblendfrac;	/* See basebone */
#endif
noref void(float reqid, float responsecode, string resourcebody) URI_Get_Callback;	/* Called as an eventual result of the uri_get builtin. */
#ifdef SSQC
noref void() SpectatorConnect;	/* Called when a spectator joins the game. */
noref void() SpectatorDisconnect;	/* Called when a spectator disconnects from the game. */
noref void() SpectatorThink;	/* Called each frame for each spectator. */
noref void(string cmd) SV_ParseClientCommand;	/* Provides QC with a way to intercept 'cmd foo' commands from the client. Very handy. Self will be set to the sending client, while the 'cmd' argument can be tokenize()d and each element retrieved via argv(argno). Unrecognised cmds MUST be passed on to the clientcommand builtin. */
noref void(string dest, string from, string cmd, string info) SV_ParseClusterEvent;	/* Part of cluster mode. Handles cross-node events that were sent via clusterevent, on behalf of the named client. */
noref float(string sender, string body) SV_ParseConnectionlessPacket;	/* Provides QC with a way to communicate between servers, or with client server browsers. Sender is the sender's ip. Body is the body of the message. You'll need to add your own password/etc support as required. Self is not valid. */
noref void(float pauseduration) SV_PausedTic;	/* For each frame that the server is paused, this function will be called to give the gamecode a chance to unpause the server again. the pauseduration argument says how long the server has been paused for (the time global is frozen and will not increment while paused). Self is not valid. */
noref float(float newstatus) SV_ShouldPause;	/* Called to give the qc a change to block pause/unpause requests. Return false for the pause request to be ignored. newstatus is 1 if the user is trying to pause the game. For the duration of the call, self will be set to the player who tried to pause, or to world if it was triggered by a server-side event. */
noref void() SV_RunClientCommand;	/* Called each time a player movement packet was received from a client. Self is set to the player entity which should be updated, while the input_* globals specify the various properties stored within the input packet. The contents of this function should be somewaht identical to the equivelent function in CSQC, or prediction misses will occur. If you're feeling lazy, you can simply call 'runstandardplayerphysics' after modifying the inputs. */
noref void() SV_AddDebugPolygons;	/* Called each video frame. This is the only place where ssqc is allowed to call the R_BeginPolygon/R_PolygonVertex/R_EndPolygon builtins. This is exclusively for debugging, and will break in anything but single player as it will not be called if the engine is not running both a client and a server. */
noref void() SV_PlayerPhysics;	/* Legacy method to tweak player input that does not reliably work with prediction (prediction WILL break). Mods that care about prediction should use SV_RunClientCommand instead. If pr_no_playerphysics is set to 1, this function will never be called, which will either fix prediction or completely break player movement depending on whether the feature was even useful. */
noref void() EndFrame;	/* Called after non-player entities have been run at the end of the physics frame. Player physics is performed out of order and can/will still occur between EndFrame and BeginFrame. */
noref string(string addr, string uinfo, string features)  SV_CheckRejectConnection;	/* Called to give the mod a chance to ignore connection requests based upon client protocol support or other properties. Use infoget to read the uinfo and features arguments. */
#endif
#ifdef CSQC
noref void(float apilevel, string enginename, float engineversion) CSQC_Init;	/* Called at startup. enginename and engineversion are arbitary hints and can take any form. enginename should be consistant between revisions, but this cannot truely be relied upon. */
noref void() CSQC_WorldLoaded;	/* Called after model+sound precaches have been executed. Gives a chance for the qc to read the entity lump from the bsp. */
noref void() CSQC_Shutdown;	/* Specifies that the csqc is going down. Save your persistant settings here. */
noref void(float vwidth, float vheight, float notmenu) CSQC_UpdateView;	/* Called every single video frame. The CSQC is responsible for rendering the entire screen. */
noref void(string msg) CSQC_Parse_StuffCmd;	/* Gives the CSQC a chance to intercept stuffcmds. Use the tokenize builtin to parse the message. Unrecognised commands would normally be localcmded, but its probably better to drop unrecognised stuffcmds completely. */
noref float(string msg) CSQC_Parse_CenterPrint;	/* Gives the CSQC a chance to intercept centerprints. Return true if you wish the engine to otherwise ignore the centerprint. */
noref void(string printmsg, float printlvl) CSQC_Parse_Print;	/* Gives the CSQC a chance to intercept sprint/bprint builtin calls. CSQC should filter by the client's current msg setting and then pass the message on to the print command, or handle them itself. */
noref void() CSQC_Parse_Event;	/* Called when the client receives an SVC_CGAMEPACKET. The csqc should read the data or call the error builtin if it does not recognise the message. */
noref float(float evtype, float scanx, float chary, float devid) CSQC_InputEvent;	/* Called whenever a key is pressed, the mouse is moved, etc. evtype will be one of the IE_* constants. The other arguments vary depending on the evtype. Key presses are not guarenteed to have both scan and unichar values set at the same time. */
noref void() CSQC_Input_Frame;	/* Called just before each time clientcommandframe is updated. You can edit the input_* globals in order to apply your own player inputs within csqc, which may allow you a convienient way to pass certain info to ssqc. */
noref float(string cmd) CSQC_ConsoleCommand;	/* Called if the user uses any console command registed via registercommand. */
noref float(string text, string info) CSQC_ConsoleLink;	/* Called if the user clicks a ^[text\infokey\infovalue^] link. Use infoget to read/check each supported key. Return true if you wish the engine to not attempt to handle the link itself. */
noref void(float isnew) CSQC_Ent_Update;
noref void() CSQC_Ent_Remove;
noref float(float entnum, float channel, string soundname, float vol, float attenuation, vector pos, float pitchmod) CSQC_Event_Sound;
noref float(string resname, string restype) CSQC_LoadResource;	/* Called each time some resource is being loaded. CSQC can invoke various draw calls to provide a loading screen, until WorldLoaded is called. */
noref float() CSQC_Parse_TempEntity;	/* Please don't use this. Use CSQC_Parse_Event and multicasts instead. */
#endif
#if defined(CSQC) || defined(MENU)
noref void(string cmdtext) GameCommand;
#endif
#ifdef MENU
void() m_init;
void() m_shutdown;
void() m_draw;
void(float scan, float chr) m_keydown;
void(float scan, float chr) m_keyup;
void(float mode) m_toggle;
#endif
#if defined(CSQC) || defined(SSQC)
var float physics_mode = 2;	/* 0: original csqc - physics are not run
1: DP-compat. Thinks occur, but not true movetypes.
2: movetypes occur just as they do in ssqc. */
#endif
#ifdef CSQC
float gamespeed;	/* Set by the engine, this is the value of the sv_gamespeed cvar */
float numclientseats;	/* This is the number of splitscreen clients currently running on this client. */
#endif
#if defined(CSQC) || defined(MENU)
var vector drawfontscale = '1 1 0';	/* Specifies a scaler for all text rendering. There are other ways to implement this. */
float drawfont;	/* Allows you to choose exactly which font is to be used to draw text. Fonts can be registered/allocated with the loadfont builtin. */
const float FONT_DEFAULT = 0;
#endif
const float TRUE = 1;
const float FALSE = 0;	/* File not found... */
const float M_PI = 3.14159;
#if defined(CSQC) || defined(SSQC)
const float MOVETYPE_NONE = 0;
const float MOVETYPE_WALK = 3;
const float MOVETYPE_STEP = 4;
const float MOVETYPE_FLY = 5;
const float MOVETYPE_TOSS = 6;
const float MOVETYPE_PUSH = 7;
const float MOVETYPE_NOCLIP = 8;
const float MOVETYPE_FLYMISSILE = 9;
const float MOVETYPE_BOUNCE = 10;
const float MOVETYPE_BOUNCEMISSILE = 11;
const float MOVETYPE_FOLLOW = 12;
const float MOVETYPE_WALLWALK = 31;	/* Players using this movetype will be able to orient themselves to walls, and then run up them. */
const float MOVETYPE_PHYSICS = 32;	/* Enable the use of ODE physics upon this entity. */
const float SOLID_NOT = 0;
const float SOLID_TRIGGER = 1;
const float SOLID_BBOX = 2;
const float SOLID_SLIDEBOX = 3;
const float SOLID_BSP = 4;
const float SOLID_CORPSE = 5;
const float SOLID_LADDER = 20;	/* Obsolete and may be removed at some point. Use skin=CONTENT_LADDER and solid_bsp or solid_trigger instead. */
const float SOLID_PHYSICS_BOX = 32;
const float SOLID_PHYSICS_SPHERE = 33;
const float SOLID_PHYSICS_CAPSULE = 34;
const float SOLID_PHYSICS_TRIMESH = 35;
const float SOLID_PHYSICS_CYLINDER = 36;
const float GEOMTYPE_NONE = -1;
const float GEOMTYPE_SOLID = 0;
const float GEOMTYPE_BOX = 1;
const float GEOMTYPE_SPHERE = 2;
const float GEOMTYPE_CAPSULE = 3;
const float GEOMTYPE_TRIMESH = 4;
const float GEOMTYPE_CYLINDER = 5;
const float GEOMTYPE_CAPSULE_X = 6;
const float GEOMTYPE_CAPSULE_Y = 7;
const float GEOMTYPE_CAPSULE_Z = 8;
const float GEOMTYPE_CYLINDER_X = 9;
const float GEOMTYPE_CYLINDER_Y = 10;
const float GEOMTYPE_CYLINDER_Z = 11;
const float JOINTTYPE_FIXED = -1;
const float JOINTTYPE_POINT = 1;
const float JOINTTYPE_HINGE = 2;
const float JOINTTYPE_SLIDER = 3;
const float JOINTTYPE_UNIVERSAL = 4;
const float JOINTTYPE_HINGE2 = 5;
#endif
#ifdef CSQC
const float GE_MAXENTS = -1;	/* Valid for getentity, ignores the entity argument. Returns the maximum number of entities which may be valid, to avoid having to poll 65k when only 100 are used. */
const float GE_ACTIVE = 0;	/* Valid for getentity. Returns whether this entity is known to the client or not. */
const float GE_ORIGIN = 1;	/* Valid for getentity. Returns the interpolated .origin. */
const float GE_FORWARD = 2;	/* Valid for getentity. Returns the interpolated forward vector. */
const float GE_RIGHT = 3;	/* Valid for getentity. Returns the entity's right vector. */
const float GE_UP = 4;	/* Valid for getentity. Returns the entity's up vector. */
const float GE_SCALE = 5;	/* Valid for getentity. Returns the entity .scale. */
const float GE_ORIGINANDVECTORS = 6;	/* Valid for getentity. Returns interpolated .origin, but also sets v_forward, v_right, and v_up accordingly. Use vectoangles(v_forward,v_up) to determine the angles. */
const float GE_ALPHA = 7;	/* Valid for getentity. Returns the entity alpha. */
const float GE_COLORMOD = 8;	/* Valid for getentity. Returns the colormod vector. */
const float GE_PANTSCOLOR = 9;	/* Valid for getentity. Returns the entity's lower color (from .colormap), as a palette range value. */
const float GE_SHIRTCOLOR = 10;	/* Valid for getentity. Returns the entity's lower color (from .colormap), as a palette range value. */
const float GE_SKIN = 11;	/* Valid for getentity. Returns the entity's .skin index. */
const float GE_MINS = 12;	/* Valid for getentity. Guesses the entity's .min vector. */
const float GE_MAXS = 13;	/* Valid for getentity. Guesses the entity's .max vector. */
const float GE_ABSMIN = 14;	/* Valid for getentity. Guesses the entity's .absmin vector. */
const float GE_ABSMAX = 15;	/* Valid for getentity. Guesses the entity's .absmax vector. */
#endif
#ifdef SSQC
const float DAMAGE_NO = 0;
const float DAMAGE_YES = 1;
const float DAMAGE_AIM = 2;
#endif
#if defined(CSQC) || defined(SSQC)
const float CONTENT_EMPTY = -1;
const float CONTENT_SOLID = -2;
const float CONTENT_WATER = -3;
const float CONTENT_SLIME = -4;
const float CONTENT_LAVA = -5;
const float CONTENT_SKY = -6;
const float CONTENT_LADDER = -16;	/* If this value is assigned to a solid_bsp's .skin field, the entity will become a ladder volume. */
const float CHAN_AUTO = 0;	/* The automatic channel, play as many sounds on this channel as you want, and they'll all play, however the other channels will replace each other. */
const float CHAN_WEAPON = 1;
const float CHAN_VOICE = 2;
const float CHAN_ITEM = 3;
const float CHAN_BODY = 4;
const float ATTN_NONE = 0;	/* Sounds with this attenuation can be heard throughout the map */
const float ATTN_NORM = 1;	/* Standard attenuation */
const float ATTN_IDLE = 2;	/* Extra attenuation so that sounds don't travel too far. */
const float ATTN_STATIC = 3;	/* Even more attenuation to avoid torches drowing out everything else throughout the map. */
#endif
#ifdef SSQC
const float SVC_CGAMEPACKET = 83;	/* Direct ssqc->csqc message. Must only be multicast. The data triggers a CSQC_Parse_Event call in the csqc for the csqc to read the contents. The server *may* insert length information for clients connected via proxies which are not able to cope with custom csqc payloads. This should only ever be used in conjunction with the MSG_MULTICAST destination. */
const float MSG_BROADCAST = 0;	/* The byte(s) will be unreliably sent to all players. MSG_ constants are valid arguments to the Write* builtin family. */
const float MSG_ONE = 1;	/* The byte(s) will be reliably sent to the player specified in the msg_entity global. */
const float MSG_ALL = 2;	/* The byte(s) will be reliably sent to all players. */
const float MSG_INIT = 3;	/* The byte(s) will be written into the signon buffer. Clients will see these messages when they connect later. This buffer is only flushed on map changes, so spamming it _WILL_ result in overflows. */
const float MSG_MULTICAST = 4;	/* The byte(s) will be written into the multicast buffer for more selective sending. Messages sent this way will never be split across packets, and using this for csqc-only messages will not break protocol translation. */
const float MSG_ENTITY = 5;	/* The byte(s) will be written into the entity buffer. This is a special value used only inside 'SendEntity' functions. */
const float MULTICAST_ALL = 0;	/* The multicast message is unreliably sent to all players. MULTICAST_ constants are valid arguments for the multicast builtin, which ignores the specified origin when given this constant. */
const float MULTICAST_PHS = 1;	/* The multicast message is unreliably sent to only players that can potentially hear the specified origin. Its quite loose. */
const float MULTICAST_PVS = 2;	/* The multicast message is unreliably sent to only players that can potentially see the specified origin. */
const float MULTICAST_ONE = 6;	/* The multicast message is unreliably sent to the player specified in the msg_entity global. The specified origin is ignored. */
const float MULTICAST_ALL_R = 3;	/* The multicast message is reliably sent to all players. The specified origin is ignored. */
const float MULTICAST_PHS_R = 4;	/* The multicast message is reliably sent to only players that can potentially hear the specified origin. Players might still not receive it if they are out of range. */
const float MULTICAST_PVS_R = 5;	/* The multicast message is reliably sent to only players that can potentially see the specified origin. Players might still not receive it if they cannot see the event. */
const float MULTICAST_ONE_R = 7;	/* The multicast message is reliably sent to the player specified in the msg_entity global. The specified origin is ignored */
#endif
#if defined(QWSSQC)
const float PRINT_LOW = 0;
const float PRINT_MEDIUM = 1;
const float PRINT_HIGH = 2;
const float PRINT_CHAT = 3;
#endif
#ifdef SSQC
const float PVSF_NORMALPVS = 0;	/* Filter first by PVS, then filter this entity using tracelines if sv_cullentities is enabled. */
const float PVSF_NOTRACECHECK = 1;	/* Filter strictly by PVS. */
const float PVSF_USEPHS = 2;	/* Send if we're close enough to be able to hear this entity. */
const float PVSF_IGNOREPVS = 3;	/* Ignores pvs. This entity is visible whereever you are on the map. */
const float PVSF_NOREMOVE = 128;	/* Once visible to a client, this entity will remain visible. This can be useful for csqc and corpses. */
const string INFOKEY_P_IP = "ip";	/* The apparent ip address of the client. This may be a proxy's ip address. */
const string INFOKEY_P_REALIP = "realip";	/* If sv_getrealip is set, this gives the ip as determine using that algorithm. */
const string INFOKEY_P_CSQCACTIVE = "csqcactive";	/* Client has csqc enabled. CSQC ents etc will be sent to this player. */
const string INFOKEY_P_SVPING = "svping";
const string INFOKEY_P_GUID = "guid";	/* Some hash string which should be reasonably unique to this player's quake installation. */
const string INFOKEY_P_CHALLENGE = "challenge";
const string INFOKEY_P_USERID = "*userid";
const string INFOKEY_P_DOWNLOADPCT = "download";	/* The client's download percentage for the current file. Additional files are not known. */
const string INFOKEY_P_TRUSTLEVEL = "trustlevel";
const string INFOKEY_P_PROTOCOL = "protocol";	/* The network protocol the client is using to connect to the server. */
const string INFOKEY_P_VIP = "*VIP";	/* 1 if the player has the VIP 'penalty'. */
const string INFOKEY_P_ISMUTED = "*ismuted";	/* 1 if the player has the 'mute' penalty and is not allowed to use the say/say_team commands. */
const string INFOKEY_P_ISDEAF = "*isdeaf";	/* 1 if the player has the 'deaf' penalty and cannot see other people's say/say_team commands. */
const string INFOKEY_P_ISCRIPPLED = "*ismuted";	/* 1 if the player has the cripple penalty, and their movement values are ignored (.movement is locked to 0). */
const string INFOKEY_P_ISCUFFED = "*ismuted";	/* 1 if the player has the cuff penalty, and is unable to attack or use impulses(.button0 and .impulse fields are locked to 0). */
const string INFOKEY_P_ISLAGGED = "*ismuted";	/* 1 if the player has the fakelag penalty and has an extra 200ms of lag. */
#endif
#if defined(CSQC) || defined(SSQC)
const string INFOKEY_P_PING = "ping";	/* The player's ping time, in milliseconds. */
const string INFOKEY_P_NAME = "name";	/* The player's name. */
const string INFOKEY_P_TOPCOLOR = "topcolor";	/* The player's upper/shirt colour (palette index). */
const string INFOKEY_P_BOTTOMCOLOR = "bottomcolor";	/* The player's lower/pants/trouser colour (palette index). */
#endif
#ifdef CSQC
const string INFOKEY_P_TOPCOLOR_RGB = "topcolor_rgb";	/* The player's upper/shirt colour as an rgb value in a format usable with stov. */
const string INFOKEY_P_BOTTOMCOLOR_RGB = "bottomcolor_rgb";	/* The player's lower/pants/trouser colour as an rgb value in a format usable with stov. */
const string INFOKEY_P_MUTED = "ignored";	/* 0: we can see the result of the player's say/say_team commands.   1: we see no say/say_team messages from this player. Use the ignore command to toggle this value. */
const string INFOKEY_P_VOIP_MUTED = "vignored";	/* 0: we can hear this player when they speak (assuming voip is generally enabled). 1: we ignore everything this player says. Use cl_voip_mute to change the values. */
const string INFOKEY_P_ENTERTIME = "entertime";	/* Reads the timestamp at which the player entered the game, in terms of csqc's time global. */
const string INFOKEY_P_FRAGS = "frags";	/* Reads a player's frag count. */
const string INFOKEY_P_PACKETLOSS = "pl";	/* Reads a player's packetloss, as a percentage. */
const string INFOKEY_P_VOIPSPEAKING = "voipspeaking";	/* Boolean value that says whether the given player is currently sending voice information. */
const string INFOKEY_P_VOIPLOUDNESS = "voiploudness";	/* Only valid for the local player. Gives a value between 0 and 1 to indicate to the user how loud their mic is. */
#endif
#if defined(CSQC) || defined(SSQC)
const float FL_FLY = 1;
const float FL_SWIM = 2;
const float FL_CLIENT = 8;
const float FL_INWATER = 16;
const float FL_MONSTER = 32;
#endif
#ifdef SSQC
const float FL_GODMODE = 64;
const float FL_NOTARGET = 128;
#endif
#if defined(CSQC) || defined(SSQC)
const float FL_ITEM = 256;
const float FL_ONGROUND = 512;
const float FL_PARTIALGROUND = 1024;
const float FL_WATERJUMP = 2048;
#endif
#if defined(CSQC) || defined(NQSSQC)
const float FL_JUMPRELEASED = 4096;
#endif
#if defined(CSQC) || defined(SSQC)
const float FL_FINDABLE_NONSOLID = 16384;	/* Allows this entity to be found with findradius */
#endif
#ifdef SSQC
const float FL_LAGGEDMOVE = 65536;	/* Enables anti-lag on rockets etc. */
#endif
#if defined(CSQC) || defined(SSQC)
const float MOVE_NORMAL = 0;
const float MOVE_NOMONSTERS = 1;	/* The trace will ignore all non-solid_bsp entities. */
const float MOVE_MISSILE = 2;	/* The trace will use a bbox size of +/- 15 against entities with FL_MONSTER set. */
const float MOVE_HITMODEL = 4;	/* Traces will impact the actual mesh of the model instead of merely their bounding box. Should generally only be used for tracelines. Note that this flag is unreliable as an object can animate through projectiles. The bounding box MUST be set to completely encompass the entity or those extra areas will be non-solid (leaving a hole for things to go through). */
const float MOVE_TRIGGERS = 16;	/* This trace type will impact only triggers. It will ignore non-solid entities. */
const float MOVE_EVERYTHING = 32;	/* This type of trace will hit solids and triggers alike. Even non-solid entities. */
#endif
#ifdef SSQC
const float MOVE_LAGGED = 64;	/* Will use antilag based upon the player's latency. Traces will be performed against old positions for entities instead of their current origin. */
#endif
#if defined(CSQC) || defined(SSQC)
const float MOVE_ENTCHAIN = 128;	/* Returns a list of entities impacted via the trace_ent.chain field */
#endif
const float RESTYPE_MODEL = 0;	/* RESTYPE_* constants are used as arguments with the resourcestatus builtin. */
const float RESTYPE_SOUND = 1;	/* precache_sound */
const float RESTYPE_PARTICLE = 2;	/* particleeffectnum */
#if defined(CSQC) || defined(MENU)
const float RESTYPE_PIC = 3;	/* precache_pic. Status results are an amalgomation of the textures used by the named shader. */
const float RESTYPE_SKIN = 4;	/* setcustomskin */
const float RESTYPE_TEXTURE = 5;	/* Individual textures within shaders. These are not directly usable, but may be named as part of a skin file, or a shader. */
#endif
const float RESSTATE_NOTKNOWN = 0;	/* RESSTATE_* constants are return values from the resourcestatus builtin. The engine doesn't know about the resource if it is in this state. This means you will need to precache it. Attempting to use it anyway may result in warnings, errors, or silently succeed, depending on engine version and resource type. */
const float RESSTATE_NOTLOADED = 1;	/* The resource was precached, but has been flushed and there has not been an attempt to reload it. If you use the resource normally, chances are it'll be loaded but at the cost of a stall. */
const float RESSTATE_LOADING = 2;	/* Resources in this this state are queued for loading, and will be loaded at the engine's convienience. If you attempt to query the resource now, the engine will stall until the result is available. sounds in this state may be delayed, while models/pics/shaders may be invisible. */
const float RESSTATE_FAILED = 3;	/* Resources in this state are unusable/could not be loaded. You will get placeholders or dummy results. Queries will not stall the engine. The engine may display placeholder content. */
const float RESSTATE_LOADED = 4;	/* Resources in this state are finally usable, everything will work okay. Hurrah. Queries will not stall the engine. */
#if defined(CSQC) || defined(SSQC)
const float EF_BRIGHTFIELD = 1;
#endif
#if defined(CSQC) || defined(NQSSQC)
const float EF_MUZZLEFLASH = 2;
#endif
#if defined(CSQC) || defined(SSQC)
const float EF_BRIGHTLIGHT = 4;
const float EF_DIMLIGHT = 8;
#endif
#if defined(QWSSQC)
const float EF_FLAG1 = 16;
const float EF_FLAG2 = 32;
#endif
#if defined(CSQC) || defined(NQSSQC)
const float EF_ADDITIVE = 32;
#endif
#if defined(CSQC) || defined(SSQC)
const float EF_BLUE = 64;
const float EF_RED = 128;
const float EF_FULLBRIGHT = 512;
const float EF_NODEPTHTEST = 8192;
#endif
#ifdef SSQC
const float EF_NOMODELFLAGS = 8388608;	/* Surpresses the normal flags specified in the model. */
#endif
#if defined(CSQC) || defined(SSQC)
const float MF_ROCKET = 1;
const float MF_GRENADE = 2;
const float MF_GIB = 4;
const float MF_ROTATE = 8;
const float MF_TRACER = 16;
const float MF_ZOMGIB = 32;
const float MF_TRACER2 = 64;
const float MF_TRACER3 = 128;
const float PFLAGS_NOSHADOW = 1;	/* Associated RT lights attached will not cast shadows, making them significantly faster to draw. */
const float PFLAGS_CORONA = 2;	/* Enables support of coronas on the associated rtlights. */
#endif
#ifdef SSQC
const float PFLAGS_FULLDYNAMIC = 128;	/* When set in self.pflags, enables fully-customised dynamic lights. Custom rtlight information is not otherwise used. */
#endif
#if defined(CSQC) || defined(SSQC)
const float EV_STRING = 1;
const float EV_FLOAT = 2;
const float EV_VECTOR = 3;
const float EV_ENTITY = 4;
const float EV_FUNCTION = 6;
const float EV_POINTER = 7;
const float EV_INTEGER = 8;
const float EV_VARIANT = 9;
#endif
hashtable gamestate;	/* Special hash table index for hash_add and hash_get. Entries in this table will persist over map changes (and doesn't need to be created/deleted). */
const float HASH_REPLACE = 256;	/* Used with hash_add. Attempts to remove the old value instead of adding two values for a single key. */
#ifdef CSQC
const float STAT_HEALTH = 0;
const float STAT_WEAPON = 2;
const float STAT_AMMO = 3;
const float STAT_ARMOR = 4;
const float STAT_WEAPONFRAME = 5;
const float STAT_SHELLS = 6;
const float STAT_NAILS = 7;
const float STAT_ROCKETS = 8;
const float STAT_CELLS = 9;
const float STAT_ACTIVEWEAPON = 10;
const float STAT_TOTALSECRETS = 11;
const float STAT_TOTALMONSTERS = 12;
const float STAT_FOUNDSECRETS = 13;
const float STAT_KILLEDMONSTERS = 14;
const float STAT_ITEMS = 15;
const float STAT_VIEWHEIGHT = 16;
const float STAT_VIEW2 = 20;	/* This stat contains the number of the entity in the server's .view2 field. */
const float STAT_VIEWZOOM = 21;
#endif
#if defined(CSQC) || defined(MENU)
const float VF_MIN = 1;	/* The top-left of the 3d viewport in screenspace. The VF_ values are used via the setviewprop/getviewprop builtins. */
const float VF_MIN_X = 2;
const float VF_MIN_Y = 3;
const float VF_SIZE = 4;	/* The width+height of the 3d viewport in screenspace. */
const float VF_SIZE_X = 5;
const float VF_SIZE_Y = 6;
const float VF_VIEWPORT = 7;	/* vector+vector. Two argument shortcut for VF_MIN and VF_SIZE */
const float VF_FOV = 8;	/* sets both fovx and fovy. consider using afov instead. */
const float VF_FOVX = 9;	/* horizontal field of view. does not consider aspect at all. */
const float VF_FOVY = 10;	/* vertical field of view. does not consider aspect at all. */
const float VF_ORIGIN = 11;	/* The origin of the view. Not of the player. */
const float VF_ORIGIN_X = 12;
const float VF_ORIGIN_Y = 13;
const float VF_ORIGIN_Z = 14;
const float VF_ANGLES = 15;	/* The angles the view will be drawn at. Not the angle the client reports to the server. */
const float VF_ANGLES_X = 16;
const float VF_ANGLES_Y = 17;
const float VF_ANGLES_Z = 18;
#endif
#ifdef CSQC
const float VF_DRAWWORLD = 19;	/* boolean. If set to 1, the engine will draw the world and static/persistant rtlights. If 0, the world will be skipped and everything will be fullbright. */
const float VF_DRAWENGINESBAR = 20;	/* boolean. If set to 1, the sbar will be drawn, and viewsize will be honoured automatically. */
const float VF_DRAWCROSSHAIR = 21;	/* boolean. If set to 1, the engine will draw its default crosshair. */
const float VF_CL_VIEWANGLES = 33;
const float VF_CL_VIEWANGLES_X = 34;
const float VF_CL_VIEWANGLES_Y = 35;
const float VF_CL_VIEWANGLES_Z = 36;
#endif
#if defined(CSQC) || defined(MENU)
const float VF_PERSPECTIVE = 200;	/* 1: regular rendering. Fov specifies the angle. 0: isometric-style. Fov specifies the number of Quake Units each side of the viewport. */
#endif
#ifdef CSQC
const float VF_LPLAYER = 202;	/* The 'seat' number, used when running splitscreen. */
#endif
#if defined(CSQC) || defined(MENU)
const float VF_AFOV = 203;	/* Aproximate fov. Matches the 'fov' cvar. The engine handles the aspect ratio for you. */
const float VF_SCREENVSIZE = 204;	/* Provides a reliable way to retrieve the current virtual screen size (even if the screen is automatically scaled to retain aspect). */
const float VF_SCREENPSIZE = 205;	/* Provides a reliable way to retrieve the current physical screen size (cvars need vid_restart for them to take effect). */
#endif
#ifdef CSQC
const float VF_VIEWENTITY = 206;	/* Changes the RF_EXTERNALMODEL flag on entities to match the new selection, and removes entities flaged with RF_VIEWENTITY. Requires cunning use of .entnum and typically requires calling addentities(MASK_VIEWMODEL) too. */
#endif
#if defined(CSQC) || defined(MENU)
const float VF_RT_DESTCOLOUR = 212;	/* The texture name to write colour info into, this includes both 3d and 2d drawing.
Additional arguments are: format (rgba8=1,rgba16f=2,rgba32f=3), sizexy.
Written to by both 3d and 2d rendering.
Note that any rendertarget textures may be destroyed on video mode changes or so. Shaders can name render targets by prefixing texture names with '$rt:', or $sourcecolour. */
const float VF_RT_SOURCECOLOUR = 209;	/* The texture name to use with shaders that specify a $sourcecolour map. */
const float VF_RT_DEPTH = 210;	/* The texture name to use as a depth buffer. Also used for shaders that specify $sourcedepth. 1-based. Additional arguments are: format (16bit=4,24bit=5,32bit=6), sizexy. */
const float VF_RT_RIPPLE = 211;	/* The texture name to use as a ripplemap (target for shaders with 'sort ripple'). Also used for shaders that specify $ripplemap. 1-based. Additional arguments are: format, sizexy. */
#endif
#ifdef CSQC
const float RF_VIEWMODEL = 1;	/* Specifies that the entity is a view model, and that its origin is relative to the current view position. These entities are also subject to viewweapon bob. */
const float RF_EXTERNALMODEL = 2;	/* Specifies that this entity should be displayed in mirrors (and may still cast shadows), but will not otherwise be visible. */
#endif
#if defined(CSQC) || defined(MENU)
const float RF_DEPTHHACK = 4;	/* Hacks the depth values such that the entity uses depth values as if it were closer to the screen. This is useful when combined with viewmodels to avoid weapons poking in to walls. */
const float RF_ADDITIVE = 8;	/* Shaders from this entity will temporarily be hacked to use an additive blend mode instead of their normal blend mode. */
#endif
#ifdef CSQC
const float RF_USEAXIS = 16;	/* The entity will be oriented according to the current v_forward+v_right+v_up vector values instead of the entity's .angles field. */
const float RF_NOSHADOW = 32;	/* This entity will not cast shadows. Often useful on view models. */
const float RF_FRAMETIMESARESTARTTIMES = 64;	/* Specifies that the frame1time, frame2time field are timestamps (denoting the start of the animation) rather than time into the animation. */
const float IE_KEYDOWN = 0;	/* Specifies that a key was pressed. Second argument is the scan code. Third argument is the unicode (printable) char value. Fourth argument denotes which keyboard(or mouse, if its a mouse 'scan' key) the event came from. Note that some systems may completely separate scan codes and unicode values, with a 0 value for the unspecified argument. */
const float IE_KEYUP = 1;	/* Specifies that a key was released. Arguments are the same as IE_KEYDOWN. On some systems, this may be fired instantly after IE_KEYDOWN was fired. */
const float IE_MOUSEDELTA = 2;	/* Specifies that a mouse was moved (touch screens and tablets typically give IE_MOUSEABS events instead, use _windowed_mouse 0 to test code to cope with either). Second argument is the X displacement, third argument is the Y displacement. Fourth argument is which mouse or touch event triggered the event. */
const float IE_MOUSEABS = 3;	/* Specifies that a mouse cursor or touch event was moved to a specific location relative to the virtual screen space. Second argument is the new X position, third argument is the new Y position. Fourth argument is which mouse or touch event triggered the event. */
const float IE_ACCELEROMETER = 4;
const float IE_FOCUS = 5;	/* Specifies that input focus was given. parama says mouse focus, paramb says keyboard focus. If either are -1, then it is unchanged. */
const float IE_JOYAXIS = 6;	/* Specifies that what value a joystick/controller axis currently specifies. x=axis, y=value. Will be called multiple times, once for each axis of each active controller. */
#endif
#ifdef SSQC
const float CLIENTTYPE_DISCONNECTED = 0;	/* Return value from clienttype() builtin. This entity is a player slot that is currently empty. */
const float CLIENTTYPE_REAL = 1;	/* This is a real player, and not a bot. */
const float CLIENTTYPE_BOT = 2;	/* This player slot does not correlate to a real player, any messages sent to this client will be ignored. */
const float CLIENTTYPE_NOTACLIENT = 3;	/* This entity is not even a player slot. This is typically an error condition. */
#endif
const float FILE_READ = 0;	/* The file may be read via fgets to read a single line at a time. */
const float FILE_APPEND = 1;	/* Like FILE_WRITE, but writing starts at the end of the file. */
const float FILE_WRITE = 2;	/* fputs will be used to write to the file. */
#if defined(CSQC) || defined(SSQC)
const float FILE_READNL = 4;	/* Like FILE_READ, except newlines are not special. fgets reads the entire file into a tempstring. */
const float FILE_MMAP_READ = 5;	/* The file will be loaded into memory. fgets returns a pointer to the first byte (and will always return the same value for this file). Cast this to your datatype. */
const float FILE_MMAP_RW = 6;	/* Like FILE_MMAP_READ, except any changes to the data will be written back to disk once the file is closed. */
#endif
#ifdef CSQC
const float MASK_ENGINE = 1;	/* Valid as an argument for addentities. If specified, all non-csqc entities will be added to the scene. */
const float MASK_VIEWMODEL = 2;	/* Valid as an argument for addentities. If specified, the regular engine viewmodel will be added to the scene. */
const float PREDRAW_AUTOADD = 0;	/* Valid as a return value from the predraw function. Returning this will cause the engine to automatically invoke addentity(self) for you. */
const float PREDRAW_NEXT = 1;	/* Valid as a return value from the predraw function. Returning this will simply move on to the next entity without the autoadd behaviour, so can be used for particle/invisible/special entites, or entities that were explicitly drawn with addentity. */
const float LFIELD_ORIGIN = 0;
const float LFIELD_COLOUR = 1;
const float LFIELD_RADIUS = 2;
const float LFIELD_FLAGS = 3;
const float LFIELD_STYLE = 4;
const float LFIELD_ANGLES = 5;
const float LFIELD_FOV = 6;
const float LFIELD_CORONA = 7;
const float LFIELD_CORONASCALE = 8;
const float LFIELD_CUBEMAPNAME = 9;
const float LFIELD_AMBIENTSCALE = 10;
const float LFIELD_DIFFUSESCALE = 11;
const float LFIELD_SPECULARSCALE = 12;
const float LFLAG_NORMALMODE = 1;
const float LFLAG_REALTIMEMODE = 2;
const float LFLAG_LIGHTMAP = 4;
const float LFLAG_FLASHBLEND = 8;
const float LFLAG_NOSHADOWS = 256;
const float LFLAG_SHADOWMAP = 512;
const float LFLAG_CREPUSCULAR = 1024;
const float TEREDIT_RELOAD = 0;
const float TEREDIT_SAVE = 1;
const float TEREDIT_SETHOLE = 2;
const float TEREDIT_HEIGHT_SET = 3;
const float TEREDIT_HEIGHT_SMOOTH = 4;
const float TEREDIT_HEIGHT_SPREAD = 5;
const float TEREDIT_HEIGHT_RAISE = 6;
const float TEREDIT_HEIGHT_FLATTEN = 18;
const float TEREDIT_HEIGHT_LOWER = 7;
const float TEREDIT_TEX_KILL = 8;
const float TEREDIT_TEX_GET = 9;
const float TEREDIT_TEX_BLEND = 10;
const float TEREDIT_TEX_UNIFY = 11;
const float TEREDIT_TEX_NOISE = 12;
const float TEREDIT_TEX_BLUR = 13;
const float TEREDIT_WATER_SET = 14;
const float TEREDIT_MESH_ADD = 15;
const float TEREDIT_MESH_KILL = 16;
const float TEREDIT_TINT = 17;
const float TEREDIT_TEX_REPLACE = 19;
const float TEREDIT_RESET_SECT = 20;
const float TEREDIT_RELOAD_SECT = 21;
#endif
#if defined(CSQC) || defined(MENU)
const float SLIST_HOSTCACHEVIEWCOUNT = 0;
const float SLIST_HOSTCACHETOTALCOUNT = 1;
const float SLIST_MASTERQUERYCOUNT = 2;
const float SLIST_MASTERREPLYCOUNT = 3;
const float SLIST_SERVERQUERYCOUNT = 4;
const float SLIST_SERVERREPLYCOUNT = 5;
const float SLIST_SORTFIELD = 6;
const float SLIST_SORTDESCENDING = 7;
const float SLIST_TEST_CONTAINS = 0;
const float SLIST_TEST_NOTCONTAIN = 1;
const float SLIST_TEST_LESSEQUAL = 2;
const float SLIST_TEST_LESS = 3;
const float SLIST_TEST_EQUAL = 4;
const float SLIST_TEST_GREATER = 5;
const float SLIST_TEST_GREATEREQUAL = 6;
const float SLIST_TEST_NOTEQUAL = 7;
const float SLIST_TEST_STARTSWITH = 8;
const float SLIST_TEST_NOTSTARTSWITH = 9;
#endif
#ifdef MENU
float(string ext) checkextension = #1; /*
		Checks if the named extension is supported by the running engine. */

void(string err,...) error = #2;
void(string err,...) objerror = #3;
void(string text,...) print = #4;
//void(string text,...) bprint = #5;
//void(float clientnum, string text,...) msprint = #6;
//void(string text,...) cprint = #7;
vector(vector) normalize = #8;
float(vector) vlen = #9;
float(vector) vectoyaw = #10;
vector(vector) vectoangles = #11;
float() random = #12;
void(string) localcmd = #13;
float(string name) cvar = #14;
void(string name, string value) cvar_set = #15;
void(string text) dprint = #16;
string(float) ftos = #17;
float(float) fabs = #18;
string(vector) vtos = #19;
string(entity) etos = #20; /* Part of DP_QC_ETOS*/
float(string) stof = #21; /* Part of FRIK_FILE, FTE_STRINGS, QW_ENGINE, ZQ_QC_STRINGS*/
entity() spawn = #22;
void(entity) remove = #23;
entity(entity start, .string field, string match) find = #24;
entity(entity start, .__variant field, __variant match) findfloat = #25; /* Part of DP_QC_FINDFLOAT*/
entity(.string field, string match) findchain = #26; /* Part of DP_QC_FINDCHAIN*/
entity(.__variant field, __variant match) findchainfloat = #27; /* Part of DP_QC_FINDCHAINFLOAT*/
string(string file) precache_file = #28;
string(string sample) precache_sound = #29;
void() coredump = #30;
void() traceon = #31;
void() traceoff = #32;
void(entity) eprint = #33;
float(float) rint = #34;
float(float) floor = #35;
float(float) ceil = #36;
entity(entity) nextent = #37;
float(float) sin = #38; /* Part of DP_QC_SINCOSSQRTPOW*/
float(float) cos = #39; /* Part of DP_QC_SINCOSSQRTPOW*/
float(float) sqrt = #40; /* Part of DP_QC_SINCOSSQRTPOW*/
vector() randomvector = #41;
float(string name, string value, float flags) registercvar = #42; /* Part of DP_REGISTERCVAR*/
float(float,...) min = #43; /* Part of DP_QC_MINMAXBOUND*/
float(float,...) max = #44; /* Part of DP_QC_MINMAXBOUND*/
float(float min,float value,float max) bound = #45; /* Part of DP_QC_MINMAXBOUND*/
float(float,float) pow = #46; /* Part of DP_QC_SINCOSSQRTPOW*/
void(entity src, entity dst) copyentity = #47; /* Part of DP_QC_COPYENTITY*/
filestream(string filename, float mode) fopen = #48; /* Part of FRIK_FILE*/
void(filestream fhandle) fclose = #49; /* Part of FRIK_FILE*/
string(filestream fhandle) fgets = #50; /* Part of FRIK_FILE*/
void(filestream fhandle, string s) fputs = #51; /* Part of FRIK_FILE*/
float(string) strlen = #52; /* Part of FRIK_FILE, FTE_STRINGS, ZQ_QC_STRINGS*/
string(string, optional string, optional string, optional string, optional string, optional string, optional string, optional string) strcat = #53; /* Part of FRIK_FILE, FTE_STRINGS, ZQ_QC_STRINGS*/
string(string s, float start, float length) substring = #54; /* Part of FRIK_FILE, FTE_STRINGS, ZQ_QC_STRINGS*/
vector(string) stov = #55; /* Part of FRIK_FILE, FTE_STRINGS, ZQ_QC_STRINGS*/
string(string) strzone = #56; /* Part of FRIK_FILE, FTE_STRINGS, ZQ_QC_STRINGS*/
void(string) strunzone = #57; /* Part of FRIK_FILE, FTE_STRINGS, ZQ_QC_STRINGS*/
float(string) tokenize = #58; /* Part of KRIMZON_SV_PARSECLIENTCOMMAND*/
string(float) argv = #59; /* Part of KRIMZON_SV_PARSECLIENTCOMMAND*/
float() isserver = #60;
//float() clientcount = #61;
float() clientstate = #62;
//void(float client, string s) clientcommand = #63; /* Part of KRIMZON_SV_PARSECLIENTCOMMAND*/
//void(string map) changelevel = #64;
void(string sample) localsound = #65;
vector() getmousepos = #66;
float(optional float timetype) gettime = #67;
void(string data) loadfromdata = #68;
void(string data) loadfromfile = #69;
float(float val, float m) mod = #70;
string(string name) cvar_string = #71; /* Part of DP_QC_CVAR_STRING*/
//void() crash = #72;
//void() stackdump = #73;
searchhandle(string pattern, float caseinsensitive, float quiet) search_begin = #74; /* Part of DP_QC_FS_SEARCH*/
void(searchhandle handle) search_end = #75; /* Part of DP_QC_FS_SEARCH*/
float(searchhandle handle) search_getsize = #76; /* Part of DP_QC_FS_SEARCH*/
string(searchhandle handle, float num) search_getfilename = #77; /* Part of DP_QC_FS_SEARCH*/
float(entity) etof = #79;
entity(float) ftoe = #80;
float(string) validstring = #81;
float(string str) altstr_count = #82;
string(string str) altstr_prepare = #83;
string(string str, float num) altstr_get = #84;
string(string str, float num, string set)  altstr_set = #85;
//string(string str, float num, string set) altstr_ins = #86;
entity(entity start, .float field, float match) findflags = #87; /* Part of DP_QC_FINDFLAGS*/
entity(.float field, float match) findchainflags = #88; /* Part of DP_QC_FINDCHAINFLAGS*/
void(entity ent, string mname) setmodel = #90; /*
		Menuqc-specific version. */

void(string mname) precache_model = #91; /*
		Menuqc-specific version. */

void(entity ent, vector neworg) setorigin = #92; /*
		Menuqc-specific version. */

#endif
#if defined(CSQC) || defined(SSQC)
void(vector vang) makevectors = #1; /*
		Takes an angle vector (pitch,yaw,roll). Writes its results into v_forward, v_right, v_up vectors. */

void(entity e, vector o) setorigin = #2; /*
		Changes e's origin to be equal to o. Also relinks collision state (as well as setting absmin+absmax), which is required after changing .solid */

void(entity e, string m) setmodel = #3; /*
		Looks up m in the model precache list, and sets both e.model and e.modelindex to match. BSP models will set e.mins and e.maxs accordingly, other models depend upon the value of sv_gameplayfix_setmodelrealbox - for compatibility you should always call setsize after all pickups or non-bsp models. Also relinks collision state. */

void(entity e, vector min, vector max) setsize = #4; /*
		Sets the e's mins and maxs fields. Also relinks collision state, which sets absmin and absmax too. */

#endif
#ifdef SSQC
void() breakpoint = #6; /*
		Trigger a debugging event. FTE will break into the qc debugger. Other engines may crash with a debug execption. */

#endif
#if defined(CSQC) || defined(SSQC)
float() random = #7; /*
		Returns a random value between 0 and 1. Be warned, this builtin can return 1 in most engines, which can break arrays. */

void(entity e, float chan, string samp, float vol, float atten, optional float speedpct, optional float flags) sound = #8; /*
		Starts a sound centered upon the given entity.
		chan is the entity sound channel to use, channel 0 will allow you to mix many samples at once, others will replace the old sample
		'samp' must have been precached first
		if specified, 'speedpct' should normally be around 100 (or =0), 200 for double speed or 50 for half speed.
		flags&1 means the sound should be sent reliably. */

vector(vector v) normalize = #9; /*
		Shorten or lengthen a direction vector such that it is only one quake unit long. */

void(string e) error = #10; /*
		Ends the game with an easily readable error message. */

void(string e) objerror = #11; /*
		Displays a non-fatal easily readable error message concerning the self entity, including a field dump. self will be removed! */

float(vector v) vlen = #12; /*
		Returns the square root of the dotproduct of a vector with itself. Or in other words the length of a distance vector, in quake units. */

float(vector v, optional entity reference) vectoyaw = #13; /*
		Given a direction vector, returns the yaw angle in which that direction vector points. If an entity is passed, the yaw angle will be relative to that entity's gravity direction. */

entity() spawn = #14; /*
		Adds a brand new entity into the world! Hurrah, you're now a parent! */

void(entity e) remove = #15; /*
		Destroys the given entity and clears some limited fields (including model, modelindex, solid, classname). Any references to the entity following the call are an error. After two seconds, the entity will be reused, in the interim you can unfortunatly still read its fields to see if the reference is no longer valid. */

void(vector v1, vector v2, float flags, entity ent) traceline = #16; /*
		Traces an infinitely thin line through the world from v1 towards v2.
		Will not collide with ent, ent.owner, or any entity who's owner field refers to ent.
		There are no side effects beyond the trace_* globals being written.
		flags&MOVE_NOMONSTERS will not impact on non-bsp entities.
		flags&MOVE_MISSILE will impact with increased size.
		flags&MOVE_HITMODEL will impact upon model meshes, instead of their bounding boxes.
		flags&MOVE_TRIGGERS will also stop on triggers
		flags&MOVE_EVERYTHING will stop if it hits anything, even non-solid entities.
		flags&MOVE_LAGGED will backdate entity positions for the purposes of this builtin according to the indicated player ent's latency, to provide lag compensation. */

#endif
#ifdef SSQC
entity() checkclient = #17; /*
		Returns one of the player entities. The returned player will change periodically. */

#endif
#if defined(CSQC) || defined(SSQC)
entity(entity start, .string fld, string match) find = #18; /*
		Scan for the next entity with a given field set to the given 'match' value. start should be either world, or the previous entity that was found. Returns world on failure/if there are no more. */

string(string s) precache_sound = #19; /*
		Precaches a sound, making it known to clients and loading it from disk. This builtin (strongly) should be called during spawn functions. This builtin must be called for the sound before the sound builtin is called, or it might not even be heard. */

string(string s) precache_model = #20; /*
		Precaches a model, making it known to clients and loading it from disk if it has a .bsp extension. This builtin (strongly) should be called during spawn functions. This must be called for each model name before setmodel may use that model name.
		Modelindicies precached in SSQC will always be positive. CSQC precaches will be negative if they are not also on the server. */

#endif
#ifdef SSQC
void(entity client, string s) stuffcmd = #21; /*
		Sends a console command (or cvar) to the client, where it will be executed. Different clients support different commands. Do NOT forget the final \n.
		This builtin is generally considered evil. */

#endif
#if defined(CSQC) || defined(SSQC)
entity(vector org, float rad) findradius = #22; /*
		Finds all entities within a distance of the 'org' specified. One entity is returned directly, while other entities are returned via that entity's .chain field. */

#endif
#if defined(NQSSQC)
void(string s, optional string s2, optional string s3, optional string s4, optional string s5, optional string s6, optional string s7, optional string s8) bprint = #23; /*
		NQ: Concatenates all arguments, and prints the messsage on the console of all connected clients. */

#endif
#if defined(QWSSQC)
void(float msglvl, string s, optional string s2, optional string s3, optional string s4, optional string s5, optional string s6, optional string s7) bprint = #23; /*
		QW: Concatenates all string arguments, and prints the messsage on the console of only all clients who's 'msg' infokey is set lower or equal to the supplied 'msglvl' argument. */

#endif
#if defined(NQSSQC)
void(entity client, string s, optional string s2, optional string s3, optional string s4, optional string s5, optional string s6, optional string s7) sprint = #24; /*
		NQ: Concatenates all string arguments, and prints the messsage on the named client's console */

#endif
#if defined(QWSSQC)
void(entity client, float msglvl, string s, optional string s2, optional string s3, optional string s4, optional string s5, optional string s6) sprint = #24; /*
		QW: Concatenates all string arguments, and prints the messsage on the named client's console, but only if that client's 'msg' infokey is set lower or equal to the supplied 'msglvl' argument. */

#endif
#if defined(CSQC) || defined(NQSSQC)
void(string s, ...) dprint = #25; /*
		NQ: Prints the given message on the server's console, but only if the developer cvar is set. Arguments will be concatenated into a single message. */

#endif
#if defined(CSQC) || defined(QWSSQC)
void(string s, ...) dprint = #25; /*
		QW: Unconditionally prints the given message on the server's console.  Arguments will be concatenated into a single message. */

#endif
#if defined(CSQC) || defined(SSQC)
string(float val) ftos = #26; /*
		Returns a tempstring containing a representation of the given float. Precision depends upon engine. */

string(vector val) vtos = #27; /*
		Returns a tempstring containing a representation of the given vector. Precision depends upon engine. */

void() coredump = #28; /*
		Writes out a coredump. This contains stack, globals, and field info for all ents. This can be handy for debugging. */

void() traceon = #29; /*
		Enables tracing. This may be spammy, slow, and stuff. Set debugger 1 in order to use fte's qc debugger. */

void() traceoff = #30; /*
		Disables tracing again. */

void(entity e) eprint = #31; /*
		Debugging builtin that prints all fields of the given entity to the console. */

float(float yaw, float dist, optional float settraceglobals) walkmove = #32; /*
		Attempt to walk the entity at a given angle for a given distance.
		if settraceglobals is set, the trace_* globals will be set, showing the results of the movement.
		This function will trigger touch events. */

float() droptofloor = #34; /*
		Instantly moves the entity downwards until it hits the ground. If the entity would need to drop more than 'pr_droptofloorunits' quake units, its position will be considered invalid and the builtin will abort. */

void(float lightstyle, string stylestring, optional vector rgb) lightstyle = #35; /*
		Specifies an auto-animating string that specifies the light intensity for entities using that lightstyle.
		a is off, z is fully lit. Should be lower case only.
		rgb will recolour all lights using that lightstyle. */

float(float) rint = #36; /*
		Rounds the given float up or down to the closest integeral value. X.5 rounds away from 0 */

float(float) floor = #37; /*
		Rounds the given float downwards, even when negative. */

float(float) ceil = #38; /*
		Rounds the given float upwards, even when negative. */

//float(vector v) qtest_canreach = #39;
float(entity ent) checkbottom = #40; /*
		Expensive checks to ensure that the entity is actually sitting on something solid, returns true if it is. */

float(vector pos) pointcontents = #41; /*
		Checks the given point to see what is there. Returns one of the SOLID_* constants. Just because a spot is empty does not mean that the player can stand there due to the size of the player - use tracebox for such tests. */

float(float) fabs = #43; /*
		Removes the sign of the float, making it positive if it is negative. */

#endif
#ifdef SSQC
vector(entity player, float missilespeed) aim = #44; /*
		Returns a direction vector (specifically v_forward on error). This builtin attempts to guess what pitch angle to fire projectiles at for people that don't know about mouselook. Does not affect yaw angles. */

#endif
#if defined(CSQC) || defined(SSQC)
float(string) cvar = #45; /*
		Returns the numeric value of the named cvar */

void(string, ...) localcmd = #46; /*
		Adds the string to the console command queue. Commands will not be executed immediately, but rather at the start of the following frame. */

entity(entity) nextent = #47; /*
		Returns the following entity. Skips over removed entities. Returns world when passed the last valid entity. */

void(vector pos, vector dir, float colour, float count) particle = #48; /*
		Spawn 'count' particles around 'pos' moving in the direction 'dir', with a palette colour index between 'colour' and 'colour+8'. */

#define ChangeYaw changeyaw
void() changeyaw = #49; /*
		Changes the self.angles_y field towards self.ideal_yaw by up to self.yawspeed. */

vector(vector fwd, optional vector up) vectoangles = #51; /*
		Returns the angles required to orient an entity to look in the given direction. The 'up' argument is required if you wish to set a roll angle, otherwise it will be limited to just monster-style turning. */

#endif
#ifdef SSQC
void(float to, float val) WriteByte = #52; /*
		Writes a single byte into a network message buffer. Typically you will find a more correct alternative to writing arbitary data. 'to' should be one of the MSG_* constants. MSG_ONE must have msg_entity set first. */

void(float to, float val) WriteChar = #53;
void(float to, float val) WriteShort = #54;
void(float to, float val) WriteLong = #55;
void(float to, float val) WriteCoord = #56;
void(float to, float val) WriteAngle = #57;
void(float to, string val) WriteString = #58;
void(float to, entity val) WriteEntity = #59;
#endif
#if defined(CSQC) || defined(SSQC)
float(float angle) sin = #60; /* Part of DP_QC_SINCOSSQRTPOW*/
float(float angle) cos = #61; /* Part of DP_QC_SINCOSSQRTPOW*/
float(float value) sqrt = #62; /* Part of DP_QC_SINCOSSQRTPOW*/
void(entity ent) changepitch = #63; /* Part of DP_QC_CHANGEPITCH*/
void(entity ent, entity ignore) tracetoss = #64;
string(entity ent) etos = #65; /* Part of DP_QC_ETOS*/
void(float step) movetogoal = #67;
string(string s) precache_file = #68; /*
		This builtin does nothing. It was used only as a hint for pak generation. */

void(entity e) makestatic = #69; /*
		Sends a copy of the entity's renderable fields to all clients, and REMOVES the entity, preventing further changes. This means it will be unmutable and non-solid. */

#endif
#ifdef SSQC
void(string mapname, optional string newmapstartspot) changelevel = #70; /*
		Attempts to change the map to the named map. If 'newmapstartspot' is specified, the state of the current map will be preserved, and the argument will be passed to the next map in the 'startspot' global, and the next map will be loaded from archived state if it was previously visited. If not specified, all archived map states will be purged. */

#endif
#if defined(CSQC) || defined(SSQC)
void(string cvarname, string valuetoset) cvar_set = #72; /*
		Instantly sets a cvar to the given string value. */

#endif
#ifdef SSQC
void(entity ent, string text, optional string text2, optional string text3, optional string text4, optional string text5, optional string text6, optional string text7) centerprint = #73;
#endif
#if defined(CSQC) || defined(SSQC)
void (vector pos, string samp, float vol, float atten) ambientsound = #74;
string(string str) precache_model2 = #75;
string(string str) precache_sound2 = #76;
string(string str) precache_file2 = #77;
#endif
#ifdef SSQC
void(entity player) setspawnparms = #78;
void(entity killer, entity killee) logfrag = #79; /* Part of QW_ENGINE*/
string(entity e, string key) infokey = #80; /* Part of QW_ENGINE
		If e is world, returns the field 'key' from either the serverinfo or the localinfo. If e is a player, returns the value of 'key' from the player's userinfo string. There are a few special exceptions, like 'ip' which is not technically part of the userinfo. */

#endif
#if defined(CSQC) || defined(SSQC)
float(string) stof = #81; /* Part of FRIK_FILE, FTE_STRINGS, QW_ENGINE, ZQ_QC_STRINGS*/
#endif
#ifdef SSQC
#define unicast(pl,reli) do{msg_entity = pl; multicast('0 0 0', reli?MULITCAST_ONE_R:MULTICAST_ONE);}while(0)
void(vector where, float set) multicast = #82; /*
		Once the MSG_MULTICAST network message buffer has been filled with data, this builtin is used to dispatch it to the given target, filtering by pvs for reduced network bandwidth. */

void(float style, float val, optional vector rgb) lightstylestatic = #5; /*
		Sets the lightstyle to an explicit numerical level. From Hexen2. */

#endif
#if defined(CSQC) || defined(SSQC)
void(vector start, vector mins, vector maxs, vector end, float nomonsters, entity ent) tracebox = #90; /* Part of DP_QC_TRACEBOX
		Exactly like traceline, but a box instead of a uselessly thin point. Acceptable sizes are limited by bsp format, q1bsp has strict acceptable size values. */

vector() randomvec = #91; /* Part of DP_QC_RANDOMVEC
		Returns a vector with random values. Each axis is independantly a value between -1 and 1 inclusive. */

vector(vector org) getlight = #92;
void(string cvarname, string defaultvalue) registercvar = #93; /* Part of DP_REGISTERCVAR
		Creates a new cvar on the fly. If it does not already exist, it will be given the specified value. If it does exist, this is a no-op.
		This builtin has the limitation that it does not apply to configs or commandlines. Such configs will need to use the set or seta command causing this builtin to be a noop.
		In engines that support it, you will generally find the autocvar feature easier and more efficient to use. */

float(float a, float b, ...) min = #94; /* Part of DP_QC_MINMAXBOUND
		Returns the lowest value of its arguments. */

float(float a, float b, ...) max = #95; /* Part of DP_QC_MINMAXBOUND
		Returns the highest value of its arguments. */

float(float minimum, float val, float maximum) bound = #96; /* Part of DP_QC_MINMAXBOUND
		Returns val, unless minimum is higher, or maximum is less. */

float(float value, float exp) pow = #97; /* Part of DP_QC_SINCOSSQRTPOW*/
entity(entity start, .float fld, float match) findfloat = #98; /* Part of DP_QC_FINDFLOAT
		Equivelent to the find builtin, but instead of comparing strings, this builtin compares floats. This builtin requires multiple calls in order to scan all entities - set start to the previous call's return value.
		world is returned when there are no more entities. */

float(string extname) checkextension = #99; /*
		Checks for an extension by its name (eg: checkextension("FRIK_FILE") says that its okay to go ahead and use strcat).
		Use cvar("pr_checkextension") to see if this builtin exists. */

#endif
#ifdef SSQC
float(string builtinname) builtin_find = #100; /*
		Looks to see if the named builtin is valid, and returns the builtin number it exists at. */

#endif
#if defined(CSQC) || defined(SSQC)
float(float value) anglemod = #102;
#endif
#ifdef SSQC
void(string slot, string picname, float x, float y, float zone, optional entity player) showpic = #104; /* Part of TEI_SHOWLMP2*/
void(string slot, optional entity player) hidepic = #105; /* Part of TEI_SHOWLMP2*/
void(string slot, float x, float y, float zone, optional entity player) movepic = #106; /* Part of TEI_SHOWLMP2*/
void(string slot, string picname, optional entity player) changepic = #107; /* Part of TEI_SHOWLMP2*/
#endif
#if defined(CSQC) || defined(SSQC)
filestream(string filename, float mode, optional float mmapminsize) fopen = #110; /* Part of FRIK_FILE*/
void(filestream fhandle) fclose = #111; /* Part of FRIK_FILE*/
string(filestream fhandle) fgets = #112; /* Part of FRIK_FILE*/
void(filestream fhandle, string s, optional string s2, optional string s3, optional string s4, optional string s5, optional string s6, optional string s7) fputs = #113; /* Part of FRIK_FILE*/
float(string s) strlen = #114; /* Part of FRIK_FILE, FTE_STRINGS, ZQ_QC_STRINGS*/
string(string s1, optional string s2, ...) strcat = #115; /* Part of FRIK_FILE, FTE_STRINGS, ZQ_QC_STRINGS*/
string(string s, float start, float length) substring = #116; /* Part of FRIK_FILE, FTE_STRINGS, ZQ_QC_STRINGS*/
vector(string s) stov = #117; /* Part of FRIK_FILE, FTE_STRINGS, ZQ_QC_STRINGS*/
string(string s, ...) strzone = #118; /* Part of FRIK_FILE, FTE_STRINGS, ZQ_QC_STRINGS*/
void(string s) strunzone = #119; /* Part of FRIK_FILE, FTE_STRINGS, ZQ_QC_STRINGS*/
#endif
#ifdef SSQC
void(string cvar, float val) cvar_setf = #176;
#endif
#if defined(CSQC) || defined(SSQC)
float(string modelname, optional float queryonly) getmodelindex = #200; /*
		Acts as an alternative to precache_model(foo);setmodel(bar, foo); return bar.modelindex;
		If queryonly is set and the model was not previously precached, the builtin will return 0 without needlessly precaching the model. */

__variant(float prnum, string funcname, ...) externcall = #201; /* Part of FTE_MULTIPROGS
		Directly call a function in a different/same progs by its name.
		prnum=0 is the 'default' or 'main' progs.
		prnum=-1 means current progs.
		prnum=-2 will scan through the active progs and will use the first it finds. */

float(string progsname) addprogs = #202; /* Part of FTE_MULTIPROGS
		Loads an additional .dat file into the current qcvm. The returned handle can be used with any of the externcall/externset/externvalue builtins.
		There are cvars that allow progs to be loaded automatically. */

__variant(float prnum, string varname) externvalue = #203; /* Part of FTE_MULTIPROGS
		Reads a global in the named progs by the name of that global.
		prnum=0 is the 'default' or 'main' progs.
		prnum=-1 means current progs.
		prnum=-2 will scan through the active progs and will use the first it finds. */

void(float prnum, __variant newval, string varname) externset = #204; /* Part of FTE_MULTIPROGS
		Sets a global in the named progs by name.
		prnum=0 is the 'default' or 'main' progs.
		prnum=-1 means current progs.
		prnum=-2 will scan through the active progs and will use the first it finds. */

float(string input, string token) instr = #206; /* Part of FTE_MULTIPROGS
		Returns substring(input, strstrpos(input, token), -1), or the null string if token was not found in input. You're probably better off using strstrpos. */

void(entity portal, float state) openportal = #207; /*
		Opens or closes the portals associated with a door or some such on q2 or q3 maps. On Q2BSPs, the entity should be the 'func_areaportal' entity - its style field will say which portal to open. On Q3BSPs, the entity is the door itself, the portal will be determined by the two areas found from a preceding setorigin call. */

#endif
#ifdef SSQC
float(float attributes, string effectname, ...) RegisterTempEnt = #208; /* Part of FTE_PEXT_CUSTOMTENTS*/
void(float type, vector pos, ...) CustomTempEnt = #209; /* Part of FTE_PEXT_CUSTOMTENTS*/
float(optional float sleeptime) fork = #210; /* Part of FTE_MULTITHREADED
		When called, this builtin simply returns. Twice.
		The current 'thread' will return instantly with a return value of 0. The new 'thread' will return after sleeptime seconds with a return value of 1. See documentation for the 'sleep' builtin for limitations/requirements concerning the new thread. Note that QC should probably call abort in the new thread, as otherwise the function will return to the calling qc function twice also. */

#endif
void(optional __variant ret) abort = #211; /* Part of FTE_MULTITHREADED
		QC execution is aborted. Parent QC functions on the stack will be skipped, effectively this forces all QC functions to 'return ret' until execution returns to the engine. If ret is ommited, it is assumed to be 0. */

#ifdef SSQC
void(float sleeptime) sleep = #212; /* Part of FTE_MULTITHREADED
		Suspends the current QC execution thread for 'sleeptime' seconds.
		Other QC functions can and will be executed in the interim, including changing globals and field state (but not simultaneously).
		The self and other globals will be restored when the thread wakes up (or set to world if they were removed since the thread started sleeping). Locals will be preserved, but will not be protected from remove calls.
		If the engine is expecting the QC to return a value (even in the parent/root function), the value 0 shall be used instead of waiting for the qc to resume. */

void(entity player, string key, string value) forceinfokey = #213; /* Part of FTE_FORCEINFOKEY
		Directly changes a user's info without pinging off the client. Also allows explicitly setting * keys, including *spectator. Does not affect the user's config or other servers. */

void(string filename, float starttag, entity edict) chat = #214; /* Part of FTE_NPCCHAT*/
#endif
#if defined(CSQC) || defined(SSQC)
void(vector org, vector dmin, vector dmax, float colour, float effect, float count) particle2 = #215; /* Part of FTE_HEXEN2*/
void(vector org, vector box, float colour, float effect, float count) particle3 = #216; /* Part of FTE_HEXEN2*/
void(vector org, float radius, float colour, float effect, float count) particle4 = #217; /* Part of FTE_HEXEN2*/
float(float number, float quantity) bitshift = #218; /* Part of EXT_BITSHIFT*/
void(vector pos) te_lightningblood = #219; /* Part of FTE_TE_STANDARDEFFECTBUILTINS*/
#endif
float(string s1, string sub, optional float startidx) strstrofs = #221; /* Part of FTE_STRINGS
		Returns the 0-based offset of sub within the s1 string, or -1 if sub is not in s1.
		If startidx is set, this builtin will ignore matches before that 0-based offset. */

float(string str, float index) str2chr = #222; /* Part of FTE_STRINGS
		Retrieves the character value at offset 'index'. */

string(float chr, ...) chr2str = #223; /* Part of FTE_STRINGS
		The input floats are considered character values, and are concatenated. */

string(float ccase, float redalpha, float redchars, string str, ...) strconv = #224; /* Part of FTE_STRINGS
		Converts quake chars in the input string amongst different representations.
		ccase specifies the new case for letters.
		 0: not changed.
		 1: forced to lower case.
		 2: forced to upper case.
		redalpha and redchars switch between colour ranges.
		 0: no change.
		 1: Forced white.
		 2: Forced red.
		 3: Forced gold(low) (numbers only).
		 4: Forced gold (high) (numbers only).
		 5+6: Forced to white and red alternately.
		You should not use this builtin in combination with UTF-8. */

string(float pad, string str1, ...) strpad = #225; /* Part of FTE_STRINGS
		Pads the string with spaces, to ensure its a specific length (so long as a fixed-width font is used, anyway). If pad is negative, the spaces are added on the left. If positive the padding is on the right. */

string(infostring old, string key, string value) infoadd = #226; /* Part of FTE_STRINGS
		Returns a new tempstring infostring with the named value changed (or added if it was previously unspecified). Key and value may not contain the \ character. */

string(infostring info, string key) infoget = #227; /* Part of FTE_STRINGS
		Reads a named value from an infostring. The returned value is a tempstring */

#define strcmp strncmp
float(string s1, string s2, optional float len, optional float s1ofs, optional float s2ofs) strncmp = #228; /* Part of FTE_STRINGS
		Compares up to 'len' chars in the two strings. s1ofs allows you to treat s2 as a substring to compare against, or should be 0.
		Returns 0 if the two strings are equal, a negative value if s1 appears numerically lower, and positive if s1 appears numerically higher. */

float(string s1, string s2) strcasecmp = #229; /* Part of FTE_STRINGS
		Compares the two strings without case sensitivity.
		Returns 0 if they are equal. The sign of the return value may be significant, but should not be depended upon. */

float(string s1, string s2, float len, optional float s1ofs, optional float s2ofs) strncasecmp = #230; /* Part of FTE_STRINGS
		Compares up to 'len' chars in the two strings without case sensitivity. s1ofs allows you to treat s2 as a substring to compare against, or should be 0.
		Returns 0 if they are equal. The sign of the return value may be significant, but should not be depended upon. */

#if defined(CSQC) || defined(SSQC)
void() calltimeofday = #231; /* Part of FTE_CALLTIMEOFDAY
		Asks the engine to instantly call the qc's 'timeofday' function, before returning. For compatibility with mvdsv.
		timeofday should have the prototype: void(float secs, float mins, float hour, float day, float mon, float year, string strvalue)
		The strftime builtin is more versatile and less weird. */

#endif
#ifdef SSQC
void(float num, float type, .__variant fld) clientstat = #232; /*
		Specifies what data to use in order to send various stats, in a client-specific way.
		'num' should be a value between 32 and 127, other values are reserved.
		'type' must be set to one of the EV_* constants, one of EV_FLOAT, EV_STRING, EV_INTEGER, EV_ENTITY.
		fld must be a reference to the field used, each player will be sent only their own copy of these fields. */

void(float num, float type, string name) globalstat = #233; /*
		Specifies what data to use in order to send various stats, in a non-client-specific way. num and type are as in clientstat, name however, is the name of the global to read in the form of a string. */

float(entity player) isbackbuffered = #234; /* Part of FTE_ISBACKBUFFERED
		Returns if the given player's network buffer will take multiple network frames in order to clear. If this builtin returns non-zero, you should delay or reduce the amount of reliable (and also unreliable) data that you are sending to that client. */

#endif
#if defined(CSQC) || defined(SSQC)
void(vector angle) rotatevectorsbyangle = #235;
void(vector fwd, vector right, vector up) rotatevectorsbyvectors = #236;
float(float mdlindex, string skinname) skinforname = #237;
#endif
#if defined(CSQC) || defined(MENU)
float(string shadername, optional string defaultshader, ...) shaderforname = #238; /* Part of FTE_FORCESHADER
		Caches the named shader and returns a handle to it.
		If the shader could not be loaded from disk (missing file or ruleset_allow_shaders 0), it will be created from the 'defaultshader' string if specified, or a 'skin shader' default will be used.
		defaultshader if not empty should include the outer {} that you would ordinarily find in a shader. */

#endif
#if defined(CSQC) || defined(SSQC)
void(vector org, optional float count) te_bloodqw = #239; /* Part of FTE_TE_STANDARDEFFECTBUILTINS*/
float(vector viewpos, entity entity) checkpvs = #240; /* Part of FTE_QC_CHECKPVS*/
#endif
#ifdef SSQC
entity(string match, optional float matchnum) matchclientname = #241; /* Part of FTE_QC_MATCHCLIENTNAME*/
void(string dest, string content) sendpacket = #242; /* Part of FTE_QC_SENDPACKET*/
#endif
#ifdef CSQC
vector(entity ent, float tagnum) rotatevectorsbytag = #244;
#endif
#ifdef SSQC
float(optional string host, optional string user, optional string pass, optional string defaultdb, optional string driver) sqlconnect = #250; /* Part of FTE_SQL*/
void(float serveridx) sqldisconnect = #251; /* Part of FTE_SQL*/
float(float serveridx, void(float serveridx, float queryidx, float rows, float columns, float eof, float firstrow) callback, float querytype, string query) sqlopenquery = #252; /* Part of FTE_SQL*/
void(float serveridx, float queryidx) sqlclosequery = #253; /* Part of FTE_SQL*/
string(float serveridx, float queryidx, float row, float column) sqlreadfield = #254; /* Part of FTE_SQL*/
string(float serveridx, optional float queryidx) sqlerror = #255; /* Part of FTE_SQL*/
string(float serveridx, string data) sqlescape = #256; /* Part of FTE_SQL*/
string(float serveridx) sqlversion = #257; /* Part of FTE_SQL*/
float(float serveridx, float queryidx, float row, float column) sqlreadfloat = #258; /* Part of FTE_SQL*/
#endif
#if defined(CSQC) || defined(SSQC)
int(string) stoi = #259; /* Part of FTE_QC_INTCONV
		Converts the given string into an integer. Base 8, 10, or 16 is determined based upon the format of the string. */

string(int) itos = #260; /* Part of FTE_QC_INTCONV
		Converts the passed integer into a base10 string. */

int(string) stoh = #261; /* Part of FTE_QC_INTCONV
		Reads a base-16 string (with or without 0x prefix) as an integer. Bugs out if given a base 8 or base 10 string. :P */

string(int) htos = #262; /* Part of FTE_QC_INTCONV
		Formats an integer as a base16 string, with leading 0s and no prefix. Always returns 8 characters. */

float(float modlindex, optional float useabstransforms) skel_create = #263; /* Part of FTE_CSQC_SKELETONOBJECTS
		Allocates a new uninitiaised skeletal object, with enough bone info to animate the given model.
		eg: self.skeletonobject = skel_create(self.modelindex); */

float(float skel, entity ent, float modelindex, float retainfrac, float firstbone, float lastbone, optional float addfrac) skel_build = #264; /* Part of FTE_CSQC_SKELETONOBJECTS
		Animation data (according to the entity's frame info) is pulled from the specified model and blended into the specified skeletal object.
		If retainfrac is set to 0 on the first call and 1 on the others, you can blend multiple animations together according to the addfrac value. The final weight should be 1. Other values will result in scaling and/or other weirdness. You can use firstbone and lastbone to update only part of the skeletal object, to allow legs to animate separately from torso, use 0 for both arguments to specify all, as bones are 1-based. */

float(float skel) skel_get_numbones = #265; /* Part of FTE_CSQC_SKELETONOBJECTS
		Retrives the number of bones in the model. The valid range is 1<=bone<=numbones. */

string(float skel, float bonenum) skel_get_bonename = #266; /* Part of FTE_CSQC_SKELETONOBJECTS
		Retrieves the name of the specified bone. Mostly only for debugging. */

float(float skel, float bonenum) skel_get_boneparent = #267; /* Part of FTE_CSQC_SKELETONOBJECTS
		Retrieves which bone this bone's position is relative to. Bone 0 refers to the entity's position rather than an actual bone */

float(float skel, string tagname) skel_find_bone = #268; /* Part of FTE_CSQC_SKELETONOBJECTS
		Finds a bone by its name, from the model that was used to create the skeletal object. */

vector(float skel, float bonenum) skel_get_bonerel = #269; /* Part of FTE_CSQC_SKELETONOBJECTS
		Gets the bone position and orientation relative to the bone's parent. Return value is the offset, and v_forward, v_right, v_up contain the orientation. */

vector(float skel, float bonenum) skel_get_boneabs = #270; /* Part of FTE_CSQC_SKELETONOBJECTS
		Gets the bone position and orientation relative to the entity. Return value is the offset, and v_forward, v_right, v_up contain the orientation.
		Use gettaginfo for world coord+orientation. */

void(float skel, float bonenum, vector org, optional vector fwd, optional vector right, optional vector up) skel_set_bone = #271; /* Part of FTE_CSQC_SKELETONOBJECTS
		Sets a bone position relative to its parent. If the orientation arguments are not specified, v_forward+v_right+v_up are used instead. */

void(float skel, float bonenum, vector org, optional vector fwd, optional vector right, optional vector up) skel_mul_bone = #272; /* Part of FTE_CSQC_SKELETONOBJECTS
		Transforms a single bone by a matrix. You can use makevectors to generate a rotation matrix from an angle. */

void(float skel, float startbone, float endbone, vector org, optional vector fwd, optional vector right, optional vector up) skel_mul_bones = #273; /* Part of FTE_CSQC_SKELETONOBJECTS
		Transforms an entire consecutive range of bones by a matrix. You can use makevectors to generate a rotation matrix from an angle, but you'll probably want to divide the angle by the number of bones. */

void(float skeldst, float skelsrc, float startbone, float entbone) skel_copybones = #274; /* Part of FTE_CSQC_SKELETONOBJECTS
		Copy bone data from one skeleton directly into another. */

void(float skel) skel_delete = #275; /* Part of FTE_CSQC_SKELETONOBJECTS
		Deletes a skeletal object. The actual delete is delayed, allowing the skeletal object to be deleted in an entity's predraw function yet still be valid by the time the addentity+renderscene builtins need it. Also uninstanciates any ragdoll currently in effect on the skeletal object. */

float(float modidx, string framename) frameforname = #276; /* Part of FTE_CSQC_SKELETONOBJECTS
		Looks up a framegroup from a model by name, avoiding the need for hardcoding. Returns -1 on error. */

float(float modidx, float framenum) frameduration = #277; /* Part of FTE_CSQC_SKELETONOBJECTS
		Retrieves the duration (in seconds) of the specified framegroup. */

void(float action, optional vector pos, optional float radius, optional float quant, ...) terrain_edit = #278; /*
		Realtime terrain editing. Actions are the TEREDIT_ constants. */

void() touchtriggers = #279; /*
		Triggers a touch events between self and every entity that it is in contact with. This should typically just be the triggers touch functions. */

#endif
#ifdef SSQC
void(float buf, float fl) writefloat = #280;
#endif
#if defined(CSQC) || defined(SSQC)
float(entity skelent, string dollcmd, float animskel) skel_ragupdate = #281; /*
		Updates the skeletal object attached to the entity according to its origin and other properties.
		if animskel is non-zero, the ragdoll will animate towards the bone state in the animskel skeletal object, otherwise they will pick up the model's base pose which may not give nice results.
		If dollcmd is not set, the ragdoll will update (this should be done each frame).
		If the doll is updated without having a valid doll, the model's default .doll will be instanciated.
		commands:
		 doll foo.doll : sets up the entity to use the named doll file
		 dollstring TEXT : uses the doll file directly embedded within qc, with that extra prefix.
		 cleardoll : uninstanciates the doll without destroying the skeletal object.
		 animate 0.5 : specifies the strength of the ragdoll as a whole 
		 animatebody somebody 0.5 : specifies the strength of the ragdoll on a specific body (0 will disable ragdoll animations on that body).
		 enablejoint somejoint 1 : enables (or disables) a joint. Disabling joints will allow the doll to shatter. */

float*(float skel) skel_mmap = #282; /*
		Map the bones in VM memory. They can then be accessed via pointers. Each bone is 12 floats, the four vectors interleaved (sadly). */

void(entity ent, float bonenum, vector org, optional vector angorfwd, optional vector right, optional vector up) skel_set_bone_world = #283; /*
		Sets the world position of a bone within the given entity's attached skeletal object. The world position is dependant upon the owning entity's position. If no orientation argument is specified, v_forward+v_right+v_up are used for the orientation instead. If 1 is specified, it is understood as angles. If 3 are specified, they are the forawrd/right/up vectors to use. */

string(float modidx, float framenum) frametoname = #284;
string(float modidx, float skin) skintoname = #285;
float(float resourcetype, float tryload, string resourcename) resourcestatus = #286; /*
		resourcetype must be one of the RESTYPE_ constants. Returns one of the RESSTATE_ constants. Tryload 0 is a query only. Tryload 1 will attempt to reload the content if it was flushed. */

#endif
hashtable(float tabsize, optional float defaulttype) hash_createtab = #287; /* Part of FTE_QC_HASHTABLES
		Creates a hash table object with at least 'tabsize' slots. hash table with index 0 is a game-persistant table and will NEVER be returned by this builtin (except as an error return). */

void(hashtable table) hash_destroytab = #288; /* Part of FTE_QC_HASHTABLES
		Destroys a hash table object. */

void(hashtable table, string name, __variant value, optional float typeandflags) hash_add = #289; /* Part of FTE_QC_HASHTABLES
		Adds the given key with the given value to the table.
		If flags&HASH_REPLACE, the old value will be removed, if not set then multiple values may be added for a single key, they won't overwrite.
		The type argument describes how the value should be stored and saved to files. While you can claim that all variables are just vectors, being more precise can result in less issues with tempstrings or saved games. */

__variant(hashtable table, string name, optional __variant deflt, optional float requiretype, optional float index) hash_get = #290; /* Part of FTE_QC_HASHTABLES
		looks up the specified key name in the hash table. returns deflt if key was not found. If stringsonly=1, the return value will be in the form of a tempstring, otherwise it'll be the original value argument exactly as it was. If requiretype is specified, then values not of the specified type will be ignored. Hurrah for multiple types with the same name. */

__variant(hashtable table, string name) hash_delete = #291; /* Part of FTE_QC_HASHTABLES
		removes the named key. returns the value of the object that was destroyed, or 0 on error. */

string(hashtable table, float idx) hash_getkey = #292; /* Part of FTE_QC_HASHTABLES
		gets some random key name. add+delete can change return values of this, so don't blindly increment the key index if you're removing all. */

float(string name) checkcommand = #294; /* Part of FTE_QC_CHECKCOMMAND
		Checks to see if the supplied name is a valid command, cvar, or alias. Returns 0 if it does not exist. */

string(string s) argescape = #295; /*
		Marks up a string so that it can be reliably tokenized as a single argument later. */

#ifdef SSQC
void(string dest, string from, string cmd, string info) clusterevent = #296; /*
		Only functions in mapcluster mode. Sends an event to whichever server the named player is on. The destination server can then dispatch the event to the client or handle it itself via the SV_ParseClusterEvent entrypoint. If dest is empty, the event is broadcast to ALL servers. If the named player can't be found, the event will be returned to this server with the cmd prefixed with 'error:'. */

#endif
#if defined(CSQC) || defined(MENU)
void() clearscene = #300; /*
		Forgets all rentities, polygons, and temporary dlights. Resets all view properties to their default values. */

#endif
#ifdef CSQC
void(float mask) addentities = #301; /*
		Walks through all entities effectively doing this:
		 if (ent.drawmask&mask){ ent.predaw(); if (wasremoved(ent)||(ent.renderflags&RF_NOAUTOADD))continue; addentity(ent); }
		If mask&MASK_DELTA, non-csqc entities, particles, and related effects will also be added to the rentity list.
		 If mask&MASK_STDVIEWMODEL then the default view model will also be added. */

#endif
#if defined(CSQC) || defined(MENU)
void(entity ent) addentity = #302; /*
		Copies the entity fields into a new rentity for later rendering via addscene. */

#define setviewprop setproperty
float(float property, ...) setproperty = #303; /*
		Allows you to override default view properties like viewport, fov, and whether the engine hud will be drawn. Different VF_ values have slightly different arguments, some are vectors, some floats. */

void() renderscene = #304; /*
		Draws all entities, polygons, and particles on the rentity list (which were added via addentities or addentity), using the various view properties set via setproperty. There is no ordering dependancy.
		The scene must generally be cleared again before more entities are added, as entities will persist even over to the next frame.
		You may call this builtin multiple times per frame, but should only be called from CSQC_UpdateView. */

#endif
#ifdef CSQC
float(vector org, float radius, vector lightcolours, optional float style, optional string cubemapname, optional float pflags) dynamiclight_add = #305; /*
		Adds a temporary dlight, ready to be drawn via addscene. Cubemap orientation will be read from v_forward/v_right/v_up. */

#endif
void(string texturename, optional float flags) R_BeginPolygon = #306; /*
		Specifies the shader to use for the following polygons, along with optional flags.
		If flags&4, the polygon will be drawn as soon as the EndPolygon call is made, rather than waiting for renderscene. This allows complex 2d effects. */

void(vector org, vector texcoords, vector rgb, float alpha) R_PolygonVertex = #307; /*
		Specifies a polygon vertex with its various properties. */

void() R_EndPolygon = #308; /*
		Ends the current polygon. At least 3 verticies must have been specified. You do not need to call beginpolygon if you wish to draw another polygon with the same shader. */

#if defined(CSQC) || defined(MENU)
#define getviewprop getproperty
__variant(float property) getproperty = #309; /*
		Retrieve a currently-set (typically view) property, allowing you to read the current viewport or other things. Due to cheat protection, certain values may be unretrievable. */

#endif
#ifdef CSQC
vector (vector v) unproject = #310; /*
		Transform a 2d screen-space point (with depth) into a 3d world-space point, according the various origin+angle+fov etc settings set via setproperty. */

vector (vector v) project = #311; /*
		Transform a 3d world-space point into a 2d screen-space point, according the various origin+angle+fov etc settings set via setproperty. */

void(float width, vector pos1, vector pos2, vector rgb, float alpha, optional float drawflag) drawline = #315; /*
		Draws a 2d line between the two 2d points. */

float(string name) iscachedpic = #316; /*
		Checks to see if the image is currently loaded. Engines might lie, or cache between maps. */

string(string name, optional float trywad) precache_pic = #317; /*
		Forces the engine to load the named image. If trywad is specified, the specified name must any lack path and extension. */

#define draw_getimagesize drawgetimagesize
vector(string picname) drawgetimagesize = #318; /*
		Returns the dimensions of the named image. Images specified with .lmp should give the original .lmp's dimensions even if texture replacements use a different resolution. */

void(string name) freepic = #319; /*
		Tells the engine that the image is no longer needed. The image will appear to be new the next time its needed. */

float(vector position, float character, vector size, vector rgb, float alpha, optional float drawflag) drawcharacter = #320; /*
		Draw the given quake character at the given position.
		If flag&4, the function will consider the char to be a unicode char instead (or display as a ? if outside the 32-127 range).
		size should normally be something like '8 8 0'.
		rgb should normally be '1 1 1'
		alpha normally 1.
		Software engines may assume the named defaults.
		Note that ALL text may be rescaled on the X axis due to variable width fonts. The X axis may even be ignored completely. */

float(vector position, string text, vector size, vector rgb, float alpha, optional float drawflag) drawrawstring = #321; /*
		Draws the specified string without using any markup at all, even in engines that support it.
		If UTF-8 is globally enabled in the engine, then that encoding is used (without additional markup), otherwise it is raw quake chars.
		Software engines may assume a size of '8 8 0', rgb='1 1 1', alpha=1, flag&3=0, but it is not an error to draw out of the screen. */

float(vector position, string pic, vector size, vector rgb, float alpha, optional float drawflag) drawpic = #322; /*
		Draws an shader within the given 2d screen box. Software engines may omit support for rgb+alpha, but must support rescaling, and must clip to the screen without crashing. */

float(vector position, vector size, vector rgb, float alpha, optional float drawflag) drawfill = #323; /*
		Draws a solid block over the given 2d box, with given colour, alpha, and blend mode (specified via flags).
		flags&3=0 simple blend.
		flags&3=1 additive blend */

void(float x, float y, float width, float height) drawsetcliparea = #324; /*
		Specifies a 2d clipping region (aka: scissor test). 2d draw calls will all be clipped to this 2d box, the area outside will not be modified by any 2d draw call (even 2d polygons). */

void(void) drawresetcliparea = #325; /*
		Reverts the scissor/clip area to the whole screen. */

float(vector position, string text, vector size, vector rgb, float alpha, float drawflag) drawstring = #326; /*
		Draws a string, interpreting markup and recolouring as appropriate. */

float(string text, float usecolours, optional vector fontsize) stringwidth = #327; /*
		Calculates the width of the screen in virtual pixels. If usecolours is 1, markup that does not affect the string width will be ignored. Will always be decoded as UTF-8 if UTF-8 is globally enabled.
		If the char size is not specified, '8 8 0' will be assumed. */

void(vector pos, vector sz, string pic, vector srcpos, vector srcsz, vector rgb, float alpha, optional float drawflag) drawsubpic = #328; /*
		Draws a rescaled subsection of an image to the screen. */

float(float stnum) getstati = #330; /*
		Retrieves the numerical value of the given EV_INTEGER or EV_ENTITY stat (converted to a float). */

#define getstatbits getstatf
float(float stnum, optional float firstbit, optional float bitcount) getstatf = #331; /*
		Retrieves the numerical value of the given EV_FLOAT stat. If firstbit and bitcount are specified, retrieves the upper bits of the STAT_ITEMS stat. */

string(float firststnum) getstats = #332; /*
		Retrieves the value of the given EV_STRING stat, as a tempstring.
		Older engines may use 4 consecutive integer stats, with a limit of 15 chars (yes, really. 15.), but FTE QuakeWorld uses a separate namespace for string stats and has a much higher length limit. */

void(entity e, float mdlindex) setmodelindex = #333; /*
		Sets a model by precache index instead of by name. Otherwise identical to setmodel. */

string(float mdlindex) modelnameforindex = #334; /*
		Retrieves the name of the model based upon a precache index. This can be used to reduce csqc network traffic by enabling model matching. */

#endif
#if defined(CSQC) || defined(SSQC)
float(string effectname) particleeffectnum = #335; /*
		Precaches the named particle effect. If your effect name is of the form 'foo.bar' then particles/foo.cfg will be loaded by the client if foo.bar was not already defined.
		Different engines will have different particle systems, this specifies the QC API only. */

void(float effectnum, entity ent, vector start, vector end) trailparticles = #336; /*
		Draws the given effect between the two named points. If ent is not world, distances will be cached in the entity in order to avoid framerate dependancies. The entity is not otherwise used. */

void(float effectnum, vector origin, optional vector dir, optional float count) pointparticles = #337; /*
		Spawn a load of particles from the given effect at the given point traveling or aiming along the direction specified. The number of particles are scaled by the count argument. */

#endif
#ifdef CSQC
void(string s, ...) cprint = #338; /*
		Print into the center of the screen just as ssqc's centerprint would appear. */

#endif
#if defined(CSQC) || defined(SSQC)
void(string s, ...) print = #339; /*
		Unconditionally print on the local system's console, even in ssqc (doesn't care about the value of the developer cvar). */

#endif
#ifdef CSQC
string(float keynum) keynumtostring = #340; /*
		Returns a hunam-readable name for the given keycode, as a tempstring. */

#endif
#ifdef MENU
string(float keynum) keynumtostring_csqc = #340; /*
		Returns a hunam-readable name for the given keycode, as a tempstring. */

#endif
#ifdef CSQC
float(string keyname) stringtokeynum = #341; /*
		Looks up the key name in the same way that the bind command would, returning the keycode for that key. */

#endif
#ifdef MENU
float(string keyname) stringtokeynum_csqc = #341; /*
		Looks up the key name in the same way that the bind command would, returning the keycode for that key. */

#endif
#if defined(CSQC) || defined(MENU)
string(float keynum) getkeybind = #342; /*
		Finds the current binding for the given key (ignores modifiers like shift/alt/ctrl). */

#endif
#ifdef CSQC
void(float usecursor, optional string cursorimage, optional vector hotspot, optional float scale) setcursormode = #343; /*
		Pass TRUE if you want the engine to release the mouse cursor (absolute input events + touchscreen mode). Pass FALSE if you want the engine to grab the cursor (relative input events + standard looking). If the image name is specified, the engine will use that image for a cursor (use an empty string to clear it again), in a way that will not conflict with the console. Images specified this way will be hardware accelerated, if supported by the platform/port. */

vector() getmousepos = #344; /*
		Nasty convoluted DP extension. Typically returns deltas instead of positions. Use CSQC_InputEvent for such things in csqc mods. */

float(float inputsequencenum) getinputstate = #345; /*
		Looks up an input frame from the log, setting the input_* globals accordingly.
		The sequence number range used for prediction should normally be servercommandframe < sequence <= clientcommandframe.
		The sequence equal to clientcommandframe will change between input frames. */

void(float sens) setsensitivityscaler = #346; /*
		Temporarily scales the player's mouse sensitivity based upon something like zoom, avoiding potential cvar saving and thus corruption. */

#endif
#if defined(CSQC) || defined(SSQC)
void(entity ent) runstandardplayerphysics = #347; /*
		Perform the engine's standard player movement prediction upon the given entity using the input_* globals to describe movement. */

#endif
#ifdef CSQC
string(float playernum, string keyname) getplayerkeyvalue = #348; /*
		Look up a player's userinfo, to discover things like their name, topcolor, bottomcolor, skin, team, *ver.
		Also includes scoreboard info like frags, ping, pl, userid, entertime, as well as voipspeaking and voiploudness. */

#endif
#if defined(CSQC) || defined(MENU)
float() isdemo = #349; /*
		Returns if the client is currently playing a demo or not */

#endif
#ifdef CSQC
float() isserver = #350; /*
		Returns if the client is acting as the server (aka: listen server) */

void(vector origin, vector forward, vector right, vector up, optional float inwater) SetListener = #351; /*
		Sets the position of the view, as far as the audio subsystem is concerned. This should be called once per CSQC_UpdateView as it will otherwise revert to default. */

void(string cmdname) registercommand = #352; /*
		Register the given console command, for easy console use.
		Console commands that are later used will invoke CSQC_ConsoleCommand. */

#endif
#if defined(CSQC) || defined(SSQC)
float(entity ent) wasfreed = #353; /*
		Quickly check to see if the entity is currently free. This function is only valid during the two-second non-reuse window, after that it may give bad results. Try one second to make it more robust. */

#endif
#ifdef CSQC
string(string key) serverkey = #354; /*
		Look up a key in the server's public serverinfo string */

string(optional string resetstring) getentitytoken = #355; /*
		Grab the next token in the map's entity lump.
		If resetstring is not specified, the next token will be returned with no other sideeffects.
		If empty, will reset from the map before returning the first token, probably {.
		If not empty, will tokenize from that string instead.
		Always returns tempstrings. */

#endif
#if defined(CSQC) || defined(MENU)
float(string s) findfont = #356; /*
		Looks up a named font slot. Matches the actual font name as a last resort. */

float(string fontname, string fontmaps, string sizes, float slot, optional float fix_scale, optional float fix_voffset) loadfont = #357; /*
		too convoluted for me to even try to explain correct usage. Try drawfont = loadfont("foo", "cour", "16", 0, 0, 0); to switch to the courier font, if you have the freetype2 library in windows.. */

#endif
#ifdef CSQC
void(string evname, string evargs, ...) sendevent = #359; /*
		Invoke Cmd_evname_evargs in ssqc. evargs must be a string of initials refering to the types of the arguments to pass. v=vector, e=entity(.entnum field is sent), f=float, i=int. 6 arguments max - you can get more if you pack your floats into vectors. */

float() readbyte = #360;
float() readchar = #361;
float() readshort = #362;
float() readlong = #363;
float() readcoord = #364;
float() readangle = #365;
string() readstring = #366;
float() readfloat = #367;
float() readentitynum = #368;
float(string modelname, float(float isnew) updatecallback, float flags) deltalisten = #371; /*
		Specifies a per-modelindex callback to listen for engine-networking entity updates. Such entities are automatically interpolated by the engine (unless flags specifies not to).
		The various standard entity fields will be overwritten each frame before the updatecallback function is called. */

__variant(float lno, float fld) dynamiclight_get = #372; /*
		Retrieves a property from the given dynamic/rt light. Return type depends upon the light field requested. */

void(float lno, float fld, __variant value) dynamiclight_set = #373; /*
		Changes a property on the given dynamic/rt light. Value type depends upon the light field to be changed. */

string(float efnum, float body) particleeffectquery = #374; /*
		Retrieves either the name or the body of the effect with the given number. The effect body is regenerated from internal state, and can be changed before being reapplied via the localcmd builtin. */

void(string shadername, vector origin, vector up, vector side, vector rgb, float alpha) adddecal = #375; /*
		Adds a temporary clipped decal shader to the scene, centered at the given point with given orientation. Will be drawn by the next renderscene call, and freed by the next clearscene call. */

void(entity e, string skinfilename, optional string skindata) setcustomskin = #376; /*
		Sets an entity's skin overrides. These are custom per-entity surface->shader lookups. The skinfilename/data should be in .skin format:
		surfacename,shadername - makes the named surface use the named shader
		replace "surfacename" "shadername" - same.
		compose "surfacename" "shader" "imagename@x,y:w,h?r,g,b,a" - compose a skin texture from multiple images. The texture is determined to be sufficient to hold the first named image, additional images can be named as extra tokens on the same line. Use a + at the end of the line to continue reading image tokens from the next line also, the named shader must use 'map $diffuse' to read the composed texture (compatible with the defaultskin shader). */

#endif
__variant*(int size) memalloc = #384; /* Part of FTE_MEMALLOC
		Allocate an arbitary block of memory */

void(__variant *ptr) memfree = #385; /* Part of FTE_MEMALLOC
		Frees a block of memory that was allocated with memfree */

void(__variant *dst, __variant *src, int size) memcpy = #386; /* Part of FTE_MEMALLOC
		Copys memory from one location to another */

void(__variant *dst, int val, int size) memfill8 = #387; /* Part of FTE_MEMALLOC
		Sets an entire block of memory to a specified value. Pretty much always 0. */

__variant(__variant *dst, float ofs) memgetval = #388; /*
		Looks up the 32bit value stored at a pointer-with-offset. */

void(__variant *dst, float ofs, __variant val) memsetval = #389; /*
		Changes the 32bit value stored at the specified pointer-with-offset. */

__variant*(__variant *base, float ofs) memptradd = #390; /*
		Perform some pointer maths. Woo. */

#if defined(CSQC) || defined(MENU)
string(string conname, string field, optional string newvalue) con_getset = #391; /* Part of FTE_CSQC_ALTCONSOLES_WIP
		Reads or sets a property from a console object. The old value is returned. Iterrate through consoles with the 'next' field. Valid properties: 	title, name, next, unseen, markup, forceutf8, close, clear, hidden, linecount */

void(string conname, string messagefmt, ...) con_printf = #392; /* Part of FTE_CSQC_ALTCONSOLES_WIP
		Prints onto a named console. */

void(string conname, vector pos, vector size, float fontsize) con_draw = #393; /* Part of FTE_CSQC_ALTCONSOLES_WIP
		Draws the named console. */

float(string conname, float inevtype, float parama, float paramb, float paramc) con_input = #394; /* Part of FTE_CSQC_ALTCONSOLES_WIP
		Forwards input events to the named console. Mouse updates should be absolute only. */

#endif
#if defined(CSQC) || defined(SSQC)
void(entity from, entity to) copyentity = #400; /* Part of DP_QC_COPYENTITY*/
#endif
#ifdef SSQC
void(entity ent, float colours) setcolors = #401; /*
		Changes a player's colours. The bits 0-3 are the lower/trouser colour, bits 4-7 are the upper/shirt colours. */

#endif
#if defined(CSQC) || defined(SSQC)
entity(.string field, string match) findchain = #402; /* Part of DP_QC_FINDCHAIN*/
entity(.float fld, float match) findchainfloat = #403; /* Part of DP_QC_FINDCHAINFLOAT*/
void(vector org, string modelname, float startframe, float endframe, float framerate) effect = #404; /* Part of DP_SV_EFFECT
		Spawns a self-animating sprite */

void(vector org, vector dir, float count) te_blood = #405; /* Part of DP_TE_BLOOD*/
void(vector mincorner, vector maxcorner, float explosionspeed, float howmany) te_bloodshower = #406; /* Part of DP_TE_BLOODSHOWER*/
void(vector org, vector color) te_explosionrgb = #407; /* Part of DP_TE_EXPLOSIONRGB*/
void(vector mincorner, vector maxcorner, vector vel, float howmany, float color, float gravityflag, float randomveljitter) te_particlecube = #408; /* Part of DP_TE_PARTICLECUBE*/
void(vector mincorner, vector maxcorner, vector vel, float howmany, float color) te_particlerain = #409; /* Part of _DP_TE_PARTICLERAIN*/
void(vector mincorner, vector maxcorner, vector vel, float howmany, float color) te_particlesnow = #410; /* Part of _DP_TE_PARTICLESNOW*/
void(vector org, vector vel, float howmany) te_spark = #411; /* Part of DP_TE_SPARK*/
void(vector org) te_gunshotquad = #412; /* Part of _DP_TE_QUADEFFECTS1*/
void(vector org) te_spikequad = #413; /* Part of _DP_TE_QUADEFFECTS1*/
void(vector org) te_superspikequad = #414; /* Part of _DP_TE_QUADEFFECTS1*/
void(vector org) te_explosionquad = #415; /* Part of _DP_TE_QUADEFFECTS1*/
void(vector org) te_smallflash = #416; /* Part of DP_TE_SMALLFLASH*/
void(vector org, float radius, float lifetime, vector color) te_customflash = #417; /* Part of DP_TE_CUSTOMFLASH*/
void(vector org, optional float count) te_gunshot = #418; /* Part of DP_TE_STANDARDEFFECTBUILTINS, FTE_TE_STANDARDEFFECTBUILTINS*/
void(vector org) te_spike = #419; /* Part of DP_TE_STANDARDEFFECTBUILTINS, FTE_TE_STANDARDEFFECTBUILTINS*/
void(vector org) te_superspike = #420; /* Part of DP_TE_STANDARDEFFECTBUILTINS, FTE_TE_STANDARDEFFECTBUILTINS*/
void(vector org) te_explosion = #421; /* Part of DP_TE_STANDARDEFFECTBUILTINS, FTE_TE_STANDARDEFFECTBUILTINS*/
void(vector org) te_tarexplosion = #422; /* Part of DP_TE_STANDARDEFFECTBUILTINS, FTE_TE_STANDARDEFFECTBUILTINS*/
void(vector org) te_wizspike = #423; /* Part of DP_TE_STANDARDEFFECTBUILTINS, FTE_TE_STANDARDEFFECTBUILTINS*/
void(vector org) te_knightspike = #424; /* Part of DP_TE_STANDARDEFFECTBUILTINS, FTE_TE_STANDARDEFFECTBUILTINS*/
void(vector org) te_lavasplash = #425; /* Part of DP_TE_STANDARDEFFECTBUILTINS, FTE_TE_STANDARDEFFECTBUILTINS*/
void(vector org) te_teleport = #426; /* Part of DP_TE_STANDARDEFFECTBUILTINS, FTE_TE_STANDARDEFFECTBUILTINS*/
void(vector org, float color, float colorlength) te_explosion2 = #427; /* Part of DP_TE_STANDARDEFFECTBUILTINS*/
void(entity own, vector start, vector end) te_lightning1 = #428; /* Part of DP_TE_STANDARDEFFECTBUILTINS, FTE_TE_STANDARDEFFECTBUILTINS*/
void(entity own, vector start, vector end) te_lightning2 = #429; /* Part of DP_TE_STANDARDEFFECTBUILTINS, FTE_TE_STANDARDEFFECTBUILTINS*/
void(entity own, vector start, vector end) te_lightning3 = #430; /* Part of DP_TE_STANDARDEFFECTBUILTINS, FTE_TE_STANDARDEFFECTBUILTINS*/
void(entity own, vector start, vector end) te_beam = #431; /* Part of DP_TE_STANDARDEFFECTBUILTINS*/
void(vector dir) vectorvectors = #432; /* Part of DP_QC_VECTORVECTORS*/
void(vector org) te_plasmaburn = #433; /* Part of _DP_TE_PLASMABURN*/
float(entity e, float s) getsurfacenumpoints = #434; /* Part of DP_QC_GETSURFACE*/
vector(entity e, float s, float n) getsurfacepoint = #435; /* Part of DP_QC_GETSURFACE*/
vector(entity e, float s) getsurfacenormal = #436; /* Part of DP_QC_GETSURFACE*/
string(entity e, float s) getsurfacetexture = #437; /* Part of DP_QC_GETSURFACE*/
float(entity e, vector p) getsurfacenearpoint = #438; /* Part of DP_QC_GETSURFACE*/
vector(entity e, float s, vector p) getsurfaceclippedpoint = #439; /* Part of DP_QC_GETSURFACE*/
#endif
#ifdef MENU
strbuf() buf_create = #440; /* Part of DP_QC_STRINGBUFFERS*/
void(strbuf bufhandle) buf_del = #441; /* Part of DP_QC_STRINGBUFFERS*/
float(strbuf bufhandle) buf_getsize = #442; /* Part of DP_QC_STRINGBUFFERS*/
void(strbuf bufhandle_from, float bufhandle_to) buf_copy = #443; /* Part of DP_QC_STRINGBUFFERS*/
void(strbuf bufhandle, float sortprefixlen, float backward) buf_sort = #444; /* Part of DP_QC_STRINGBUFFERS*/
string(strbuf bufhandle, string glue) buf_implode = #445; /* Part of DP_QC_STRINGBUFFERS*/
string(strbuf bufhandle, float string_index) bufstr_get = #446; /* Part of DP_QC_STRINGBUFFERS*/
void(strbuf bufhandle, float string_index, string str) bufstr_set = #447; /* Part of DP_QC_STRINGBUFFERS*/
float(strbuf bufhandle, string str, float order) bufstr_add = #448; /* Part of DP_QC_STRINGBUFFERS*/
void(strbuf bufhandle, float string_index) bufstr_free = #449; /* Part of DP_QC_STRINGBUFFERS*/
float(string name) iscachedpic = #451;
string(string name, optional float trywad) precache_pic = #452;
//void(string name) freepic = #453;
float(vector position, float character, vector scale, vector rgb, float alpha, optional float flag) drawcharacter = #454;
float(vector position, string text, vector scale, vector rgb, float alpha, optional float flag) drawrawstring = #455;
float(vector position, string pic, vector size, vector rgb, float alpha, optional float flag) drawpic = #456;
float(vector position, vector size, vector rgb, float alpha, optional float flag) drawfill = #457;
void(float x, float y, float width, float height) drawsetcliparea = #458;
void(void) drawresetcliparea = #459;
vector(string picname) drawgetimagesize = #460;
//void(float width, vector pos1, vector pos2) drawline = #466;
float(vector position, string text, vector scale, vector rgb, float alpha, float flag) drawstring = #467;
float(string text, float usecolours, optional vector fontsize) stringwidth = #468;
void(vector pos, vector sz, string pic, vector srcpos, vector srcsz, vector rgb, float alpha, float flag) drawsubpic = #469;
#endif
#ifdef SSQC
void(entity e, string s) clientcommand = #440; /* Part of KRIMZON_SV_PARSECLIENTCOMMAND*/
#endif
#if defined(CSQC) || defined(SSQC)
float(string s) tokenize = #441; /* Part of KRIMZON_SV_PARSECLIENTCOMMAND*/
string(float n) argv = #442; /* Part of KRIMZON_SV_PARSECLIENTCOMMAND*/
void(entity e, entity tagentity, string tagname) setattachment = #443; /* Part of DP_GFX_QUAKE3MODELTAGS*/
searchhandle(string pattern, float caseinsensitive, float quiet) search_begin = #444; /* Part of DP_QC_FS_SEARCH
		initiate a filesystem scan based upon filenames. Be sure to call search_end on the returned handle. */

void(searchhandle handle) search_end = #445; /* Part of DP_QC_FS_SEARCH*/
float(searchhandle handle) search_getsize = #446; /* Part of DP_QC_FS_SEARCH
		Retrieves the number of files that were found. */

string(searchhandle handle, float num) search_getfilename = #447; /* Part of DP_QC_FS_SEARCH
		Retrieves name of one of the files that was found by the initial search. */

string(string cvarname) cvar_string = #448; /* Part of DP_QC_CVAR_STRING*/
entity(entity start, .float fld, float match) findflags = #449; /* Part of DP_QC_FINDFLAGS*/
entity(.float fld, float match) findchainflags = #450; /* Part of DP_QC_FINDCHAINFLAGS*/
float(entity ent, string tagname) gettagindex = #451; /* Part of DP_MD3_TAGSINFO*/
vector(entity ent, float tagindex) gettaginfo = #452; /* Part of DP_MD3_TAGSINFO
		Obtains the current worldspace position+orientation of the bone or tag from the given entity. The return value is the world coord, v_forward, v_right, v_up are also set according to the bone/tag's orientation. */

#endif
#ifdef SSQC
void(entity player) dropclient = #453; /* Part of DP_SV_DROPCLIENT*/
entity() spawnclient = #454; /* Part of DP_SV_BOTCLIENT*/
float(entity client) clienttype = #455; /* Part of DP_SV_BOTCLIENT*/
void(float target, string str) WriteUnterminatedString = #456; /* Part of DP_SV_WRITEUNTERMINATEDSTRING*/
#endif
#if defined(CSQC) || defined(SSQC)
entity(float entnum) edict_num = #459; /* Part of DP_QC_EDICT_NUM*/
strbuf() buf_create = #460; /* Part of DP_QC_STRINGBUFFERS*/
void(strbuf bufhandle) buf_del = #461; /* Part of DP_QC_STRINGBUFFERS*/
float(strbuf bufhandle) buf_getsize = #462; /* Part of DP_QC_STRINGBUFFERS*/
void(strbuf bufhandle_from, strbuf bufhandle_to) buf_copy = #463; /* Part of DP_QC_STRINGBUFFERS*/
void(strbuf bufhandle, float sortprefixlen, float backward) buf_sort = #464; /* Part of DP_QC_STRINGBUFFERS*/
string(strbuf bufhandle, string glue) buf_implode = #465; /* Part of DP_QC_STRINGBUFFERS*/
string(strbuf bufhandle, float string_index) bufstr_get = #466; /* Part of DP_QC_STRINGBUFFERS*/
void(strbuf bufhandle, float string_index, string str) bufstr_set = #467; /* Part of DP_QC_STRINGBUFFERS*/
float(strbuf bufhandle, string str, float order) bufstr_add = #468; /* Part of DP_QC_STRINGBUFFERS*/
void(strbuf bufhandle, float string_index) bufstr_free = #469; /* Part of DP_QC_STRINGBUFFERS*/
#endif
float(float s) asin = #471; /* Part of DP_QC_ASINACOSATANATAN2TAN*/
float(float c) acos = #472; /* Part of DP_QC_ASINACOSATANATAN2TAN*/
float(float t) atan = #473; /* Part of DP_QC_ASINACOSATANATAN2TAN*/
float(float c, float s) atan2 = #474; /* Part of DP_QC_ASINACOSATANATAN2TAN*/
float(float a) tan = #475; /* Part of DP_QC_ASINACOSATANATAN2TAN*/
float(string s) strlennocol = #476; /* Part of DP_QC_STRINGCOLORFUNCTIONS*/
string(string s) strdecolorize = #477; /* Part of DP_QC_STRINGCOLORFUNCTIONS*/
string(float uselocaltime, string format, ...) strftime = #478; /* Part of DP_QC_STRFTIME*/
float(string s, string separator1, ...) tokenizebyseparator = #479; /* Part of DP_QC_TOKENIZEBYSEPARATOR*/
string(string s) strtolower = #480; /* Part of DP_QC_STRING_CASE_FUNCTIONS*/
string(string s) strtoupper = #481; /* Part of DP_QC_STRING_CASE_FUNCTIONS*/
string(string s) cvar_defstring = #482; /* Part of DP_QC_CVAR_DEFSTRING*/
#if defined(CSQC) || defined(SSQC)
void(vector origin, string sample, float volume, float attenuation) pointsound = #483; /* Part of DP_SV_POINTSOUND*/
#endif
string(string search, string replace, string subject) strreplace = #484; /* Part of DP_QC_STRREPLACE*/
string(string search, string replace, string subject) strireplace = #485; /* Part of DP_QC_STRREPLACE*/
#if defined(CSQC) || defined(SSQC)
vector(entity e, float s, float n, float a) getsurfacepointattribute = #486; /* Part of DP_QC_GETSURFACEPOINTATTRIBUTE*/
#endif
#if defined(CSQC) || defined(MENU)
float(string name) gecko_create = #487; /* Part of DP_GECKO_SUPPORT*/
void(string name) gecko_destroy = #488; /* Part of DP_GECKO_SUPPORT*/
void(string name, string URI) gecko_navigate = #489; /* Part of DP_GECKO_SUPPORT*/
float(string name, float key, float eventtype) gecko_keyevent = #490; /* Part of DP_GECKO_SUPPORT*/
void(string name, float x, float y) gecko_mousemove = #491; /* Part of DP_GECKO_SUPPORT*/
void(string name, float w, float h) gecko_resize = #492; /* Part of DP_GECKO_SUPPORT*/
vector(string name) gecko_get_texture_extent = #493; /* Part of DP_GECKO_SUPPORT*/
#endif
float(float caseinsensitive, string s, ...) crc16 = #494; /* Part of DP_QC_CRC16*/
float(string name) cvar_type = #495; /* Part of DP_QC_CVAR_TYPE*/
float() numentityfields = #496; /* Part of DP_QC_ENTITYDATA*/
string(float fieldnum) entityfieldname = #497; /* Part of DP_QC_ENTITYDATA*/
float(float fieldnum) entityfieldtype = #498; /* Part of DP_QC_ENTITYDATA*/
string(float fieldnum, entity ent) getentityfieldstring = #499; /* Part of DP_QC_ENTITYDATA*/
float(float fieldnum, entity ent, string s) putentityfieldstring = #500; /* Part of DP_QC_ENTITYDATA*/
#ifdef CSQC
void(float effectindex, entity own, vector org_from, vector org_to, vector dir_from, vector dir_to, float countmultiplier, optional float flags) boxparticles = #502;
#endif
string(string filename, optional float makereferenced) whichpack = #503; /* Part of DP_QC_WHICHPACK
		Returns the pak file name that contains the file specified. progs/player.mdl will generally return something like 'pak0.pak'. If makereferenced is true, clients will automatically be told that the returned package should be pre-downloaded and used, even if allow_download_refpackages is not set. */

#ifdef CSQC
__variant(float entnum, float fieldnum) getentity = #504; /*
		Looks up fields from non-csqc-visible entities. The entity will need to be within the player's pvs. fieldnum should be one of the GE_ constants. */

#endif
string(string in) uri_escape = #510; /* Part of DP_QC_URI_ESCAPE*/
string(string in) uri_unescape = #511; /* Part of DP_QC_URI_ESCAPE*/
float(entity ent) num_for_edict = #512;
float(string uril, float id, optional string postmimetype, optional string postdata) uri_get = #513; /* Part of DP_QC_URI_GET
		uri_get() gets content from an URL and calls a callback "uri_get_callback" with it set as string; an unique ID of the transfer is returned
		returns 1 on success, and then calls the callback with the ID, 0 or the HTTP status code, and the received data in a string */

float(string str) tokenize_console = #514;
float(float idx) argv_start_index = #515;
float(float idx) argv_end_index = #516;
void(strbuf strbuf) buf_cvarlist = #517;
string(string cvarname) cvar_description = #518;
#if defined(CSQC) || defined(SSQC)
float(optional float timetype) gettime = #519;
#endif
#ifdef CSQC
string(float keynum) keynumtostring_omgwtf = #520;
string(string command, optional float bindmap) findkeysforcommand = #521;
#endif
#if defined(CSQC) || defined(SSQC)
void(string s) loadfromdata = #529; /*
		Reads a set of entities from the given string. This string should have the same format as a .ent file or a saved game. Entities will be spawned as required. If you need to see the entities that were created, you should use parseentitydata instead. */

void(string s) loadfromfile = #530; /*
		Reads a set of entities from the named file. This file should have the same format as a .ent file or a saved game. Entities will be spawned as required. If you need to see the entities that were created, you should use parseentitydata instead. */

#endif
#ifdef SSQC
float(string mname) precache_vwep_model = #532; /* Part of ZQ_VWEP*/
#endif
#ifdef CSQC
float(entity e, float channel) getsoundtime = #533;
#endif
#if defined(CSQC) || defined(MENU)
float(string sample) soundlength = #534;
#endif
float(string filename, strbuf bufhandle) buf_loadfile = #535;
float(filestream filehandle, strbuf bufhandle, optional float startpos, optional float numstrings) buf_writefile = #536;
#if defined(CSQC) || defined(SSQC)
void(entity e, float physics_enabled) physics_enable = #540; /*
		Enable or disable the physics attached to a MOVETYPE_PHYSICS entity. Entities which have been disabled in this way will stop taking so much cpu time. */

void(entity e, vector force, vector relative_ofs) physics_addforce = #541; /*
		Apply some impulse directional force upon a MOVETYPE_PHYSICS entity. */

void(entity e, vector torque) physics_addtorque = #542; /*
		Apply some impulse rotational force upon a MOVETYPE_PHYSICS entity. */

#endif
#ifdef MENU
void(float dest) setkeydest = #601;
float() getkeydest = #602;
#endif
#if defined(CSQC) || defined(MENU)
void(float trg) setmousetarget = #603;
float() getmousetarget = #604;
#endif
void(.../*, string funcname*/) callfunction = #605; /*
		Invokes the named function. The function name is always passed as the last parameter and must always be present. The others are passed to the named function as-is */

void(filestream fh, entity e) writetofile = #606; /*
		Writes an entity's fields to the named frik_file file handle. */

float(string s) isfunction = #607;
#if defined(CSQC) || defined(MENU)
vector(float vidmode, optional float forfullscreen) getresolution = #608;
#endif
#ifdef CSQC
string(float keynum) keynumtostring_menu = #609;
string(string command, optional float bindmap) findkeysforcommand_dp = #610;
#endif
#ifdef MENU
string(float keynum) keynumtostring = #609; /*
		Converts a qscancode key number into a mostly-human-readable name, matching the bind command. */

string(string command, optional float bindmap) findkeysforcommand = #610;
#endif
#if defined(CSQC) || defined(MENU)
float(float type) gethostcachevalue = #611; /* Part of FTE_CSQC_SERVERBROWSER*/
string(float type, float hostnr) gethostcachestring = #612; /* Part of FTE_CSQC_SERVERBROWSER*/
#endif
void(entity e, string s) parseentitydata = #613; /*
		Reads a single entity's fields into an already-spawned entity. s should contain field pairs like in a saved game: {"foo1" "bar" "foo2" "5"}  */

#ifdef MENU
float(string key) stringtokeynum = #614; /*
		Returns the qscancode of a key from its name. Names are identical to the bind command. ctrl/shift/alt modifiers are ignored. */

#endif
#ifdef CSQC
float(string key) stringtokeynum_menu = #614;
#endif
#if defined(CSQC) || defined(MENU)
void() resethostcachemasks = #615; /* Part of FTE_CSQC_SERVERBROWSER*/
void(float mask, float fld, string str, float op) sethostcachemaskstring = #616; /* Part of FTE_CSQC_SERVERBROWSER*/
void(float mask, float fld, float num, float op) sethostcachemasknumber = #617; /* Part of FTE_CSQC_SERVERBROWSER*/
void() resorthostcache = #618; /* Part of FTE_CSQC_SERVERBROWSER*/
void(float fld, float descending) sethostcachesort = #619; /* Part of FTE_CSQC_SERVERBROWSER*/
void() refreshhostcache = #620; /* Part of FTE_CSQC_SERVERBROWSER*/
float(float fld, float hostnr) gethostcachenumber = #621; /* Part of FTE_CSQC_SERVERBROWSER*/
float(string key) gethostcacheindexforkey = #622; /* Part of FTE_CSQC_SERVERBROWSER*/
void(string key) addwantedhostcachekey = #623; /* Part of FTE_CSQC_SERVERBROWSER*/
string() getextresponse = #624; /* Part of FTE_CSQC_SERVERBROWSER*/
#endif
string(string dnsname, optional float defport) netaddress_resolve = #625;
string(string fmt, ...) sprintf = #627;
#if defined(CSQC) || defined(SSQC)
float(entity e, float s) getsurfacenumtriangles = #628;
vector(entity e, float s, float n) getsurfacetriangle = #629;
#endif
string(string digest, string data, ...) digest_hex = #639;
#if defined(CSQC) || defined(MENU)
#define K_TAB	9
#define K_ENTER	13
#define K_ESCAPE	27
#define K_SPACE	32
#define K_BACKSPACE	127
#define K_UPARROW	128
#define K_DOWNARROW	129
#define K_LEFTARROW	130
#define K_RIGHTARROW	131
#define K_LALT	132
#define K_RALT	-245
#define K_LCTRL	133
#define K_RCTRL	-246
#define K_LSHIFT	134
#define K_RSHIFT	-247
#define K_F1	135
#define K_F2	136
#define K_F3	137
#define K_F4	138
#define K_F5	139
#define K_F6	140
#define K_F7	141
#define K_F8	142
#define K_F9	143
#define K_F10	144
#define K_F11	145
#define K_F12	146
#define K_INS	147
#define K_DEL	148
#define K_PGDN	149
#define K_PGUP	150
#define K_HOME	151
#define K_END	152
#define K_KP_HOME	164
#define K_KP_UPARROW	165
#define K_KP_PGUP	166
#define K_KP_LEFTARROW	161
#define K_KP_5	162
#define K_KP_RIGHTARROW	163
#define K_KP_END	158
#define K_KP_DOWNARROW	159
#define K_KP_PGDN	160
#define K_KP_ENTER	172
#define K_KP_INS	157
#define K_KP_DEL	167
#define K_KP_SLASH	168
#define K_KP_MINUS	170
#define K_KP_PLUS	171
#define K_KP_NUMLOCK	154
#define K_KP_STAR	169
#define K_KP_EQUALS	173
#define K_MOUSE1	512
#define K_MOUSE2	513
#define K_MOUSE3	514
#define K_MOUSE4	517
#define K_MOUSE5	518
#define K_MOUSE6	519
#define K_MOUSE7	520
#define K_MOUSE8	521
#define K_MOUSE9	522
#define K_MOUSE10	523
#define K_LWIN	239
#define K_RWIN	240
#define K_APP	-241
#define K_SEARCH	-242
#define K_POWER	130
#define K_VOLUP	-243
#define K_VOLDOWN	-244
#define K_JOY1	768
#define K_JOY2	769
#define K_JOY3	770
#define K_JOY4	771
#define K_AUX1	784
#define K_AUX2	785
#define K_AUX3	786
#define K_AUX4	787
#define K_AUX5	788
#define K_AUX6	789
#define K_AUX7	790
#define K_AUX8	791
#define K_AUX9	792
#define K_AUX10	793
#define K_AUX11	794
#define K_AUX12	795
#define K_AUX13	796
#define K_AUX14	797
#define K_AUX15	798
#define K_AUX16	799
#define K_AUX17	800
#define K_AUX18	801
#define K_AUX19	802
#define K_AUX20	803
#define K_AUX21	804
#define K_AUX22	805
#define K_AUX23	806
#define K_AUX24	807
#define K_AUX25	808
#define K_AUX26	809
#define K_AUX27	810
#define K_AUX28	811
#define K_AUX29	812
#define K_AUX30	813
#define K_AUX31	814
#define K_AUX32	815
#define K_PAUSE	153
#define K_MWHEELUP	515
#define K_MWHEELDOWN	516
#define K_PRINTSCREEN	174
#define K_CAPSLOCK	155
#define K_SCROLLLOCK	156
#define K_SEMICOLON	59
#define K_TILDE	126
#define K_BACKQUOTE	96
#define K_BACKSLASH	92
#endif
#pragma noref 0
