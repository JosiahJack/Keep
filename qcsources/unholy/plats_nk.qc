float START_BOTTOM = 1;
float START_RTRN= 2;
float CONTINUE= 4;
float CENTER= 8;

//float	STATE_TOP					= 0;
//float	STATE_BOTTOM				= 1;
//float	STATE_UP					= 2;
//float	STATE_DOWN					= 3;
float	STATE_MOVING				= 4;

void() newplat_hit_bottom;
void() newplat_hit_top;

void() newplat_calc_down =
{
	self.state=STATE_MOVING;
	SUB_CalcMove (self.pos2, self.speed, newplat_hit_bottom);
};

void() newplat_go_down =
{
	sound (self, CHAN_VOICE, self.noise, 1, ATTN_NORM);
	newplat_calc_down();
};

void() newplat_calc_up =
{
	self.state=STATE_MOVING;
	SUB_CalcMove (self.pos1, self.speed, newplat_hit_top);
};

void() newplat_go_up =
{
	sound (self, CHAN_VOICE, self.noise, 1, ATTN_NORM);
	newplat_calc_up();
};

void() newplat_hit_bottom =
{
	sound (self, CHAN_VOICE, self.noise1, 1, ATTN_NORM);
	self.state = STATE_BOTTOM;
	self.lifetime = time + self.wait;
	if (((self.spawnflags & START_RTRN) && !(self.spawnflags & START_BOTTOM)) ||
		(self.spawnflags & CONTINUE))
	{
		self.nextthink = self.ltime + self.wait;
		self.think=newplat_go_up;
	}
	setorigin (self.enemy, self.origin);	
};

void() newplat_hit_top =
{
	sound (self, CHAN_VOICE, self.noise1, 1, ATTN_NORM);
	self.state = STATE_TOP;
	self.lifetime = time + self.wait;

	if (((self.spawnflags & START_RTRN) && (self.spawnflags & START_BOTTOM)) ||
		(self.spawnflags & CONTINUE))
	{
		self.nextthink = self.ltime + self.wait;
		self.think=newplat_go_down;
	}

	setorigin (self.enemy, self.origin);	
};

void() newplat_crush =
{
	T_Damage (other, self, self, self.dmg);
	if (self.velocity_z < 0)
		newplat_calc_down ();
	else if (self.velocity_z > 0)
		newplat_calc_up();
	else
		objerror ("newplat_crush: bad self.state\n");
};

void() newplat_trigger_use =
{
	if (self.think) if (self.think!=SUB_Null)
		return;		// already activated

	if ((self.state==STATE_MOVING) || (self.lifetime > time))
 		return;

	if (self.state == STATE_BOTTOM)
		newplat_go_up ();
	else
		newplat_go_down ();
};

void() newplat_center_touch =
{

	if ((other.classname != "player") || (other.health <= 0))
		return;
	
	self = self.enemy;
	if ((self.state==STATE_MOVING) || (self.lifetime > time))
 		return;

	if (self.state == STATE_BOTTOM)
		newplat_go_up ();
	else
		newplat_go_down ();
};

void() newplat_spawn_inside_trigger =
{
	local entity	trigger;

	//Inky 20201104 Associate the plat with a hand made trigger instead of an autogenerated one with default size and position
	//              (That's to trigger the plat only when the player is right in the center of it instead of when touching its edges)
	if(self.target)
	{
		trigger=find(world,targetname,self.target);
	}
	else
	{
	   //middle trigger
		trigger = spawn();
	}
	
	trigger.touch = newplat_center_touch;

	trigger.movetype = MOVETYPE_PUSH;
	trigger.solid = SOLID_TRIGGER;
	trigger.enemy = self;
	self.enemy = trigger;
	
	if(!self.target)
	{
		if (self.spawnflags & CENTER) //Inky 20210112
		{
			vector platcenter = (self.mins + self.maxs)*0.5;
			setsize (trigger, platcenter - '16 16 0' - '0 0 1' * (self.height/2+32), platcenter + '16 16 0' + '0 0 1' * (self.height/2+32));
		}
		else
			setsize (trigger, self.mins,self.maxs); //Inky 20201104
	}
	
	self.think=SUB_Null; //To allow external activation by trigger
};

/*QUAKED func_newplat (0 .5 .8) ? START_BOTTOM STRT_RTRN CONTINUE
speed	default 150
If the "height" key is set, that will determine the amount the plat moves, instead of being implicitly determined by the model's height.
START_BOTTOM - where plat starts at
if checked plat starts at the bottom of it's movement
START_RTRN - if check will return plat to start position.
CONTINUE - plat will never stop moving
height - distance plat moves up or down
wait - amount of time plat waits before moving (default 3)
*/
void() func_newplat =
{

	if (!self.t_length)
		self.t_length = 80;
	if (!self.t_width)
		self.t_width = 10;

	if (self.soundtype == 0)
		self.soundtype = 2;

	if (self.sounds == 0)
		self.sounds = 3;
	
	if (self.sounds == 1)
	{
		self.noise = ("misc/null.wav");
		precache_sound ("misc/null.wav");
		self.noise1 = ("misc/null.wav");
		precache_sound ("misc/null.wav");
	}
	else if (self.sounds == 2)
	{
		precache_sound ("plats/plat1.wav");
		precache_sound ("plats/plat2.wav");
		self.noise = "plats/plat1.wav";
		self.noise1 = "plats/plat2.wav";
	}
	else if (self.sounds == 3)
	{
		precache_sound ("plats/medplat1.wav");
		precache_sound ("plats/medplat2.wav");
		self.noise = "plats/medplat1.wav";
		self.noise1 = "plats/medplat2.wav";
	}
	else if (self.sounds == 4)
	{
		self.noise = ("plats/train2.wav");
		precache_sound ("plats/train2.wav");
		self.noise1 = ("plats/train1.wav");
		precache_sound ("plats/train1.wav");
	}
	else if (self.sounds == 5)
	{
		precache_sound ("doors/doormv1.wav");
		precache_sound ("doors/drclos4.wav");
		self.noise = "doors/doormv1.wav";
		self.noise1 = "doors/drclos4.wav";
	}

	self.mangle = self.angles;
	self.angles = '0 0 0';

	self.classname = "newplat";
	self.solid = SOLID_BSP;
	self.movetype = MOVETYPE_PUSH;
	setorigin (self, self.origin);	
	setmodel (self, self.model);
	setsize (self, self.mins , self.maxs);

	if (!self.speed)
		self.speed = 150;

	if (!self.wait)
		self.wait = 3;

	if (!self.dmg)
		self.dmg = 2;

// pos1 is the top position, pos2 is the bottom
	self.pos1 = self.origin;
	self.pos2 = self.origin;

	if (self.spawnflags & START_BOTTOM)
		self.state=STATE_BOTTOM;
	else
		self.state=STATE_TOP;

   if (self.state==STATE_BOTTOM)
	{
		self.pos1_z = self.origin_z + self.height;
		self.pos2_z = self.origin_z;
	}
	else
	{
		self.pos1_z = self.origin_z;
		self.pos2_z = self.origin_z - self.height;
	}

	self.use = newplat_trigger_use;
	self.blocked = newplat_crush;

	//set the "start moving" trigger
	self.nextthink = time + 0.5;
	self.think=newplat_spawn_inside_trigger;

};
