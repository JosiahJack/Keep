/*======================================================================
 SPECIFIC AI LOGIC ROUTINES

 * Specific routines for certain monster types to determine if
   they can melee or missile (range) attack
 * Always working 1 frame behind the ai_run function
 * Moved demon/wizard checkattack routines here (split locations)
 
 CheckAttack (generic)
======================================================================*/
void() CheckAttack =
{
	// Does the monster have a clear shot to the player?
	// sightline can be blocked by other monsters
	if (visblocked(self.enemy)) return;
		
	//----------------------------------------------------------------------
	// Melee attack
	// enemy_range is checked before this function (ai_run - ai.qc)
	// If the monster is within melee range they instantly attack
	//----------------------------------------------------------------------
	if (ai_checkmelee(MONAI_MELEEKNIGHT) && self.th_melee) {
		self.attack_state = AS_MELEE;
		self.th_melee ();
		return;
	}
	//----------------------------------------------------------------------
	// If setup to be a turret, check range attack only
	//----------------------------------------------------------------------
	if (self.movespeed < 0 && self.th_missile) {
		if (time < self.attack_finished) return;
		SUB_AttackFinished (2 + random());
		self.attack_state = AS_MISSILE;
		return;
	}
	
	//----------------------------------------------------------------------
	// Range attack
	// The attack chance percentages are constant across skill levels
	//----------------------------------------------------------------------
	if (!self.th_missile) return;
	if (time < self.attack_finished) return;
	if (enemy_range == RANGE_FAR) return;

	// range < 120 map units
	if (enemy_range == RANGE_MELEE) {
		self.attack_chance = 0.9;
		self.attack_finished = 0;
	}
	// range < 500 map units
	else if (enemy_range == RANGE_NEAR) {
		if (self.th_melee) self.attack_chance = 0.2;
		else self.attack_chance = 0.4;
	}
	// range < 1000 map units
	else if (enemy_range == RANGE_MID) {
		if (self.th_melee) self.attack_chance = 0.05;
		else self.attack_chance = 0.1;
	}
	else self.attack_chance = 0;

	if (random () < self.attack_chance) {
		SUB_AttackFinished (2*random());
		self.th_missile ();
	}
};

/*======================================================================
 SoldierCheckAttack (Rocket version has melee)
======================================================================*/
void() SoldierCheckAttack =
{
	//----------------------------------------------------------------------
	// If setup to be a turret, check range attack only
	//----------------------------------------------------------------------
	if (self.movespeed < 0) {
		if (time < self.attack_finished) return;
		if (visblocked(self.enemy)) return;
		SUB_AttackFinished (2 + random());
		self.attack_state = AS_MISSILE;
		return;
	}
	//----------------------------------------------------------------------
	// If enemy is within melee range, just keep on attacking!
	// Original ID behaviour is 10% chance to not attack in melee range
	// This has changed so that the soldier is more agressive up close
	// The army rocket has a special behaviour for melee range
	//----------------------------------------------------------------------
	if (self.classtype != CT_MONARMYROCKET && enemy_range == RANGE_MELEE) {
		self.attack_state = AS_MISSILE;
		return;
	}	
	
	// Does the monster have a clear shot to the player?
	// sightline can be blocked by other monsters
	if (visblocked(self.enemy)) return;

	if (self.classtype == CT_MONARMYROCKET) {
		if (ai_checkmelee(MONAI_RANGEARMYR)) {
			self.oldorigin = self.origin;
			// If move backward works, run back animation
			if (walkmove(self.angles_y+180, 16)) {
				setorigin(self, self.oldorigin);
				self.attack_state = AS_MELEE;
				self.th_melee ();
				return;
			}
			else setorigin(self, self.oldorigin);
		}
	}
	
	//----------------------------------------------------------------------
	// Range attack (bullets)
	//----------------------------------------------------------------------
	if (time < self.attack_finished) return;
	if (enemy_range == RANGE_FAR) return;	
	if (enemy_range == RANGE_MELEE) self.attack_chance = 0.9;		// range < 120 map units
	else if (enemy_range == RANGE_NEAR) self.attack_chance = 0.4;	// range < 500 map units
	else if (enemy_range == RANGE_MID) self.attack_chance = 0.05;	// range < 1000 map units
	else self.attack_chance = 0;
	if (random () < self.attack_chance) {
		self.attack_state = AS_MISSILE;
		if (self.classtype == CT_MONARMYROCKET) SUB_AttackFinished (2 + random());
		else SUB_AttackFinished (1 + random());
		if (random() < 0.3) self.lefty = !self.lefty;
	}
};

/*======================================================================
 PyrpCheckAttack (Melee=FIRE!)
======================================================================*/
void() PyroCheckAttack =
{
	// Does the monster have a clear shot to the player?
	// sightline can be blocked by other monsters
	if (visblocked(self.enemy)) return;

	if (ai_checkmelee(MONAI_RANGEPYRO)) {
		self.attack_state = AS_MELEE;
		self.th_melee ();
		return;
	}
};

/*======================================================================
 ShamCheckAttack
======================================================================*/
void() ShamCheckAttack =
{
	//----------------------------------------------------------------------
	// Melee attack(claws/overhead smash)
	//----------------------------------------------------------------------
	if (ai_checkmelee(MONAI_MELEESHAM)) {
		self.attack_state = AS_MELEE;
		// Don't wait for next frame, melee attack straight away 
		// (different id behaviour)
		self.th_melee ();
		return;
	}

	//----------------------------------------------------------------------
	// Range attack (lightning)
	//----------------------------------------------------------------------
	if (!enemy_vis) return;
	if (time < self.attack_finished) return;
	if (self.enemydist > MONAI_SHAMRANGE) return;

	// Does the monster have a clear shot to the player?
	// sightline can be blocked by other monsters
	if (visblocked(self.enemy)) return;

	self.attack_state = AS_MISSILE;
	SUB_AttackFinished (2 + 2*random());
};

/*======================================================================
 GolemCheckAttack
======================================================================*/
void() GolemCheckAttack =
{
	//----------------------------------------------------------------------
	// Melee attack(Punch/Pound)
	//----------------------------------------------------------------------
	if (!enemy_vis) return;
	if (self.enemydist < MONAI_MELEEGOLEM) {
		self.attack_state = AS_MELEE;
		return;
	}
	//----------------------------------------------------------------------
	// Floor stomp attack
	//----------------------------------------------------------------------
	if (self.enemydist < MONAI_GOLEMRANGE && random() < 0.3) {
		SUB_AttackFinished (1 + 2*random());
		self.th_slide ();
		return;
	}	
	//----------------------------------------------------------------------
	// Range attack (Rock Attack)
	//----------------------------------------------------------------------
	if (time < self.attack_finished) return;
	
	// Does the monster have a clear shot to the player?
	// sightline can be blocked by other monsters
	if (!visblocked_wide(self.enemy, '0 0 34', '0 0 24')) {
		self.attack_state = AS_MISSILE;
		SUB_AttackFinished (2 + 2*random());
	}
};

/*======================================================================
 ShalCheckAttack
======================================================================*/
void() ShalCheckAttack =
{
	//----------------------------------------------------------------------
	// If setup to be a turret, check range attack only
	//----------------------------------------------------------------------
	if (self.movespeed < 0) {
		if (time < self.attack_finished) return;
		// Slower spawnrate for minion eggs than voreballs
		if (!(self.spawnflags & MON_SHALRATH_MINIONS)) {
			if (visblocked(self.enemy)) return;
			SUB_AttackFinished (2*random());
		}
		else SUB_AttackFinished (1 + 2*random());
		self.attack_state = AS_MISSILE;
		return;
	}
	// Minion spawning shalraths should maintain distance
	// Use the new turn and side walk function to stay mid range
	if (self.spawnflags & MON_SHALRATH_MINIONS && self.enemy.flags & FL_CLIENT) {
		// Calculate a flat vector to ignore Z axis difference
		self.enemydist = range_distance(self.enemy, TRUE);
		// If too far away from enemy, move in a straight line
		if (self.enemydist > MONAI_RANGESHAL) {
			self.attack_state = AS_STRAIGHT;
		}
		else {
			// If range attack still blocked, move sideway/backwards
			if (time < self.attack_finished) {
				// If too close, move backwards and sideways so that
				// there is plenty of room to spawn more minions
				if (self.enemydist < MONAI_RANGESHAL2)
					self.attack_state = AS_BACKWARD;
				else self.attack_state = AS_SIDESTEP;
				// straight away move
				return;
			}
		}
	}

	// Does the monster have a clear shot to the enemy?
	// sightline can be blocked by other monsters
	if (visblocked(self.enemy)) return;
		
	//----------------------------------------------------------------------
	// Range attack
	// The attack chance percentages are constant across skill levels
	//----------------------------------------------------------------------
	if (enemy_range == RANGE_FAR) return;
	if (time < self.attack_finished) return;

	// random chance based on distance to enemy
	if (enemy_range == RANGE_MELEE) {
		self.attack_chance = 0.9;	// < 120
		self.attack_finished = 0;	// If enemy really close, constantly fire!
	}
	else if (enemy_range == RANGE_NEAR) self.attack_chance = 0.4;	// < 500
	else if (enemy_range == RANGE_MID) self.attack_chance = 0.1;	// < 1000
	else self.attack_chance = 0;

	// Random chance of range attack?
	if (random () < self.attack_chance) {
		// Slower spawnrate for minion eggs than voreballs
		if (self.spawnflags & MON_SHALRATH_MINIONS) SUB_AttackFinished (1 + 2*random());
		else SUB_AttackFinished (2*random());
		self.attack_state = AS_MISSILE;
	}
};

/*======================================================================
 EliminatorCheckAttack (Range=Plasma)
======================================================================*/
void() EliminatorCheckAttack =
{
	//----------------------------------------------------------------------
	// Range attack (Plasma)
	//----------------------------------------------------------------------
	if (!enemy_vis) return;
	if (time < self.attack_finished) return;
	if (enemy_range == RANGE_FAR) return;
	// Does the monster have a clear shot to the player?
	// sightline can be blocked by other monsters
	if (visblocked(self.enemy)) return;

	// Aggressive range attack, no % chances
	self.attack_state = AS_MISSILE;
	SUB_AttackFinished (1 + 2*random());
};

/*======================================================================
 DefenderCheckAttack (Melee=SSG / Range=GL)
======================================================================*/
void() DefenderCheckAttack =
{
	//----------------------------------------------------------------------
	// Melee attack (Super Shotgun to face)
	//----------------------------------------------------------------------
	if (ai_checkmelee(MONAI_RANGEDEFSSG)) {
		self.attack_state = AS_MELEE;
		self.th_melee ();
		return;
	}
	//----------------------------------------------------------------------
	// Range attack (Grenades)
	//----------------------------------------------------------------------
	if (!enemy_vis) return;
	if (time < self.attack_finished) return;
	if (enemy_range == RANGE_FAR) return;
	// Does the monster have a clear shot to the player?
	// sightline can be blocked by other monsters
	if (visblocked(self.enemy)) return;

	// Aggressive range attack, no % chances
	self.attack_state = AS_MISSILE;
	SUB_AttackFinished (1 + 2*random());
};

/*======================================================================
 OgreCheckAttack
======================================================================*/
void() OgreCheckAttack =
{
	//----------------------------------------------------------------------
	// Melee attack (chainsaw)
	//----------------------------------------------------------------------
	if (ai_checkmelee(MONAI_MELEEOGRE)) {
		self.attack_state = AS_MELEE;
		return;
	}
	//----------------------------------------------------------------------
	// If setup to be a turret, check range attack only
	//----------------------------------------------------------------------
	if (self.movespeed < 0) {
		if (time < self.attack_finished) return;
		if (visblocked(self.enemy)) return;
		SUB_AttackFinished (1 + 2*random());
		self.attack_state = AS_MISSILE;
		return;
	}
	//----------------------------------------------------------------------
	// Range attack (grenades)
	// strangely enough the chance attack percentages are not used
	//----------------------------------------------------------------------
	if (!enemy_vis) return;
	if (time < self.attack_finished) return;
	// Does the monster have a clear shot to the player?
	// sightline can be blocked by other monsters
	if (visblocked(self.enemy)) return;

	self.attack_state = AS_MISSILE;
	SUB_AttackFinished (1 + 2*random());
};

/*======================================================================
 OgreMacCheckAttack
======================================================================*/
void() OgreMacCheckAttack =
{
	//----------------------------------------------------------------------
	// Melee attack (chainsaw)
	//----------------------------------------------------------------------
	if (ai_checkmelee(MONAI_MELEEOGRE)) {
		self.attack_state = AS_MELEE;
		return;
	}
	//----------------------------------------------------------------------
	// If setup to be a turret, check range attack only
	//----------------------------------------------------------------------
	if (self.movespeed < 0) {
		if (time < self.attack_finished) return;
		if (visblocked(self.enemy)) return;
		SUB_AttackFinished (1 + 2*random());
		self.attack_state = AS_MISSILE;
		return;
	}
	//----------------------------------------------------------------------
	// Mid Range attack (JUMP)
	//----------------------------------------------------------------------
	// Jumped recently, facing right direction and not blocked?
	if ( self.jump_flag < time && infront(self.enemy) && !visblocked(self.enemy) ) {
		// Check for enemy above? (z axis)
		if (self.enemy.origin_z <= self.origin_z) {
			// Is the fury knight within the right range?
			if (self.enemydist > MONAI_JUMPHOGRENEAR &&
				self.enemydist < MONAI_JUMPHOGREFAR) {
				// Block any range attacks for a while
				SUB_AttackFinished (1 + random());
				self.th_jump ();
				return;
			}
		}
	}
	//----------------------------------------------------------------------
	// Range attack (grenades)
	// strangely enough the chance attack percentages are not used
	//----------------------------------------------------------------------
	if (!enemy_vis) return;
	if (time < self.attack_finished) return;
	// Does the monster have a clear shot to the player?
	// sightline can be blocked by other monsters
	if (visblocked(self.enemy)) return;

	self.attack_state = AS_MISSILE;
	SUB_AttackFinished (1 + 2*random());
};

/*======================================================================
 WizardCheckAttack (No melee attack)
======================================================================*/
void() WizardCheckAttack =
{
	//----------------------------------------------------------------------
	// Range attack (spit)
	//----------------------------------------------------------------------
	if (!enemy_vis) return;
	if (time < self.attack_finished) return;
	//----------------------------------------------------------------------
	// If setup to be a turret, check range attack only
	//----------------------------------------------------------------------
	if (self.movespeed < 0) {
		if (visblocked(self.enemy)) return;
		self.attack_state = AS_MISSILE;
		return;
	}
	//----------------------------------------------------------------------
	// Does the monster have a clear shot to the player?
	// sightline can be blocked by other monsters
	// The original id behaviour is wizards run until within range
	//----------------------------------------------------------------------
	if (enemy_range == RANGE_FAR || visblocked(self.enemy)) {
		if (self.attack_state != AS_STRAIGHT) self.attack_state = AS_STRAIGHT;
		return;
	}

	if (enemy_range == RANGE_MELEE) self.attack_chance = 0.9;		// range < 120 map units
	else if (enemy_range == RANGE_NEAR) self.attack_chance = 0.6;	// range < 500 map units
	else if (enemy_range == RANGE_MID) self.attack_chance = 0.2;	// range < 1000 map units
	else self.attack_chance = 0;
	if (random () < self.attack_chance) {
		self.attack_state = AS_MISSILE;
	}
	//----------------------------------------------------------------------
	// If turret, then do not move sideways
	// otherwise keep moving forward to enemy target
	//----------------------------------------------------------------------
	else if (enemy_range == RANGE_MID) {
		if (self.attack_state != AS_STRAIGHT) self.attack_state = AS_STRAIGHT;
	}
	else {
		if (self.attack_state != AS_SLIDING) {
			self.attack_state = AS_SLIDING;
			self.th_slide ();
		}
	}
};

/*======================================================================
 SkullWizardCheckAttack (No melee attack)
======================================================================*/
void() SkullWizCheckAttack =
{
	//----------------------------------------------------------------------
	// Teleport away if player too close
	//----------------------------------------------------------------------
	if (self.enemydist < MONAI_MELEESKULLW) {
		self.attack_state = AS_MELEE;
		return;
	}
	// make sure enemy is stationary (turret)
	else self.attack_state = AS_TURRET;
		
	//----------------------------------------------------------------------
	// Range / missile attack (skull attack)
	//----------------------------------------------------------------------
	if (!enemy_vis) return;
	if (time < self.attack_finished) return;
	// Does the monster have a clear shot to the player?
	// sightline can be blocked by other monsters
	if (visblocked(self.enemy)) return;

	self.attack_state = AS_MISSILE;
	SUB_AttackFinished (1 + 2*random());
};

/*======================================================================
 LostCheckAttack
======================================================================*/
void() LostCheckAttack =
{
	//----------------------------------------------------------------------
	// setup enemytarget if one is not active
	//----------------------------------------------------------------------
	if (self.enemy.classtype != CT_ENEMYTARGET) {
		SUB_setupEnemyTarget(self.enemy, self.height, MONAI_ABOVETIMER);
		if (self.enemytarget) self.enemy = self.enemytarget;
	}

	//----------------------------------------------------------------------
	// Melee attack (bite)
	//----------------------------------------------------------------------
	if (ai_checkmelee(MONAI_MELEELOSTSOUL)) {
		self.attack_state = AS_MELEE;
		return;
	}

	//----------------------------------------------------------------------
	// If too close, move sideways until can ram again
	// If too far, move closer
	//----------------------------------------------------------------------
	if (self.enemydist < MONAI_RANGELOSTNEAR) {
		self.attack_state = AS_SLIDING;
		return;
	}
	else if (self.enemydist > MONAI_RANGELOSTFAR) {
		self.attack_state = AS_STRAIGHT;
		return;
	}

	//----------------------------------------------------------------------
	// Cannot see enemy? go into guard mode
	//----------------------------------------------------------------------
	if (!enemy_vis && self.lostsearch == FALSE) {
		SUB_switchEnemyTarget();
		self.ideal_yaw = vectoyaw(self.enemy.origin - self.origin);
		self.lostsearch = TRUE;
		self.lostenemy = self.enemy;
		self.losttimer = time + MONAI_LOSTTIMER + random()*5;
		self.enemy = self.goalentity = self.movetarget = world;
		self.th_altstand();
		return;
	}
	
	//----------------------------------------------------------------------
	// Range attack (Ramming Speed)
	//----------------------------------------------------------------------
	// Only range attack if cooldown has finished
	if (time > self.attack_finished) {
		if (!visblocked_wide(SUB_entEnemyTarget(), self.view_ofs, '0 0 24')) {
			SUB_AttackFinished(2 + random());
			self.attack_state = AS_MISSILE;
		}
		// No space for raming speed, strafe side to side
		else self.attack_state = AS_SLIDING;
	}
	// Wait for attack timer, better to face the player
	else self.attack_state = AS_SLIDING;
};

/*======================================================================
 JimCheckAttack (No melee attack)
 This is essentially the monster_centarion check
======================================================================*/
void() JimCheckAttack =
{
	// Cannot see enemy? stop chasing enemytarget
	if (!enemy_vis) {
		SUB_switchEnemyTarget();
		return;
	}
	//----------------------------------------------------------------------
	// If setup to be a turret, check range attack only
	//----------------------------------------------------------------------
	if (self.movespeed < 0) {
		if (time < self.attack_finished) return;
		if (!visblocked_wide(SUB_entEnemyTarget(), self.attack_offset, '0 0 0')) {
			SUB_AttackFinished(2 + random());
			self.attack_state = AS_MISSILE;
		}
		return;
	}
	//----------------------------------------------------------------------
	// setup enemytarget if one is not active
	//----------------------------------------------------------------------
	if (self.enemy.classtype != CT_ENEMYTARGET) {
		SUB_setupEnemyTarget(self.enemy, self.height, MONAI_ABOVETIMER);
		if (self.enemytarget) self.enemy = self.enemytarget;
	}
	//----------------------------------------------------------------------
	// Range attack (Lasers)
	//----------------------------------------------------------------------
	// Only range attack if cooldown has finished
	if (time > self.attack_finished) {
		if (enemy_range == RANGE_MELEE) self.attack_chance = 0.9;		// range < 120 map units
		else if (enemy_range == RANGE_NEAR) self.attack_chance = 0.6;	// range < 500 map units
		else if (enemy_range == RANGE_MID) self.attack_chance = 0.2;	// range < 1000 map units
		else self.attack_chance = 0;
		if (random () < self.attack_chance) {
			if (!visblocked_wide(SUB_entEnemyTarget(), self.attack_offset, '0 0 0')) {
				if (enemy_range != RANGE_MELEE)	SUB_AttackFinished(2 + random());
				self.attack_state = AS_MISSILE;
				return;
			}
		}
	}
	//----------------------------------------------------------------------
	// Make sure jim maintains its distance (strafe)
	//----------------------------------------------------------------------
	if (enemy_range >= RANGE_MID || !enemy_vis) {
		if (self.attack_state != AS_STRAIGHT) self.attack_state = AS_STRAIGHT;
	}
	else self.attack_state = AS_SLIDING;
};

/*======================================================================
 CenturionCheckAttack (No melee attack)
======================================================================*/
void() CenturionCheckAttack =
{
	// Cannot see enemy? stop chasing enemytarget
	if (!enemy_vis) {
		SUB_switchEnemyTarget();
		return;
	}
	//----------------------------------------------------------------------
	// If setup to be a turret, check range attack only
	//----------------------------------------------------------------------
	if (self.movespeed < 0) {
		if (time < self.attack_finished) return;
		if (!visblocked_wide(SUB_entEnemyTarget(), self.attack_offset, '0 0 0')) {
			SUB_AttackFinished(2 + random());
			self.attack_state = AS_MISSILE;
		}
		return;
	}
	//----------------------------------------------------------------------
	// setup enemytarget if one is not active
	//----------------------------------------------------------------------
	if (self.enemy.classtype != CT_ENEMYTARGET) {
		SUB_setupEnemyTarget(self.enemy, self.height, MONAI_ABOVETIMER);
		if (self.enemytarget) self.enemy = self.enemytarget;
	}
	//----------------------------------------------------------------------
	// Range attack (Plasma)
	//----------------------------------------------------------------------
	// Only range attack if cooldown has finished
	if (time > self.attack_finished) {
		if (enemy_range == RANGE_MELEE) self.attack_chance = 0.9;		// range < 120 map units
		else if (enemy_range == RANGE_NEAR) self.attack_chance = 0.6;	// range < 500 map units
		else if (enemy_range == RANGE_MID) self.attack_chance = 0.2;	// range < 1000 map units
		else self.attack_chance = 0;
		if (random () < self.attack_chance) {
			if (!visblocked_wide(SUB_entEnemyTarget(), self.attack_offset, '0 0 0')) {
				if (enemy_range != RANGE_MELEE)	SUB_AttackFinished(2 + random());
				self.attack_state = AS_MISSILE;
				return;
			}
		}
	}	
	//----------------------------------------------------------------------
	// Make sure the centurion maintains its distance (strafe)
	//----------------------------------------------------------------------
	if (enemy_range >= RANGE_MID || !enemy_vis) {
		if (self.attack_state != AS_STRAIGHT) self.attack_state = AS_STRAIGHT;
	}
	else self.attack_state = AS_SLIDING;
};

/*======================================================================
 GargoyleCheckAttack (No melee attack)
======================================================================*/
void() GargoyleCheckAttack =
{
	// Cannot see enemy? stop chasing enemytarget
	if (!enemy_vis) {
		SUB_switchEnemyTarget();
		return;
	}
	//----------------------------------------------------------------------
	// If setup to be a turret, check range attack only
	//----------------------------------------------------------------------
	if (self.movespeed < 0) {
		if (time < self.attack_finished) return;
		if (!visblocked_wide(SUB_entEnemyTarget(), self.attack_offset, '0 0 0')) {
			SUB_AttackFinished(2 + random());
			self.attack_state = AS_MISSILE;
		}
		return;
	}
	//----------------------------------------------------------------------
	// setup enemytarget if one is not active
	//----------------------------------------------------------------------
	if (self.enemy.classtype != CT_ENEMYTARGET) {
		SUB_setupEnemyTarget(self.enemy, self.height, MONAI_ABOVETIMER);
		if (self.enemytarget) self.enemy = self.enemytarget;
	}
	//----------------------------------------------------------------------
	// Range attack (Fireball)
	//----------------------------------------------------------------------
	// Only range attack if cooldown has finished
	if (time > self.attack_finished) {
		if (enemy_range == RANGE_MELEE) self.attack_chance = 0.9;		// range < 120 map units
		else if (enemy_range == RANGE_NEAR) self.attack_chance = 0.6;	// range < 500 map units
		else if (enemy_range == RANGE_MID) self.attack_chance = 0.2;	// range < 1000 map units
		else self.attack_chance = 0;
		if (random () < self.attack_chance) {
			if (!visblocked_wide(SUB_entEnemyTarget(), self.attack_offset, '0 0 0')) {
				if (enemy_range != RANGE_MELEE)	SUB_AttackFinished(2 + random());
				self.attack_state = AS_MISSILE;
				return;
			}
		}
	}
	
	//----------------------------------------------------------------------
	// Make sure the gargoyle maintains its distance (strafe)
	//----------------------------------------------------------------------
	if (enemy_range >= RANGE_MID || !enemy_vis) {
		if (self.attack_state != AS_STRAIGHT) self.attack_state = AS_STRAIGHT;
	}
	else self.attack_state = AS_SLIDING;
};

/*======================================================================
 GauntCheckAttack (No melee attack)
======================================================================*/
void() GauntCheckAttack =
{
	// Cannot see enemy? stop chasing enemytarget
	if (!enemy_vis) {
		SUB_switchEnemyTarget();
		return;
	}
	//----------------------------------------------------------------------
	// If setup to be a turret, check range attack only
	//----------------------------------------------------------------------
	if (self.movespeed < 0) {
		if (time < self.attack_finished) return;
		if (!visblocked_wide(SUB_entEnemyTarget(), self.attack_offset, '0 0 0')) {
			SUB_AttackFinished(2 + random());
			self.attack_state = AS_MISSILE;
		}
		return;
	}
	//----------------------------------------------------------------------
	// setup enemytarget if one is not active
	//----------------------------------------------------------------------
	if (self.enemy.classtype != CT_ENEMYTARGET) {
		SUB_setupEnemyTarget(self.enemy, self.height, MONAI_ABOVETIMER);
		if (self.enemytarget) self.enemy = self.enemytarget;
	}
	//----------------------------------------------------------------------
	// Range attack (Plasma volley)
	//----------------------------------------------------------------------
	// Only range attack if cooldown has finished
	if (time > self.attack_finished) {
		if (enemy_range == RANGE_MELEE) self.attack_chance = 0.9;		// range < 120 map units
		else if (enemy_range == RANGE_NEAR) self.attack_chance = 0.6;	// range < 500 map units
		else if (enemy_range == RANGE_MID) self.attack_chance = 0.2;	// range < 1000 map units
		else self.attack_chance = 0;
		if (random () < self.attack_chance) {
			if (!visblocked_wide(SUB_entEnemyTarget(), self.attack_offset, '0 0 0')) {
				if (enemy_range != RANGE_MELEE)	SUB_AttackFinished(2 + random());
				self.attack_state = AS_MISSILE;
				return;
			}
		}
	}
	
	//----------------------------------------------------------------------
	// Make sure the Gaunt maintains its distance (strafe)
	//----------------------------------------------------------------------
	if (enemy_range >= RANGE_MID || !enemy_vis) {
		if (self.attack_state != AS_STRAIGHT) self.attack_state = AS_STRAIGHT;
	}
	else self.attack_state = AS_SLIDING;
};

/*======================================================================
 WraithCheckAttack (No melee attack)
======================================================================*/
void() WraithCheckAttack =
{
	//----------------------------------------------------------------------
	// Cannot see enemy? stop chasing enemytarget
	//----------------------------------------------------------------------
	if (!enemy_vis) {
		SUB_switchEnemyTarget();
		return;
	}
	//----------------------------------------------------------------------
	// If setup to be a turret, check range attack only
	//----------------------------------------------------------------------
	if (self.movespeed < 0) {
		if (time < self.attack_finished) return;
		if (!visblocked_wide(SUB_entEnemyTarget(), self.attack_offset, '0 0 0')) {
			SUB_AttackFinished(2 + random());
			self.attack_state = AS_MISSILE;
		}
		return;
	}
	//----------------------------------------------------------------------
	// setup enemytarget if one os not active
	//----------------------------------------------------------------------
	if (self.enemy.classtype != CT_ENEMYTARGET) {
		SUB_setupEnemyTarget(self.enemy, self.height, MONAI_ABOVETIMER);
		if (self.enemytarget) self.enemy = self.enemytarget;
	}
	//----------------------------------------------------------------------
	// Range attack (burning and creature summons)
	// Much more aggressive decision on range attacks (ogre style)
	// No random chance percentages, logic with wraith magic function
	//----------------------------------------------------------------------
	// Only range attack if cooldown has finished
	if (time > self.attack_finished) {
		if (!visblocked_wide(SUB_entEnemyTarget(), self.attack_offset, '0 0 0')) {
			if (enemy_range != RANGE_MELEE)	SUB_AttackFinished(2 + random());
			self.attack_state = AS_MISSILE;
			return;
		}
	}

	//----------------------------------------------------------------------
	// If turret, then do not move sideways
	//----------------------------------------------------------------------
	if (self.movespeed < 0) {
		if (self.attack_state != AS_STRAIGHT) self.attack_state = AS_STRAIGHT;
		return;
	}
	//----------------------------------------------------------------------
	// Make sure the wraith maintains its distance (strafe)
	//----------------------------------------------------------------------
	if (enemy_range >= RANGE_MID || !enemy_vis) {
		if (self.attack_state != AS_STRAIGHT) self.attack_state = AS_STRAIGHT;
	}
	else self.attack_state = AS_SLIDING;
};

/*======================================================================
 MinotaurCheckAttack
======================================================================*/
void() MinotaurCheckAttack =
{
	//----------------------------------------------------------------------
	// If health is low enough, switch to rage mode
	// This does not affect the minion spawning version
	if ( !(self.spawnflags & MON_MINOTAUR_MINIONS) && self.movespeed >= 0) {
		if (self.health < self.max_health*0.5 && !self.attack_rage) {
			self.attack_rage = TRUE;
			self.th_charge();	// Short howl at the sky
			return;
		}
	}
	//----------------------------------------------------------------------
	// Melee attack (claws)
	//----------------------------------------------------------------------
	if (ai_checkmelee(MONAI_MELEEMINOTAUR)) {
		self.attack_state = AS_MELEE;
		return;
	}
	//----------------------------------------------------------------------
	// If setup to be a turret, check range attack only
	//----------------------------------------------------------------------
	if (self.movespeed < 0) {
		if (time < self.attack_finished) return;
		if (visblocked(self.enemy)) return;
		// Keep firing rockets when at range
		SUB_AttackFinished (1 + 2*random());
		self.attack_state = AS_MISSILE;
		return;
	}
	//----------------------------------------------------------------------
	// RAGE mode (keep running at player)
	//----------------------------------------------------------------------
	if (self.attack_rage) {
		if (self.attack_state != AS_STRAIGHT) self.attack_state = AS_STRAIGHT;
		// Check range and sight for a low chance range attack
		if (!enemy_vis) return;
		if (time < self.attack_finished) return;
		// If enemy not infront or random chance, stop and range attack
		if (!infront(self.enemy) || random() < 0.1) {
			// Does the monster have a clear shot to the player?
			// sightline can be blocked by other monsters
			if (visblocked(self.enemy)) return;
			// Plasma bolt attack
			SUB_AttackFinished (2 + 2*random());
			self.attack_state = AS_MISSILE;
		}
	}	
	//----------------------------------------------------------------------
	// PASSIVE mode (keep at distance)
	//----------------------------------------------------------------------
	else {
		// Is the player NOT visible? Keep getting closer
		if (!enemy_vis) {
			if (self.attack_state != AS_STRAIGHT) 
				self.attack_state = AS_STRAIGHT;
		}
		else {
			//----------------------------------------------------------------------
			// Mid Range attack (JUMP) Not spawning dark version
			//----------------------------------------------------------------------
			if ( !(self.spawnflags & MON_MINOTAUR_MINIONS) && random() < 0.35) {
				// Jumped recently, facing right direction and not blocked?
				if ( self.jump_flag < time && infront(self.enemy)) {
					if (!visblocked_wide(self.enemy, self.view_ofs, self.enemy.view_ofs) ) {
						// Check for enemy above? (z axis)
						if (self.enemy.origin_z <= self.origin_z) {
							// Is the minotaur within the right range?
							if (self.enemydist > MONAI_JUMPMINONEAR &&
								self.enemydist < MONAI_JUMPMINOFAR) {
								// Block any range attacks for a while
								SUB_AttackFinished (random());
								self.jumptouch = world;	// Reset last object touched
								self.count = 0;			// Number of times jumped
								self.th_jump ();
								return;
							}
						}
					}
				}
			}
			//----------------------------------------------------------------------
			// Range / missile attack (plasma bolts)
			//----------------------------------------------------------------------
			// Any chance of a range attack?
			if (time < self.attack_finished) {
				// Calculate a flat vector to ignore Z axis difference
				self.enemydist = range_distance(self.enemy, TRUE);
				// Don't always stay at absolute range, move closer
				if (random() < 0.15 && self.enemydist > MONAI_RANGEMINOTAUR) {
					self.attack_sidedeny = time + 1 + random();
					self.attack_state = AS_STRAIGHT;
				}
				else {
					// If not blocked, turn and move sideways
					if (self.attack_sidedeny < time)
						self.attack_state = AS_SIDESTEP;
				}
			}
			else {
				// Does the monster have a clear shot to the player?
				// sightline can be blocked by other monsters
				if (visblocked(self.enemy)) return;
				// Keep firing plasma when at range
				SUB_AttackFinished (2 + 2*random());
				self.attack_state = AS_MISSILE;
			}
		}
	}
};

/*======================================================================
 DroleCheckAttack
======================================================================*/
void() DroleCheckAttack =
{
	//----------------------------------------------------------------------
	// Quoth setup - 500HP, with rage at 350HP
	// Converted it to a % so mappers can change health
	//----------------------------------------------------------------------
	if (self.movespeed >= 0) {
		if (self.health < self.max_health*0.7 && !self.attack_rage) {
			self.attack_rage = TRUE;
		}
	}
	//----------------------------------------------------------------------
	// Melee attack (claws)
	//----------------------------------------------------------------------
	if (ai_checkmelee(MONAI_MELEEDROLE2)) {
		self.attack_state = AS_MELEE;
		return;
	}
	//----------------------------------------------------------------------
	// If setup to be a turret, check range attack only
	//----------------------------------------------------------------------
	if (self.movespeed < 0) {
		if (time < self.attack_finished) return;
		if (visblocked(self.enemy)) return;
		// Keep firing rockets when at range
		SUB_AttackFinished (1 + 2*random());
		self.attack_state = AS_MISSILE;
		return;
	}
	//----------------------------------------------------------------------
	// RAGE mode (keep running at player)
	//----------------------------------------------------------------------
	if (self.attack_rage) {
		if (self.attack_state != AS_STRAIGHT) self.attack_state = AS_STRAIGHT;
		// Check range and sight for a low chance range attack
		if (!enemy_vis) return;
		if (time < self.attack_finished) return;
		// Calculate a flat vector to ignore Z axis difference
		self.enemydist = range_distance(self.enemy, TRUE);
		if (self.enemydist > MONAI_RANGEDROLE && random() < 0.3) {
			// Does the monster have a clear shot to the player?
			// sightline can be blocked by other monsters
			if (visblocked(self.enemy)) return;
			// Standard rocket attack
			SUB_AttackFinished (1 + 2*random());
			self.attack_state = AS_MISSILE;
		}
	}	
	//----------------------------------------------------------------------
	// PASSIVE mode (keep at distance)
	//----------------------------------------------------------------------
	else {
		// Is the player visible? Keep getting closer
		if (!enemy_vis) {
			if (self.attack_state != AS_STRAIGHT) 
				self.attack_state = AS_STRAIGHT;
		}
		// Player in sight, fireball or loiter?
		else {
			// Any chance of a range attack?
			if (time < self.attack_finished) {
				// Calculate a flat vector to ignore Z axis difference
				self.enemydist = range_distance(self.enemy, TRUE);
				// Don't always stay at absolute range, move closer
				if (random() < 0.15 && self.enemydist > MONAI_RANGEDROLE) {
					self.attack_sidedeny = time + 1 + random();
					self.attack_state = AS_STRAIGHT;
				}
				else {
					// If not blocked, turn and move sideways
					if (self.attack_sidedeny < time)
						self.attack_state = AS_SIDESTEP;
				}
			}
			else {
				// Does the monster have a clear shot to the player?
				// sightline can be blocked by other monsters
				if (visblocked(self.enemy)) return;
				// Keep firing rockets when at range
				SUB_AttackFinished (1 + 2*random());
				self.attack_state = AS_MISSILE;
			}
		}
	}
};

/*======================================================================
 DSergeantCheckAttack
======================================================================*/
void() DSergeantCheckAttack =
{
	// Does the monster have a clear shot to the player?
	// sightline can be blocked by other monsters
	if (visblocked(self.enemy)) return;

	//----------------------------------------------------------------------
	// Melee attack
	// enemy_range is checked before this function (ai_run - ai.qc)
	// If the monster is within melee range they instantly attack
	//----------------------------------------------------------------------
	if (ai_checkmelee(MONAI_MELEEFRONT)) {
		self.attack_state = AS_MELEE;
		self.th_melee ();
		return;
	}
	//----------------------------------------------------------------------
	// If setup to be a turret, check range attack only
	//----------------------------------------------------------------------
	if (self.movespeed < 0) {
		if (time < self.attack_finished) return;
		// If the sightline between self and player blocked by anything, keep moving
		if (!visxray(self.enemy, self.view_ofs, '0 0 0', FALSE)) return;
		self.attack_state = AS_MISSILE;
		return;
	}
	//----------------------------------------------------------------------
	// Charge attack
	// If the player is within a certain (<500) range, randomnly start charging
	//----------------------------------------------------------------------
	self.height = fabs(self.origin_z - self.enemy.origin_z);
	if (ai_checkmelee(MONAI_CHARGEFLAIL) && self.height < MONAI_CHARGEZAXIS
			&& self.attack_timer < time) {
		// If attack timer not active, bump up with a random amount
		if (self.attack_finished < time) SUB_AttackFinished (random());
		self.th_charge ();
		return;
	}	

	//----------------------------------------------------------------------
	// Range attack
	// The attack chance percentages are constant across skill levels
	//----------------------------------------------------------------------
	if (time < self.attack_finished) return;
	// If the sightline between self and player blocked by anything, keep moving
	if (!visxray(self.enemy, '0 0 0', '0 0 0', FALSE)) return;
	if (enemy_range == RANGE_MELEE) self.attack_chance = 0.9;		// range < 120 map units
	else if (enemy_range == RANGE_NEAR) self.attack_chance = 0.4;	// range < 500 map units
	else if (enemy_range == RANGE_MID) self.attack_chance = 0.05;	// range < 1000 map units
	else self.attack_chance = 0;
	if (random () < self.attack_chance) self.attack_state = AS_MISSILE;
};

/*======================================================================
 DFuryCheckAttack
======================================================================*/
void() DFuryCheckAttack =
{
	// Does the monster have a clear shot to the player?
	// sightline can be blocked by other monsters
	if (visblocked(self.enemy)) return;
		
	//----------------------------------------------------------------------
	// Melee attack
	// enemy_range is checked before this function (ai_run - ai.qc)
	// If the monster is within melee range they instantly attack
	//----------------------------------------------------------------------
	if (ai_checkmelee(MONAI_MELEEFRONT)) {
		self.attack_state = AS_MELEE;
		self.th_melee (); 
		return;
	}
	//----------------------------------------------------------------------
	// If setup to be a turret, check range attack only
	//----------------------------------------------------------------------
	if (self.movespeed < 0) {
		if (time < self.attack_finished) return;
		// If the sightline between self and player blocked by anything, keep moving
		if (!visxray(self.enemy, self.view_ofs, '0 0 0', FALSE)) return;
		self.attack_state = AS_MISSILE;
		return;
	}
	//----------------------------------------------------------------------
	// is the enemy close enough for a double sword slice attack?
	//----------------------------------------------------------------------
	if (self.enemydist < MONAI_JUMPFURYNEAR) {
		self.attack_state = AS_MELEE;
		self.th_slide (); 
		return;
	}
	//----------------------------------------------------------------------
	// Mid Range attack (JUMP)
	//----------------------------------------------------------------------
	// Jumped recently, facing right direction and not blocked?
	if ( self.jump_flag < time && infront(self.enemy) && !visblocked(self.enemy) ) {
		// Check for enemy above? (z axis)
		if (self.enemy.origin_z <= self.origin_z) {
			// Is the fury knight within the right range?
			if (self.enemydist > MONAI_JUMPFURYNEAR &&
				self.enemydist < MONAI_JUMPFURYFAR) {
				// Block any range attacks for a while
				SUB_AttackFinished (random());
				self.jumptouch = world;		// Reset last object touched
				self.count = 0;				// Number of times jumped
				if (random() < 0.65) self.th_jump ();
				else self.th_charge ();
				return;
			}
		}
	}
	//----------------------------------------------------------------------
	// Range attack
	// The attack chance percentages are constant across skill levels
	//----------------------------------------------------------------------
	if (time < self.attack_finished) return;
	// If the sightline between self and player blocked by anything, keep moving
	if (!visxray(self.enemy, self.view_ofs, '0 0 0', FALSE)) return;
	
	if (enemy_range == RANGE_MELEE) self.attack_chance = 0.9;		// range < 120 map units
	else if (enemy_range == RANGE_NEAR) self.attack_chance = 0.4;	// range < 500 map units
	else if (enemy_range == RANGE_MID) self.attack_chance = 0.05;	// range < 1000 map units
	else self.attack_chance = 0;
	if (random () < self.attack_chance) self.attack_state = AS_MISSILE;
};

/*======================================================================
 DCrossCheckAttack
======================================================================*/
void() DCrossCheckAttack =
{
	if (!enemy_vis) return;
	//----------------------------------------------------------------------
	// Melee attack (blunt end of crossbow)
	//----------------------------------------------------------------------
	if (ai_checkmelee(MONAI_MELEEKNIGHT)) {
		self.attack_state = AS_MELEE;
		return;
	}
	//----------------------------------------------------------------------
	// If setup to be a turret, check range attack only
	//----------------------------------------------------------------------
	if (self.movespeed < 0) {
		if (time < self.attack_finished) return;
		// If sight blocked by another monster, do nothing
		if (!visblocked_wide(self.enemy, '0 0 28', '0 0 0')) return;
		self.attack_state = AS_MISSILE;
		return;
	}
	//----------------------------------------------------------------------
	// Range / missile attack (slow bolts)
	// The range logic is done via two set of animations (hold/slide)
	// Once within a certain range, stay there and snipe at the enemy
	//----------------------------------------------------------------------
	// range < 500 map units
	if (enemy_range == RANGE_NEAR) {
		// If sight blocked by another monster, slide to the side
		if (!visblocked_wide(self.enemy, '0 0 28', '0 0 0')) {
			self.attack_state = AS_SLIDING;
			self.th_slide ();
		}
		else {
			// No monster in the way, hold still and start aiming
			self.attack_state = AS_MISSILE;
			self.th_missile ();
		}
	}
	else self.attack_state = AS_STRAIGHT;
};

/*======================================================================
 ZombiekCheckAttack (Has no range attack)
 The player is in view, so decide to jump or melee
======================================================================*/
void() ZombiekCheckAttack =
{
	if (!enemy_vis) return;
	//----------------------------------------------------------------------
	// Melee attack (blunt end of crossbow)
	//----------------------------------------------------------------------
	if (ai_checkmelee(MONAI_MELEEKNIGHT)) {
		self.attack_state = AS_MELEE;
		return;
	}
	//----------------------------------------------------------------------
	// If setup to be a turret, randomly do melee attacks
	//----------------------------------------------------------------------
	if (self.movespeed < 0) {
		if (random() < MONAI_TURRETMODE) return;
		self.attack_state = AS_MELEE;
		return;
	}
	//----------------------------------------------------------------------
	// Range / missile attack (jumping)
	//----------------------------------------------------------------------
	if (time < self.attack_finished) return;
	self.attack_chance = 0.3 + skill*0.1;
	if (random() < self.attack_chance) {
		// Is the enemy the right distance away and the random chance is correct?
		if (self.enemydist > MONAI_JUMPZKNEAR && self.enemydist < MONAI_JUMPZKFAR) {
			SUB_AttackFinished (2 + random()*2);
			self.jumptouch = world;			// Reset last object touched
			self.count = 0;					// Number of times jumped
			self.attack_state = AS_JUMP;	// JUMP JUMP JUMP!
		}
	}
};

/*======================================================================
 SpawnCheckAttack
======================================================================*/
void() SpawnCheckAttack =
{
	// Spawns don't start jumping straight away unless they can directly
	// see the player. 	// They slowly crawl around which can make them
	// tricky to plan for an ambush.
	// Does the monster have a clear shot to the player?
	// sightline can be blocked by other monsters
	if (visblocked(self.enemy)) return;

	//----------------------------------------------------------------------
	// JUMP Melee attack
	// This pretty much a close quarter jump in the face attack!
	//----------------------------------------------------------------------
	if (ai_checkmelee(MONAI_MELEESPAWN)) {
		self.attack_state = AS_MELEE;
		self.th_melee ();
		return;
	}
	//----------------------------------------------------------------------
	// If setup to be a turret, randomly do melee attacks
	//----------------------------------------------------------------------
	if (self.movespeed < 0) {
		if (random() < MONAI_TURRETMODE) return;
		self.attack_state = AS_MELEE;
		return;
	}
	//----------------------------------------------------------------------
	// JUMP Range attack
	// The attack chance percentages are constant across skill levels
	//----------------------------------------------------------------------
	if (time < self.attack_finished) return;

	// range < 120 map units
	if (enemy_range == RANGE_MELEE) {
		self.attack_chance = 0.9;
		self.attack_finished = 0;
	}
	// range < 500 map units
	else if (enemy_range == RANGE_NEAR) self.attack_chance = 0.2;
	// range < 1000 map units
	else if (enemy_range == RANGE_MID) self.attack_chance = 0.05;
	else self.attack_chance = 0;

	if (random () < self.attack_chance) {
		SUB_AttackFinished (2*random());
		self.jumptouch = world;			// Reset last object touched
		self.count = 0;					// Number of times jumped
		self.attack_state = AS_JUMP;	// JUMP JUMP JUMP!
	}
};

/*======================================================================
 DemonCheckAttack
======================================================================*/
void() DemonCheckAttack =
{
	//----------------------------------------------------------------------
	// Melee attack (CLAWS)
	//----------------------------------------------------------------------
	// Check that within range of a claw attack
	if (ai_checkmelee(MONAI_MELEEDEMON)) {
		self.attack_state = AS_MELEE;
		return;
	}
	//----------------------------------------------------------------------
	// If setup to be a turret, randomly do melee attacks
	//----------------------------------------------------------------------
	if (self.movespeed < 0) {
		if (random() < MONAI_TURRETMODE) return;
		self.attack_state = AS_MELEE;
		return;
	}
	//----------------------------------------------------------------------
	// Range attack (JUMP)
	//----------------------------------------------------------------------
	// Time for another jump?
	if (self.jump_flag < time) {
		// Stop the demon over or under jumping the enemy
		if (self.origin_z + self.mins_z > self.enemy.origin_z + self.enemy.mins_z
		+ 0.75 * self.enemy.size_z) return;
		if (self.origin_z + self.maxs_z < self.enemy.origin_z + self.enemy.mins_z
		+ 0.25 * self.enemy.size_z) return;
			
		// Check for closeness, but not long range!
		self.enemydist = range_distance(self.enemy, TRUE);
		if (self.enemydist < MONAI_JUMPDEMONNEAR) return;
		
		// Check for low ceilings directly above the demon
		traceline(self.origin, self.origin + '0 0 256', TRUE, self);
		self.height = fabs(vlen(trace_endpos - self.origin));
		// Ceiling is too low (looks dumb hitting ceilings)
		if (self.height < MONAI_JUMPDEMONCHECK) return; 
	
		// ** QC code from necros **
		// Move the demon forward 16 units and check if blocked
		self.pos1 = self.origin;
		self.ideal_yaw = vectoyaw(self.enemy.origin - self.pos1);
		// If move forward fails, move back and indicate no jump
		if (!walkmove(self.ideal_yaw, 16)) {
			setorigin(self, self.pos1);
			return;
		}
		
		setorigin(self, self.pos1);			// walkmove successful, move demon back
		self.jumptouch = world;				// Reset last object touched
		self.count = 0;						// Number of times jumped
		self.attack_state = AS_JUMP;		// JUMP JUMP JUMP!
	}
};

/*======================================================================
 ScorpionCheckAttack (high damage pincher)
======================================================================*/
void() ScorpionCheckAttack =
{
	//----------------------------------------------------------------------
	// Melee attack (CLAWS)
	//----------------------------------------------------------------------
	if (ai_checkmelee(MONAI_MELEESCORPION)) {
		self.attack_state = AS_MELEE;
		self.th_melee ();
		return;
	}
	//----------------------------------------------------------------------
	// If setup to be a turret, do range attacks
	//----------------------------------------------------------------------
	if (self.movespeed < 0) {
		if (time < self.attack_finished) return;
		SUB_AttackFinished (2 + random());
		self.attack_state = AS_MISSILE;
		return;
	}
	
	//----------------------------------------------------------------------
	// Range attack (JUMP/TAIL)
	//----------------------------------------------------------------------
	if (!enemy_vis) return;
	if (time < self.attack_finished) return;

	if (self.spawnflags & MON_SCORPION_STINGER) {
		// check for extra wide space to jump
		if (!visblocked_wide(self, self.view_ofs, self.enemy.view_ofs)) return;
		
		// Time for another jump?
		if (self.jump_flag < time) {
			self.enemydist = range_distance(self.enemy, TRUE);
			if (self.enemydist < MONAI_JUMPSCORPNEAR) return;
			if (self.enemydist > MONAI_JUMPSCORPFAR) return;

			self.jumptouch = world;		// Reset last object touched
			self.count = 0;				// Number of times jumped
			self.attack_state = AS_JUMP;
		}
	}
	else {
		if (enemy_range == RANGE_MELEE) self.attack_chance = 0.9;		// range < 120 map units
		else if (enemy_range == RANGE_NEAR) self.attack_chance = 0.6;	// range < 500 map units
		else if (enemy_range == RANGE_MID) self.attack_chance = 0.2;	// range < 1000 map units
		else self.attack_chance = 0;
		if (random () < self.attack_chance) {
			SUB_AttackFinished (2 + random());
			self.attack_state = AS_MISSILE;
		}
	}
};

/*======================================================================
 DogCheckAttack
======================================================================*/
void()	DogCheckAttack =
{
	//----------------------------------------------------------------------
	// Melee attack (BITE)
	//----------------------------------------------------------------------
	// Check that within range of a bite attack
	if (ai_checkmelee(MONAI_MELEEDOG)) {
		self.attack_state = AS_MELEE;
		return;
	}
	//----------------------------------------------------------------------
	// If setup to be a turret, randomly do melee attacks
	//----------------------------------------------------------------------
	if (self.movespeed < 0) {
		if (random() < MONAI_TURRETMODE) return;
		self.attack_state = AS_MELEE;
		return;
	}
	//----------------------------------------------------------------------
	// Range attack (JUMP)
	//----------------------------------------------------------------------
	// Has the dog jumped less than 2 seconds ago?
	if (self.jump_flag < time) {
		// Stop the dog over or under jumping the enemy
		if (self.origin_z + self.mins_z > self.enemy.origin_z + self.enemy.mins_z
		+ 0.75 * self.enemy.size_z) return;
		if (self.origin_z + self.maxs_z < self.enemy.origin_z + self.enemy.mins_z
		+ 0.25 * self.enemy.size_z) return;
			
		self.enemydist = range_distance(self.enemy, TRUE);
		if (self.enemydist < MONAI_JUMPDOGNEAR) return;
		if (self.enemydist > MONAI_JUMPDOGFAR) return;

		// Check for enemy above? (z axis)
		if (self.enemy.origin_z > self.origin_z) return;
		self.jumptouch = world;			// Reset last object touched
		self.count = 0;					// Number of times jumped
		self.attack_state = AS_JUMP;
	}
};

/*======================================================================
 SpiderCheckAttack
======================================================================*/
void() SpiderCheckAttack =
{
	//----------------------------------------------------------------------
	// Melee attack (BITE)
	//----------------------------------------------------------------------
	// Check that within range of a bite attack
	if (ai_checkmelee(MONAI_MELEESPIDER)) {
		self.attack_state = AS_MELEE;
		return;
	}
	//----------------------------------------------------------------------
	// Range attack (Large Green Spider = SPIT)
	// Behaves like a wizards; strafe, spit goo
	//----------------------------------------------------------------------
	if (self.spawnflags & MON_SPIDER_LARGE) {
		if (!enemy_vis) return;
		if (time < self.attack_finished) return;

		// Does the monster have a clear shot to the player?
		// sightline can be blocked by other monsters
		if (enemy_range == RANGE_FAR || visblocked(self.enemy)) {
			if (self.attack_state != AS_STRAIGHT) {
				self.attack_state = AS_STRAIGHT;
				self.th_run ();
			}
			return;
		}

		if (enemy_range == RANGE_MELEE) self.attack_chance = 0.9;		// range < 120 map units
		else if (enemy_range == RANGE_NEAR) self.attack_chance = 0.6;	// range < 500 map units
		else if (enemy_range == RANGE_MID) self.attack_chance = 0.2;	// range < 1000 map units
		else self.attack_chance = 0;
		if (random () < self.attack_chance) {
			SUB_AttackFinished (2 + random());
			self.attack_state = AS_MISSILE;
		}
		else if (enemy_range == RANGE_MID) {
			if (self.attack_state != AS_STRAIGHT) {
				self.attack_state = AS_STRAIGHT;
				self.th_run ();
			}
		}
		else {
			if (self.attack_state != AS_SLIDING) {
				self.attack_state = AS_SLIDING;
				self.th_slide ();
			}
		}
	}
	//----------------------------------------------------------------------
	// Range attack (Small Brown Spider = JUMP)
	// Behaves like a dog; run and jump
	//----------------------------------------------------------------------
	else {
		// Is it time to jump?
		if (self.jump_flag < time) {
			// Stop the spider over or under jumping the enemy
			if (self.origin_z + self.mins_z > self.enemy.origin_z + self.enemy.mins_z
			+ 0.75 * self.enemy.size_z) return;
			if (self.origin_z + self.maxs_z < self.enemy.origin_z + self.enemy.mins_z
			+ 0.25 * self.enemy.size_z) return;
				
			self.enemydist = range_distance(self.enemy, TRUE);
			if (self.enemydist < MONAI_JUMPSPIDERNEAR) return;
			if (self.enemydist > MONAI_JUMPSPIDERFAR) return;
			// Check for enemy above? (z axis)
			if (self.enemy.origin_z > self.origin_z) return;
			self.jumptouch = world;		// Reset last object touched
			self.count = 0;				// Number of times jumped
			self.attack_state = AS_JUMP;
		}
	}
};

/*======================================================================
 VorelingCheckAttack
======================================================================*/
void() VorelingCheckAttack =
{
	//----------------------------------------------------------------------
	// Melee attack (BITE)
	//----------------------------------------------------------------------
	// Check that within range of a bite attack
	if (ai_checkmelee(MONAI_MELEEVORELING)) {
		self.attack_state = AS_MELEE;
		return;
	}
	//----------------------------------------------------------------------
	// Range attack (JUMP)
	//----------------------------------------------------------------------
	// Is it time to jump?
	if (self.jump_flag < time) {
		// Stop the voreling over or under jumping the enemy
		if (self.origin_z + self.mins_z > self.enemy.origin_z + self.enemy.mins_z
		+ 0.75 * self.enemy.size_z) return;
		if (self.origin_z + self.maxs_z < self.enemy.origin_z + self.enemy.mins_z
		+ 0.25 * self.enemy.size_z) return;
			
		// Too close/far?
		self.enemydist = range_distance(self.enemy, TRUE);
		if (self.enemydist < MONAI_JUMPVORELINGNEAR) return;
		if (self.enemydist > MONAI_JUMPVORELINGFAR) return;
		// Check for enemy above? (z axis)
		if (self.enemy.origin_z > self.origin_z) return;
		self.jumptouch = world;			// Reset last object touched
		self.count = 0;					// Number of times jumped
		self.attack_state = AS_JUMP;
	}
};

/*======================================================================
 Check if the AI is blocked by a breakable object in the way 
======================================================================*/
void() CheckBlockedBreakable =
{
	local vector	spot1, spot2, brkorg;
	local float brklen;

	// Still busy attacking? do nothing	
	if (time < self.attack_finished) return;
		
	// FIXME : there needs to be check on the breakable health
	// otherwise the monster will be stuck constantly attacking the breakable

	// Check for breakables from middle of models (not head height)
	spot1 = self.origin;
	spot2 = self.enemy.origin;
	traceline (spot1, spot2, TRUE, self);	// see through other monsters
	
	if (trace_ent.classtype != CT_FUNCBREAK) {
		// Check for breakables from top of models
		spot1 = self.origin + self.view_ofs;
		spot2 = self.enemy.origin + self.enemy.view_ofs;
		traceline (spot1, spot2, TRUE, self);	// see through other monsters
	}		

	if (ai_foundbreakable(self, trace_ent,FALSE)) {
		// Find origin of breakable, check for bmodel 0,0,0 origins
		if (trace_ent.bsporigin) brkorg = bmodel_origin(trace_ent);
		else brkorg = trace_ent.origin;
		brklen = fabs(vlen(self.origin - brkorg));
		SUB_AttackFinished (1+random());
		
		// Check breakable within melee/missile range?
		if (brklen < MONAI_MELEEKNIGHT && self.th_melee) self.attack_state = AS_MELEE;
		else if (self.th_missile) self.attack_state = AS_MISSILE;
	}
};
